after_merge,before_merge,filename,full_file_code_after_merge,full_file_code_before_merge,function_name,url,source code and errors,full_traceback,traceback_type,before_merge_without_docstrings,after_merge_without_docstrings,before_merge_docstrings,after_merge_docstrings,path_to_snippet_before_merge,path_to_snippet_after_merge
"def plot(result_pickle_file_path, show, plot_save_file):
    """"""
    [sys_analyser] draw result DataFrame
    """"""
    import pandas as pd
    from .plot import plot_result

    result_dict = pd.read_pickle(result_pickle_file_path)
    plot_result(result_dict, show, plot_save_file)","def plot(result_dict_file, show, plot_save_file):
    """"""
    [sys_analyser] draw result DataFrame
    """"""
    import pandas as pd
    from .plot import plot_result

    result_dict = pd.read_pickle(result_dict_file)
    plot_result(result_dict, show, plot_save_file)",rqalpha/mod/rqalpha_mod_sys_analyser/__init__.py,"# -*- coding: utf-8 -*-
#
# Copyright 2017 Ricequant, Inc
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import click
from rqalpha.__main__ import cli

__config__ = {
    # 当不输出csv/pickle/plot 等内容时，可以通过 record 来决定是否执行该 Mod 的计算逻辑
    ""record"": True,
    # 如果指定路径，则输出计算后的 pickle 文件
    ""output_file"": None,
    # 如果指定路径，则输出 report csv 文件
    ""report_save_path"": None,
    # 画图
    'plot': False,
    # 如果指定路径，则输出 plot 对应的图片文件
    'plot_save_file': None,
}


def load_mod():
    from .mod import AnalyserMod
    return AnalyserMod()


""""""
--report
--output-file

""""""
cli.commands['run'].params.append(
    click.Option(
        ('--report', 'mod__sys_analyser__report_save_path'),
        type=click.Path(writable=True),
        help=""[sys_analyser] save report""
    )
)
cli.commands['run'].params.append(
    click.Option(
        ('-o', '--output-file', 'mod__sys_analyser__output_file'),
        type=click.Path(writable=True),
        help=""[sys_analyser] output result pickle file""
    )
)
cli.commands['run'].params.append(
    click.Option(
        ('-p', '--plot/--no-plot', 'mod__sys_analyser__plot'),
        default=None,
        help=""[sys_analyser] plot result""
    )
)
cli.commands['run'].params.append(
    click.Option(
        ('--plot-save', 'mod__sys_analyser__plot_save_file'),
        default=None,
        help=""[sys_analyser] save plot to file""
    )
)


@cli.command()
@click.argument('result_pickle_file_path', type=click.Path(exists=True), required=True)
@click.option('--show/--hide', 'show', default=True)
@click.option('--plot-save', 'plot_save_file', default=None, type=click.Path(), help=""save plot result to file"")
def plot(result_pickle_file_path, show, plot_save_file):
    """"""
    [sys_analyser] draw result DataFrame
    """"""
    import pandas as pd
    from .plot import plot_result

    result_dict = pd.read_pickle(result_pickle_file_path)
    plot_result(result_dict, show, plot_save_file)


@cli.command()
@click.argument('result_pickle_file_path', type=click.Path(exists=True), required=True)
@click.argument('target_report_csv_path', type=click.Path(exists=True, writable=True), required=True)
def report(result_pickle_file_path, target_report_csv_path):
    """"""
    [sys_analyser] Generate report from backtest output file
    """"""
    import pandas as pd
    result_dict = pd.read_pickle(result_pickle_file_path)

    from .report import generate_report
    generate_report(result_dict, target_report_csv_path)
","# -*- coding: utf-8 -*-
#
# Copyright 2017 Ricequant, Inc
#
# Licensed under the Apache License, Version 2.0 (the ""License"");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an ""AS IS"" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import click
from rqalpha.__main__ import cli

__config__ = {
    # 当不输出csv/pickle/plot 等内容时，可以通过 record 来决定是否执行该 Mod 的计算逻辑
    ""record"": True,
    # 如果指定路径，则输出计算后的 pickle 文件
    ""output_file"": None,
    # 如果指定路径，则输出 report csv 文件
    ""report_save_path"": None,
    # 画图
    'plot': False,
    # 如果指定路径，则输出 plot 对应的图片文件
    'plot_save_file': None,
}


def load_mod():
    from .mod import AnalyserMod
    return AnalyserMod()


""""""
--report
--output-file

""""""
cli.commands['run'].params.append(
    click.Option(
        ('--report', 'mod__sys_analyser__report_save_path'),
        type=click.Path(writable=True),
        help=""[sys_analyser] save report""
    )
)
cli.commands['run'].params.append(
    click.Option(
        ('-o', '--output-file', 'mod__sys_analyser__output_file'),
        type=click.Path(writable=True),
        help=""[sys_analyser] output result pickle file""
    )
)
cli.commands['run'].params.append(
    click.Option(
        ('-p', '--plot/--no-plot', 'mod__sys_analyser__plot'),
        default=None,
        help=""[sys_analyser] plot result""
    )
)
cli.commands['run'].params.append(
    click.Option(
        ('--plot-save', 'mod__sys_analyser__plot_save_file'),
        default=None,
        help=""[sys_analyser] save plot to file""
    )
)


@cli.command()
@click.argument('result_pickle_file_path', type=click.Path(exists=True), required=True)
@click.option('--show/--hide', 'show', default=True)
@click.option('--plot-save', 'plot_save_file', default=None, type=click.Path(), help=""save plot result to file"")
def plot(result_dict_file, show, plot_save_file):
    """"""
    [sys_analyser] draw result DataFrame
    """"""
    import pandas as pd
    from .plot import plot_result

    result_dict = pd.read_pickle(result_dict_file)
    plot_result(result_dict, show, plot_save_file)


@cli.command()
@click.argument('result_pickle_file_path', type=click.Path(exists=True), required=True)
@click.argument('target_report_csv_path', type=click.Path(exists=True, writable=True), required=True)
def report(result_pickle_file_path, target_report_csv_path):
    """"""
    [sys_analyser] Generate report from backtest output file
    """"""
    import pandas as pd
    result_dict = pd.read_pickle(result_pickle_file_path)

    from .report import generate_report
    generate_report(result_dict, target_report_csv_path)
",plot,https://github.com/ricequant/rqalpha/issues/109,"[{'piece_type': 'other', 'piece_content': 'rqalpha plot ./1.pkl --show'}, {'piece_type': 'error message', 'piece_content': 'Traceback (most recent call last):\nFile ""c:\\programdata\\anaconda2\\lib\\runpy.py"", line 174, in _run_module_as_main\n""__main__"", fname, loader, pkg_name)\nFile ""c:\\programdata\\anaconda2\\lib\\runpy.py"", line 72, in _run_code\nexec code in run_globals\n│       └ {\'__builtins__\': <module \'__builtin__\' (built-in)>, \'__file__\': \'C:\\ProgramData\\Anaconda2\\Scripts\\rqalpha.exe\\__main__.py\',...\nqalpha.exe\\__main__.py"", line 2>> at 0256EA40, file ""C:\\ProgramData\\Anaconda2\\Scripts\nFile ""C:\\ProgramData\\Anaconda2\\Scripts\\rqalpha.exe\\__main__.py"", line 9, in <module>\nsys.exit(entry_point())\n│        └ <function entry_point at 0x047D1CF0>\n└ <module \'sys\' (built-in)>\nFile ""c:\\programdata\\anaconda2\\lib\\site-packages\\rqalpha\\__main__.py"", line 66, in entry_point\ncli(obj={})\n└ <click.core.Group object at 0x047CFE90>\nFile ""c:\\programdata\\anaconda2\\lib\\site-packages\\click\\core.py"", line 722, in __call__\nreturn self.main(*args, **kwargs)\n│          │       └ {\'obj\': {\'VERBOSE\': 0}}\n│          └ ()\n└ <click.core.Group object at 0x047CFE90>\nFile ""c:\\programdata\\anaconda2\\lib\\site-packages\\click\\core.py"", line 697, in main\nrv = self.invoke(ctx)\n│           └ <click.core.Context object at 0x0482CC10>\n└ <click.core.Group object at 0x047CFE90>\nFile ""c:\\programdata\\anaconda2\\lib\\site-packages\\click\\core.py"", line 1066, in invoke\nreturn _process_result(sub_ctx.command.invoke(sub_ctx))\n│               │                      └ <click.core.Context object at 0x0482CE50>\n│               └ <click.core.Context object at 0x0482CE50>\n└ <function _process_result at 0x0482D5B0>\nFile ""c:\\programdata\\anaconda2\\lib\\site-packages\\click\\core.py"", line 895, in invoke\nreturn ctx.invoke(self.callback, **ctx.params)\n│          │                └ <click.core.Context object at 0x0482CE50>\n│          └ <click.core.Command object at 0x0482CF50>\n└ <click.core.Context object at 0x0482CE50>\nFile ""c:\\programdata\\anaconda2\\lib\\site-packages\\click\\core.py"", line 535, in invoke\nreturn callback(*args, **kwargs)\n│         │       └ {\'result_pickle_file_path\': u\'./1.pkl\', \'plot_save_file\': None, \'show\': True}\n│         └ ()\n└ <function plot at 0x0482D830>\nTypeError: plot() got an unexpected keyword argument \'result_pickle_file_path\''}]","Traceback (most recent call last):
File ""c:\programdata\anaconda2\lib\runpy.py"", line 174, in _run_module_as_main
""__main__"", fname, loader, pkg_name)
File ""c:\programdata\anaconda2\lib\runpy.py"", line 72, in _run_code
exec code in run_globals
│       └ {'__builtins__': <module '__builtin__' (built-in)>, '__file__': 'C:\ProgramData\Anaconda2\Scripts\rqalpha.exe\__main__.py',...
qalpha.exe\__main__.py"", line 2>> at 0256EA40, file ""C:\ProgramData\Anaconda2\Scripts
File ""C:\ProgramData\Anaconda2\Scripts\rqalpha.exe\__main__.py"", line 9, in <module>
sys.exit(entry_point())
│        └ <function entry_point at 0x047D1CF0>
└ <module 'sys' (built-in)>
File ""c:\programdata\anaconda2\lib\site-packages\rqalpha\__main__.py"", line 66, in entry_point
cli(obj={})
└ <click.core.Group object at 0x047CFE90>
File ""c:\programdata\anaconda2\lib\site-packages\click\core.py"", line 722, in __call__
return self.main(*args, **kwargs)
│          │       └ {'obj': {'VERBOSE': 0}}
│          └ ()
└ <click.core.Group object at 0x047CFE90>
File ""c:\programdata\anaconda2\lib\site-packages\click\core.py"", line 697, in main
rv = self.invoke(ctx)
│           └ <click.core.Context object at 0x0482CC10>
└ <click.core.Group object at 0x047CFE90>
File ""c:\programdata\anaconda2\lib\site-packages\click\core.py"", line 1066, in invoke
return _process_result(sub_ctx.command.invoke(sub_ctx))
│               │                      └ <click.core.Context object at 0x0482CE50>
│               └ <click.core.Context object at 0x0482CE50>
└ <function _process_result at 0x0482D5B0>
File ""c:\programdata\anaconda2\lib\site-packages\click\core.py"", line 895, in invoke
return ctx.invoke(self.callback, **ctx.params)
│          │                └ <click.core.Context object at 0x0482CE50>
│          └ <click.core.Command object at 0x0482CF50>
└ <click.core.Context object at 0x0482CE50>
File ""c:\programdata\anaconda2\lib\site-packages\click\core.py"", line 535, in invoke
return callback(*args, **kwargs)
│         │       └ {'result_pickle_file_path': u'./1.pkl', 'plot_save_file': None, 'show': True}
│         └ ()
└ <function plot at 0x0482D830>
TypeError: plot() got an unexpected keyword argument 'result_pickle_file_path'",TypeError,"def plot(result_dict_file, show, plot_save_file):
    
    import pandas as pd
    from .plot import plot_result

    result_dict = pd.read_pickle(result_dict_file)
    plot_result(result_dict, show, plot_save_file)","def plot(result_pickle_file_path, show, plot_save_file):
    
    import pandas as pd
    from .plot import plot_result

    result_dict = pd.read_pickle(result_pickle_file_path)
    plot_result(result_dict, show, plot_save_file)",['[sys_analyser] draw result DataFrame'],['[sys_analyser] draw result DataFrame'],buggy_snippets_files/e93817735d3042d739fe86677bf0a5e504909d0001570544368d640ee352b7d4_before_merge.py,buggy_snippets_files/e93817735d3042d739fe86677bf0a5e504909d0001570544368d640ee352b7d4_after_merge.py
"    def stream_logs(self):
        """"""Stream a pod's log.""""""
        for line in self.api.read_namespaced_pod_log(
                self.name,
                self.namespace,
                follow=True,
                _preload_content=False):
            # verify that the line is JSON
            line = line.decode('utf-8')
            try:
                json.loads(line)
            except ValueError:
                # log event wasn't JSON.
                # use the line itself as the message with unknown phase.
                # We don't know what the right phase is, use 'unknown'.
                # If it was a fatal error, presumably a 'failure'
                # message will arrive shortly.
                app_log.error(""log event not json: %r"", line)
                line = json.dumps({
                    'phase': 'unknown',
                    'message': line,
                })

            self.progress('log', line)","    def stream_logs(self):
        """"""Stream a pod's log.""""""
        for line in self.api.read_namespaced_pod_log(
                self.name,
                self.namespace,
                follow=True,
                _preload_content=False):

            self.progress('log', line.decode('utf-8'))",binderhub/build.py,"""""""
Contains build of a docker image from a git repository.
""""""

import json

from kubernetes import client, watch
from tornado.ioloop import IOLoop
from tornado.log import app_log


class Build:
    """"""Represents a build of a git repository into a docker image.

    This ultimately maps to a single pod on a kubernetes cluster. Many
    different build objects can point to this single pod and perform
    operations on the pod. The code in this class needs to be careful and take
    this into account.

    For example, operations a Build object tries might not succeed because
    another Build object pointing to the same pod might have done something
    else. This should be handled gracefully, and the build object should
    reflect the state of the pod as quickly as possible.

    ``name``
        The ``name`` should be unique and immutable since it is used to
        sync to the pod. The ``name`` should be unique for a
        ``(git_url, ref)`` tuple, and the same tuple should correspond
        to the same ``name``. This allows use of the locking provided by k8s
        API instead of having to invent our own locking code.

    """"""
    def __init__(self, q, api, name, namespace, git_url, ref, builder_image,
                 image_name, push_secret):
        self.q = q
        self.api = api
        self.git_url = git_url
        self.ref = ref
        self.name = name
        self.namespace = namespace
        self.image_name = image_name
        self.push_secret = push_secret
        self.builder_image = builder_image

    def get_cmd(self):
        """"""Get the cmd to run to build the image""""""
        cmd = [
            'jupyter-repo2docker',
            self.git_url,
            '--ref', self.ref,
            '--image', self.image_name,
            '--no-clean', '--no-run', '--json-logs',
        ]

        if self.push_secret:
            cmd.append('--push')

        return cmd

    def progress(self, kind, obj):
        """"""Put the current action item into the queue for execution.""""""
        IOLoop.instance().add_callback(self.q.put, {'kind': kind, 'payload': obj})

    def submit(self):
        """"""Submit a image spec to openshift's s2i and wait for completion """"""
        volume_mounts = [
            client.V1VolumeMount(mount_path=""/var/run/docker.sock"", name=""docker-socket"")
        ]
        volumes = [client.V1Volume(
            name=""docker-socket"",
            host_path=client.V1HostPathVolumeSource(path=""/var/run/docker.sock"")
        )]

        if self.push_secret:
            volume_mounts.append(client.V1VolumeMount(mount_path=""/root/.docker"", name='docker-push-secret'))
            volumes.append(client.V1Volume(
                name='docker-push-secret',
                secret=client.V1SecretVolumeSource(secret_name=self.push_secret)
            ))

        self.pod = client.V1Pod(
            metadata=client.V1ObjectMeta(
                name=self.name,
                labels={""name"": self.name}
            ),
            spec=client.V1PodSpec(
                containers=[
                    client.V1Container(
                        image=self.builder_image,
                        name=""builder"",
                        args=self.get_cmd(),
                        image_pull_policy='Always',
                        volume_mounts=volume_mounts,
                    )
                ],
                volumes=volumes,
                restart_policy=""Never""
            )
        )

        try:
            ret = self.api.create_namespaced_pod(self.namespace, self.pod)
        except client.rest.ApiException as e:
            if e.status == 409:
                # Someone else created it!
                pass
            else:
                raise

        w = watch.Watch()
        try:
            for f in w.stream(
                    self.api.list_namespaced_pod,
                    self.namespace,
                    label_selector=""name={}"".format(self.name)):
                if f['type'] == 'DELETED':
                    self.progress('pod.phasechange', 'Deleted')
                    return
                self.pod = f['object']
                self.progress('pod.phasechange', self.pod.status.phase)
                if self.pod.status.phase == 'Succeeded':
                    self.cleanup()
                elif self.pod.status.phase == 'Failed':
                    self.cleanup()
        finally:
            w.stop()

    def stream_logs(self):
        """"""Stream a pod's log.""""""
        for line in self.api.read_namespaced_pod_log(
                self.name,
                self.namespace,
                follow=True,
                _preload_content=False):
            # verify that the line is JSON
            line = line.decode('utf-8')
            try:
                json.loads(line)
            except ValueError:
                # log event wasn't JSON.
                # use the line itself as the message with unknown phase.
                # We don't know what the right phase is, use 'unknown'.
                # If it was a fatal error, presumably a 'failure'
                # message will arrive shortly.
                app_log.error(""log event not json: %r"", line)
                line = json.dumps({
                    'phase': 'unknown',
                    'message': line,
                })

            self.progress('log', line)

    def cleanup(self):
        """"""Delete a kubernetes pod.""""""
        try:
            self.api.delete_namespaced_pod(
                name=self.name,
                namespace=self.namespace,
                body=client.V1DeleteOptions(grace_period_seconds=0))
        except client.rest.ApiException as e:
            if e.status == 404:
                # Is ok, someone else has already deleted it
                pass
            else:
                raise
","""""""
Contains build of a docker image from a git repository.
""""""

from kubernetes import client, watch
from tornado.ioloop import IOLoop

class Build:
    """"""Represents a build of a git repository into a docker image.

    This ultimately maps to a single pod on a kubernetes cluster. Many
    different build objects can point to this single pod and perform
    operations on the pod. The code in this class needs to be careful and take
    this into account.

    For example, operations a Build object tries might not succeed because
    another Build object pointing to the same pod might have done something
    else. This should be handled gracefully, and the build object should
    reflect the state of the pod as quickly as possible.

    ``name``
        The ``name`` should be unique and immutable since it is used to
        sync to the pod. The ``name`` should be unique for a
        ``(git_url, ref)`` tuple, and the same tuple should correspond
        to the same ``name``. This allows use of the locking provided by k8s
        API instead of having to invent our own locking code.

    """"""
    def __init__(self, q, api, name, namespace, git_url, ref, builder_image,
                 image_name, push_secret):
        self.q = q
        self.api = api
        self.git_url = git_url
        self.ref = ref
        self.name = name
        self.namespace = namespace
        self.image_name = image_name
        self.push_secret = push_secret
        self.builder_image = builder_image

    def get_cmd(self):
        """"""Get the cmd to run to build the image""""""
        cmd = [
            'jupyter-repo2docker',
            self.git_url,
            '--ref', self.ref,
            '--image', self.image_name,
            '--no-clean', '--no-run', '--json-logs',
        ]

        if self.push_secret:
            cmd.append('--push')

        return cmd

    def progress(self, kind, obj):
        """"""Put the current action item into the queue for execution.""""""
        IOLoop.instance().add_callback(self.q.put, {'kind': kind, 'payload': obj})

    def submit(self):
        """"""Submit a image spec to openshift's s2i and wait for completion """"""
        volume_mounts = [
            client.V1VolumeMount(mount_path=""/var/run/docker.sock"", name=""docker-socket"")
        ]
        volumes = [client.V1Volume(
            name=""docker-socket"",
            host_path=client.V1HostPathVolumeSource(path=""/var/run/docker.sock"")
        )]

        if self.push_secret:
            volume_mounts.append(client.V1VolumeMount(mount_path=""/root/.docker"", name='docker-push-secret'))
            volumes.append(client.V1Volume(
                name='docker-push-secret',
                secret=client.V1SecretVolumeSource(secret_name=self.push_secret)
            ))

        self.pod = client.V1Pod(
            metadata=client.V1ObjectMeta(
                name=self.name,
                labels={""name"": self.name}
            ),
            spec=client.V1PodSpec(
                containers=[
                    client.V1Container(
                        image=self.builder_image,
                        name=""builder"",
                        args=self.get_cmd(),
                        image_pull_policy='Always',
                        volume_mounts=volume_mounts,
                    )
                ],
                volumes=volumes,
                restart_policy=""Never""
            )
        )

        try:
            ret = self.api.create_namespaced_pod(self.namespace, self.pod)
        except client.rest.ApiException as e:
            if e.status == 409:
                # Someone else created it!
                pass
            else:
                raise

        w = watch.Watch()
        try:
            for f in w.stream(
                    self.api.list_namespaced_pod,
                    self.namespace,
                    label_selector=""name={}"".format(self.name)):
                if f['type'] == 'DELETED':
                    self.progress('pod.phasechange', 'Deleted')
                    return
                self.pod = f['object']
                self.progress('pod.phasechange', self.pod.status.phase)
                if self.pod.status.phase == 'Succeeded':
                    self.cleanup()
                elif self.pod.status.phase == 'Failed':
                    self.cleanup()
        finally:
            w.stop()

    def stream_logs(self):
        """"""Stream a pod's log.""""""
        for line in self.api.read_namespaced_pod_log(
                self.name,
                self.namespace,
                follow=True,
                _preload_content=False):

            self.progress('log', line.decode('utf-8'))

    def cleanup(self):
        """"""Delete a kubernetes pod.""""""
        try:
            self.api.delete_namespaced_pod(
                name=self.name,
                namespace=self.namespace,
                body=client.V1DeleteOptions(grace_period_seconds=0))
        except client.rest.ApiException as e:
            if e.status == 404:
                # Is ok, someone else has already deleted it
                pass
            else:
                raise
",Build.stream_logs,https://github.com/jupyterhub/binderhub/issues/164,"[{'piece_type': 'error message', 'piece_content': '/ # jupyter-repo2docker https://github.com/yuvipanda/example-requirements --json-logs\nTraceback (most recent call last):\nFile ""/usr/local/bin/jupyter-repo2docker"", line 11, in <module>\nload_entry_point(\'jupyter-repo2docker==0.4.1\', \'console_scripts\', \'jupyter-repo2docker\')()\nFile ""/usr/local/lib/python3.6/site-packages/repo2docker/__main__.py"", line 6, in main\nf.start()\nFile ""/usr/local/lib/python3.6/site-packages/repo2docker/app.py"", line 309, in start\ncheckout_path\nFile ""/usr/local/lib/python3.6/site-packages/repo2docker/app.py"", line 95, in fetch\ncapture=self.json_logs):\nFile ""/usr/local/lib/python3.6/site-packages/repo2docker/utils.py"", line 12, in execute_cmd\nproc = subprocess.Popen(cmd, **kwargs)\nFile ""/usr/local/lib/python3.6/subprocess.py"", line 709, in __init__\nrestore_signals, start_new_session)\nFile ""/usr/local/lib/python3.6/subprocess.py"", line 1344, in _execute_child\nraise child_exception_type(errno_num, err_msg, err_filename)\nFileNotFoundError: [Errno 2] No such file or directory: \'git\': \'git\''}]","/ # jupyter-repo2docker https://github.com/yuvipanda/example-requirements --json-logs
Traceback (most recent call last):
File ""/usr/local/bin/jupyter-repo2docker"", line 11, in <module>
load_entry_point('jupyter-repo2docker==0.4.1', 'console_scripts', 'jupyter-repo2docker')()
File ""/usr/local/lib/python3.6/site-packages/repo2docker/__main__.py"", line 6, in main
f.start()
File ""/usr/local/lib/python3.6/site-packages/repo2docker/app.py"", line 309, in start
checkout_path
File ""/usr/local/lib/python3.6/site-packages/repo2docker/app.py"", line 95, in fetch
capture=self.json_logs):
File ""/usr/local/lib/python3.6/site-packages/repo2docker/utils.py"", line 12, in execute_cmd
proc = subprocess.Popen(cmd, **kwargs)
File ""/usr/local/lib/python3.6/subprocess.py"", line 709, in __init__
restore_signals, start_new_session)
File ""/usr/local/lib/python3.6/subprocess.py"", line 1344, in _execute_child
raise child_exception_type(errno_num, err_msg, err_filename)
FileNotFoundError: [Errno 2] No such file or directory: 'git': 'git'",FileNotFoundError,"    def stream_logs(self):
        
        for line in self.api.read_namespaced_pod_log(
                self.name,
                self.namespace,
                follow=True,
                _preload_content=False):

            self.progress('log', line.decode('utf-8'))","    def stream_logs(self):
        
        for line in self.api.read_namespaced_pod_log(
                self.name,
                self.namespace,
                follow=True,
                _preload_content=False):
            
            line = line.decode('utf-8')
            try:
                json.loads(line)
            except ValueError:
                
                
                
                
                
                app_log.error(""log event not json: %r"", line)
                line = json.dumps({
                    'phase': 'unknown',
                    'message': line,
                })

            self.progress('log', line)",[],[],buggy_snippets_files/8241189c4267b81254c9ed07a3c93d023527169e60eaa0df03b88951d9dd5d29_before_merge.py,buggy_snippets_files/8241189c4267b81254c9ed07a3c93d023527169e60eaa0df03b88951d9dd5d29_after_merge.py
"    def addRecentProjectFile(self, projectFile):
        projectFile = QUrl(projectFile).toLocalFile()
        projects = self._recentProjectFiles()

        # remove duplicates while preserving order
        from collections import OrderedDict
        uniqueProjects = OrderedDict.fromkeys(projects)
        projects = list(uniqueProjects)
        # remove previous usage of the value
        if projectFile in uniqueProjects:
            projects.remove(projectFile)
        # add the new value in the first place
        projects.insert(0, projectFile)

        # keep only the 10 first elements
        projects = projects[0:20]

        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginWriteArray(""Projects"")
        for i, p in enumerate(projects):
            settings.setArrayIndex(i)
            settings.setValue(""filepath"", p)
        settings.endArray()
        settings.sync()

        self.recentProjectFilesChanged.emit()","    def addRecentProjectFile(self, projectFile):
        projectFile = QUrl(projectFile).path()
        projects = self._recentProjectFiles()

        # remove duplicates while preserving order
        from collections import OrderedDict
        uniqueProjects = OrderedDict.fromkeys(projects)
        projects = list(uniqueProjects)
        # remove previous usage of the value
        if projectFile in uniqueProjects:
            projects.remove(projectFile)
        # add the new value in the first place
        projects.insert(0, projectFile)

        # keep only the 10 first elements
        projects = projects[0:20]

        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginWriteArray(""Projects"")
        for i, p in enumerate(projects):
            settings.setArrayIndex(i)
            settings.setValue(""filepath"", p)
        settings.endArray()
        settings.sync()

        self.recentProjectFilesChanged.emit()",meshroom/ui/app.py,"import logging
import os
import argparse

from PySide2.QtCore import Qt, QUrl, Slot, QJsonValue, Property, Signal, qInstallMessageHandler, QtMsgType, QSettings
from PySide2.QtGui import QIcon
from PySide2.QtWidgets import QApplication

import meshroom
from meshroom.core import nodesDesc
from meshroom.ui import components
from meshroom.ui.components.clipboard import ClipboardHelper
from meshroom.ui.components.filepath import FilepathHelper
from meshroom.ui.components.scene3D import Scene3DHelper
from meshroom.ui.palette import PaletteManager
from meshroom.ui.reconstruction import Reconstruction
from meshroom.ui.utils import QmlInstantEngine


class MessageHandler(object):
    """"""
    MessageHandler that translates Qt logs to Python logging system.
    Also contains and filters a list of blacklisted QML warnings that end up in the
    standard error even when setOutputWarningsToStandardError is set to false on the engine.
    """"""

    outputQmlWarnings = bool(os.environ.get(""MESHROOM_OUTPUT_QML_WARNINGS"", False))

    logFunctions = {
        QtMsgType.QtDebugMsg: logging.debug,
        QtMsgType.QtWarningMsg: logging.warning,
        QtMsgType.QtInfoMsg: logging.info,
        QtMsgType.QtFatalMsg: logging.fatal,
        QtMsgType.QtCriticalMsg: logging.critical,
        QtMsgType.QtSystemMsg: logging.critical
    }

    # Warnings known to be inoffensive and related to QML but not silenced
    # even when 'MESHROOM_OUTPUT_QML_WARNINGS' is set to False
    qmlWarningsBlacklist = (
        'Failed to download scene at QUrl("""")',
        'QVariant(Invalid) Please check your QParameters',
        'Texture will be invalid for this frame',
    )

    @classmethod
    def handler(cls, messageType, context, message):
        """""" Message handler remapping Qt logs to Python logging system. """"""
        # discard blacklisted Qt messages related to QML when 'output qml warnings' is set to false
        if not cls.outputQmlWarnings and any(w in message for w in cls.qmlWarningsBlacklist):
            return
        MessageHandler.logFunctions[messageType](message)


class MeshroomApp(QApplication):
    """""" Meshroom UI Application. """"""
    def __init__(self, args):
        QtArgs = [args[0], '-style', 'fusion'] + args[1:]  # force Fusion style by default

        parser = argparse.ArgumentParser(prog=args[0], description='Launch Meshroom UI.', add_help=True)

        parser.add_argument('project', metavar='PROJECT', type=str, nargs='?',
                            help='Meshroom project file (e.g. myProject.mg) or folder with images to reconstruct.')
        parser.add_argument('-i', '--import', metavar='IMAGES/FOLDERS', type=str, nargs='*',
                            help='Import images or folder with images to reconstruct.')
        parser.add_argument('-I', '--importRecursive', metavar='FOLDERS', type=str, nargs='*',
                            help='Import images to reconstruct from specified folder and sub-folders.')
        parser.add_argument('-s', '--save', metavar='PROJECT.mg', type=str, default='',
                            help='Save the created scene.')
        parser.add_argument('-p', '--pipeline', metavar='MESHROOM_FILE/photogrammetry/hdri', type=str, default=os.environ.get(""MESHROOM_DEFAULT_PIPELINE"", ""photogrammetry""),
                            help='Override the default Meshroom pipeline with this external graph.')
        parser.add_argument(""--verbose"", help=""Verbosity level"", default='warning',
                            choices=['fatal', 'error', 'warning', 'info', 'debug', 'trace'],)

        args = parser.parse_args(args[1:])

        logStringToPython = {
            'fatal': logging.FATAL,
            'error': logging.ERROR,
            'warning': logging.WARNING,
            'info': logging.INFO,
            'debug': logging.DEBUG,
            'trace': logging.DEBUG,
        }
        logging.getLogger().setLevel(logStringToPython[args.verbose])

        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)

        super(MeshroomApp, self).__init__(QtArgs)

        self.setOrganizationName('AliceVision')
        self.setApplicationName('Meshroom')
        self.setApplicationVersion(meshroom.__version_name__)

        font = self.font()
        font.setPointSize(9)
        self.setFont(font)

        pwd = os.path.dirname(__file__)
        self.setWindowIcon(QIcon(os.path.join(pwd, ""img/meshroom.svg"")))

        # QML engine setup
        qmlDir = os.path.join(pwd, ""qml"")
        url = os.path.join(qmlDir, ""main.qml"")
        self.engine = QmlInstantEngine()
        self.engine.addFilesFromDirectory(qmlDir, recursive=True)
        self.engine.setWatching(os.environ.get(""MESHROOM_INSTANT_CODING"", False))
        # whether to output qml warnings to stderr (disable by default)
        self.engine.setOutputWarningsToStandardError(MessageHandler.outputQmlWarnings)
        qInstallMessageHandler(MessageHandler.handler)

        self.engine.addImportPath(qmlDir)
        components.registerTypes()

        # expose available node types that can be instantiated
        self.engine.rootContext().setContextProperty(""_nodeTypes"", sorted(nodesDesc.keys()))

        # instantiate Reconstruction object
        r = Reconstruction(defaultPipeline=args.pipeline, parent=self)
        self.engine.rootContext().setContextProperty(""_reconstruction"", r)

        # those helpers should be available from QML Utils module as singletons, but:
        #  - qmlRegisterUncreatableType is not yet available in PySide2
        #  - declaring them as singleton in qmldir file causes random crash at exit
        # => expose them as context properties instead
        self.engine.rootContext().setContextProperty(""Filepath"", FilepathHelper(parent=self))
        self.engine.rootContext().setContextProperty(""Scene3DHelper"", Scene3DHelper(parent=self))
        self.engine.rootContext().setContextProperty(""Clipboard"", ClipboardHelper(parent=self))

        # additional context properties
        self.engine.rootContext().setContextProperty(""_PaletteManager"", PaletteManager(self.engine, parent=self))
        self.engine.rootContext().setContextProperty(""MeshroomApp"", self)

        # request any potential computation to stop on exit
        self.aboutToQuit.connect(r.stopChildThreads)

        if args.project and not os.path.isfile(args.project):
            raise RuntimeError(
                ""Meshroom Command Line Error: 'PROJECT' argument should be a Meshroom project file (.mg).\n""
                ""Invalid value: '{}'"".format(args.project))

        if args.project:
            r.load(args.project)
            self.addRecentProjectFile(args.project)
        else:
            r.new()

        # import is a python keyword, so we have to access the attribute by a string
        if getattr(args, ""import"", None):
            r.importImagesFromFolder(getattr(args, ""import""), recursive=False)

        if args.importRecursive:
            r.importImagesFromFolder(args.importRecursive, recursive=True)

        if args.save:
            if os.path.isfile(args.save):
                raise RuntimeError(
                    ""Meshroom Command Line Error: Cannot save the new Meshroom project as the file (.mg) already exists.\n""
                    ""Invalid value: '{}'"".format(args.save))
            projectFolder = os.path.dirname(args.save)
            if not os.path.isdir(projectFolder):
                if not os.path.isdir(os.path.dirname(projectFolder)):
                    raise RuntimeError(
                        ""Meshroom Command Line Error: Cannot save the new Meshroom project file (.mg) as the parent of the folder does not exists.\n""
                        ""Invalid value: '{}'"".format(args.save))
                os.mkdir(projectFolder)
            r.saveAs(args.save)
            self.addRecentProjectFile(args.save)

        self.engine.load(os.path.normpath(url))

    def _recentProjectFiles(self):
        projects = []
        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginReadArray(""Projects"")
        for i in range(size):
            settings.setArrayIndex(i)
            p = settings.value(""filepath"")
            if p:
                projects.append(p)
        settings.endArray()
        return projects

    @Slot(str)
    def addRecentProjectFile(self, projectFile):
        projectFile = QUrl(projectFile).toLocalFile()
        projects = self._recentProjectFiles()

        # remove duplicates while preserving order
        from collections import OrderedDict
        uniqueProjects = OrderedDict.fromkeys(projects)
        projects = list(uniqueProjects)
        # remove previous usage of the value
        if projectFile in uniqueProjects:
            projects.remove(projectFile)
        # add the new value in the first place
        projects.insert(0, projectFile)

        # keep only the 10 first elements
        projects = projects[0:20]

        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginWriteArray(""Projects"")
        for i, p in enumerate(projects):
            settings.setArrayIndex(i)
            settings.setValue(""filepath"", p)
        settings.endArray()
        settings.sync()

        self.recentProjectFilesChanged.emit()

    @Slot(str, result=str)
    def markdownToHtml(self, md):
        """"""
        Convert markdown to HTML.

        Args:
            md (str): the markdown text to convert

        Returns:
            str: the resulting HTML string
        """"""
        try:
            from markdown import markdown
        except ImportError:
            logging.warning(""Can't import markdown module, returning source markdown text."")
            return md
        return markdown(md)

    @Property(QJsonValue, constant=True)
    def systemInfo(self):
        import platform
        import sys
        return {
            'platform': '{} {}'.format(platform.system(), platform.release()),
            'python': 'Python {}'.format(sys.version.split("" "")[0])
        }

    @Property(""QVariantList"", constant=True)
    def licensesModel(self):
        """"""
        Get info about open-source licenses for the application.
        Model provides:
            title: the name of the project
            localUrl: the local path to COPYING.md
            onlineUrl: the remote path to COPYING.md
        """"""
        rootDir = os.environ.get(""MESHROOM_INSTALL_DIR"", os.getcwd())
        return [
            {
                ""title"": ""Meshroom"",
                ""localUrl"": os.path.join(rootDir, ""COPYING.md""),
                ""onlineUrl"": ""https://raw.githubusercontent.com/alicevision/meshroom/develop/COPYING.md""
            },
            {
                ""title"": ""AliceVision"",
                ""localUrl"": os.path.join(rootDir, ""aliceVision"", ""share"", ""aliceVision"", ""COPYING.md""),
                ""onlineUrl"": ""https://raw.githubusercontent.com/alicevision/AliceVision/develop/COPYING.md""
            }
        ]

    recentProjectFilesChanged = Signal()
    recentProjectFiles = Property(""QVariantList"", _recentProjectFiles, notify=recentProjectFilesChanged)

","import logging
import os
import argparse

from PySide2.QtCore import Qt, QUrl, Slot, QJsonValue, Property, Signal, qInstallMessageHandler, QtMsgType, QSettings
from PySide2.QtGui import QIcon
from PySide2.QtWidgets import QApplication

import meshroom
from meshroom.core import nodesDesc
from meshroom.ui import components
from meshroom.ui.components.clipboard import ClipboardHelper
from meshroom.ui.components.filepath import FilepathHelper
from meshroom.ui.components.scene3D import Scene3DHelper
from meshroom.ui.palette import PaletteManager
from meshroom.ui.reconstruction import Reconstruction
from meshroom.ui.utils import QmlInstantEngine


class MessageHandler(object):
    """"""
    MessageHandler that translates Qt logs to Python logging system.
    Also contains and filters a list of blacklisted QML warnings that end up in the
    standard error even when setOutputWarningsToStandardError is set to false on the engine.
    """"""

    outputQmlWarnings = bool(os.environ.get(""MESHROOM_OUTPUT_QML_WARNINGS"", False))

    logFunctions = {
        QtMsgType.QtDebugMsg: logging.debug,
        QtMsgType.QtWarningMsg: logging.warning,
        QtMsgType.QtInfoMsg: logging.info,
        QtMsgType.QtFatalMsg: logging.fatal,
        QtMsgType.QtCriticalMsg: logging.critical,
        QtMsgType.QtSystemMsg: logging.critical
    }

    # Warnings known to be inoffensive and related to QML but not silenced
    # even when 'MESHROOM_OUTPUT_QML_WARNINGS' is set to False
    qmlWarningsBlacklist = (
        'Failed to download scene at QUrl("""")',
        'QVariant(Invalid) Please check your QParameters',
        'Texture will be invalid for this frame',
    )

    @classmethod
    def handler(cls, messageType, context, message):
        """""" Message handler remapping Qt logs to Python logging system. """"""
        # discard blacklisted Qt messages related to QML when 'output qml warnings' is set to false
        if not cls.outputQmlWarnings and any(w in message for w in cls.qmlWarningsBlacklist):
            return
        MessageHandler.logFunctions[messageType](message)


class MeshroomApp(QApplication):
    """""" Meshroom UI Application. """"""
    def __init__(self, args):
        QtArgs = [args[0], '-style', 'fusion'] + args[1:]  # force Fusion style by default

        parser = argparse.ArgumentParser(prog=args[0], description='Launch Meshroom UI.', add_help=True)

        parser.add_argument('project', metavar='PROJECT', type=str, nargs='?',
                            help='Meshroom project file (e.g. myProject.mg) or folder with images to reconstruct.')
        parser.add_argument('-i', '--import', metavar='IMAGES/FOLDERS', type=str, nargs='*',
                            help='Import images or folder with images to reconstruct.')
        parser.add_argument('-I', '--importRecursive', metavar='FOLDERS', type=str, nargs='*',
                            help='Import images to reconstruct from specified folder and sub-folders.')
        parser.add_argument('-s', '--save', metavar='PROJECT.mg', type=str, default='',
                            help='Save the created scene.')
        parser.add_argument('-p', '--pipeline', metavar='MESHROOM_FILE/photogrammetry/hdri', type=str, default=os.environ.get(""MESHROOM_DEFAULT_PIPELINE"", ""photogrammetry""),
                            help='Override the default Meshroom pipeline with this external graph.')
        parser.add_argument(""--verbose"", help=""Verbosity level"", default='warning',
                            choices=['fatal', 'error', 'warning', 'info', 'debug', 'trace'],)

        args = parser.parse_args(args[1:])

        logStringToPython = {
            'fatal': logging.FATAL,
            'error': logging.ERROR,
            'warning': logging.WARNING,
            'info': logging.INFO,
            'debug': logging.DEBUG,
            'trace': logging.DEBUG,
        }
        logging.getLogger().setLevel(logStringToPython[args.verbose])

        QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)

        super(MeshroomApp, self).__init__(QtArgs)

        self.setOrganizationName('AliceVision')
        self.setApplicationName('Meshroom')
        self.setApplicationVersion(meshroom.__version_name__)

        font = self.font()
        font.setPointSize(9)
        self.setFont(font)

        pwd = os.path.dirname(__file__)
        self.setWindowIcon(QIcon(os.path.join(pwd, ""img/meshroom.svg"")))

        # QML engine setup
        qmlDir = os.path.join(pwd, ""qml"")
        url = os.path.join(qmlDir, ""main.qml"")
        self.engine = QmlInstantEngine()
        self.engine.addFilesFromDirectory(qmlDir, recursive=True)
        self.engine.setWatching(os.environ.get(""MESHROOM_INSTANT_CODING"", False))
        # whether to output qml warnings to stderr (disable by default)
        self.engine.setOutputWarningsToStandardError(MessageHandler.outputQmlWarnings)
        qInstallMessageHandler(MessageHandler.handler)

        self.engine.addImportPath(qmlDir)
        components.registerTypes()

        # expose available node types that can be instantiated
        self.engine.rootContext().setContextProperty(""_nodeTypes"", sorted(nodesDesc.keys()))

        # instantiate Reconstruction object
        r = Reconstruction(defaultPipeline=args.pipeline, parent=self)
        self.engine.rootContext().setContextProperty(""_reconstruction"", r)

        # those helpers should be available from QML Utils module as singletons, but:
        #  - qmlRegisterUncreatableType is not yet available in PySide2
        #  - declaring them as singleton in qmldir file causes random crash at exit
        # => expose them as context properties instead
        self.engine.rootContext().setContextProperty(""Filepath"", FilepathHelper(parent=self))
        self.engine.rootContext().setContextProperty(""Scene3DHelper"", Scene3DHelper(parent=self))
        self.engine.rootContext().setContextProperty(""Clipboard"", ClipboardHelper(parent=self))

        # additional context properties
        self.engine.rootContext().setContextProperty(""_PaletteManager"", PaletteManager(self.engine, parent=self))
        self.engine.rootContext().setContextProperty(""MeshroomApp"", self)

        # request any potential computation to stop on exit
        self.aboutToQuit.connect(r.stopChildThreads)

        if args.project and not os.path.isfile(args.project):
            raise RuntimeError(
                ""Meshroom Command Line Error: 'PROJECT' argument should be a Meshroom project file (.mg).\n""
                ""Invalid value: '{}'"".format(args.project))

        if args.project:
            r.load(args.project)
            self.addRecentProjectFile(args.project)
        else:
            r.new()

        # import is a python keyword, so we have to access the attribute by a string
        if getattr(args, ""import"", None):
            r.importImagesFromFolder(getattr(args, ""import""), recursive=False)

        if args.importRecursive:
            r.importImagesFromFolder(args.importRecursive, recursive=True)

        if args.save:
            if os.path.isfile(args.save):
                raise RuntimeError(
                    ""Meshroom Command Line Error: Cannot save the new Meshroom project as the file (.mg) already exists.\n""
                    ""Invalid value: '{}'"".format(args.save))
            projectFolder = os.path.dirname(args.save)
            if not os.path.isdir(projectFolder):
                if not os.path.isdir(os.path.dirname(projectFolder)):
                    raise RuntimeError(
                        ""Meshroom Command Line Error: Cannot save the new Meshroom project file (.mg) as the parent of the folder does not exists.\n""
                        ""Invalid value: '{}'"".format(args.save))
                os.mkdir(projectFolder)
            r.saveAs(args.save)
            self.addRecentProjectFile(args.save)

        self.engine.load(os.path.normpath(url))

    def _recentProjectFiles(self):
        projects = []
        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginReadArray(""Projects"")
        for i in range(size):
            settings.setArrayIndex(i)
            p = settings.value(""filepath"")
            if p:
                projects.append(p)
        settings.endArray()
        return projects

    @Slot(str)
    def addRecentProjectFile(self, projectFile):
        projectFile = QUrl(projectFile).path()
        projects = self._recentProjectFiles()

        # remove duplicates while preserving order
        from collections import OrderedDict
        uniqueProjects = OrderedDict.fromkeys(projects)
        projects = list(uniqueProjects)
        # remove previous usage of the value
        if projectFile in uniqueProjects:
            projects.remove(projectFile)
        # add the new value in the first place
        projects.insert(0, projectFile)

        # keep only the 10 first elements
        projects = projects[0:20]

        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginWriteArray(""Projects"")
        for i, p in enumerate(projects):
            settings.setArrayIndex(i)
            settings.setValue(""filepath"", p)
        settings.endArray()
        settings.sync()

        self.recentProjectFilesChanged.emit()

    @Slot(str, result=str)
    def markdownToHtml(self, md):
        """"""
        Convert markdown to HTML.

        Args:
            md (str): the markdown text to convert

        Returns:
            str: the resulting HTML string
        """"""
        try:
            from markdown import markdown
        except ImportError:
            logging.warning(""Can't import markdown module, returning source markdown text."")
            return md
        return markdown(md)

    @Property(QJsonValue, constant=True)
    def systemInfo(self):
        import platform
        import sys
        return {
            'platform': '{} {}'.format(platform.system(), platform.release()),
            'python': 'Python {}'.format(sys.version.split("" "")[0])
        }

    @Property(""QVariantList"", constant=True)
    def licensesModel(self):
        """"""
        Get info about open-source licenses for the application.
        Model provides:
            title: the name of the project
            localUrl: the local path to COPYING.md
            onlineUrl: the remote path to COPYING.md
        """"""
        rootDir = os.environ.get(""MESHROOM_INSTALL_DIR"", os.getcwd())
        return [
            {
                ""title"": ""Meshroom"",
                ""localUrl"": os.path.join(rootDir, ""COPYING.md""),
                ""onlineUrl"": ""https://raw.githubusercontent.com/alicevision/meshroom/develop/COPYING.md""
            },
            {
                ""title"": ""AliceVision"",
                ""localUrl"": os.path.join(rootDir, ""aliceVision"", ""share"", ""aliceVision"", ""COPYING.md""),
                ""onlineUrl"": ""https://raw.githubusercontent.com/alicevision/AliceVision/develop/COPYING.md""
            }
        ]

    recentProjectFilesChanged = Signal()
    recentProjectFiles = Property(""QVariantList"", _recentProjectFiles, notify=recentProjectFilesChanged)

",MeshroomApp.addRecentProjectFile,https://github.com/alicevision/meshroom/issues/912,"[{'piece_type': 'error message', 'piece_content': '[2020-05-23 16:12:48,660][ERROR] Traceback (most recent call last):\nFile ""D:\\Meshroom_Src\\meshroom\\meshroom\\ui\\reconstruction.py"", line 432, in load\nsuper(Reconstruction, self).load(filepath, setupProjectFile)\nFile ""D:\\Meshroom_Src\\meshroom\\meshroom\\ui\\graph.py"", line 314, in load\ng.load(filepath, setupProjectFile)\nFile ""D:\\Meshroom_Src\\meshroom\\meshroom\\core\\graph.py"", line 247, in load\nwith open(filepath) as jsonFile:\nOSError: [Errno 22] Invalid argument: \'/D:/Meshroom_Dev/test-project/mostree.mg\''}]","[2020-05-23 16:12:48,660][ERROR] Traceback (most recent call last):
File ""D:\Meshroom_Src\meshroom\meshroom\ui\reconstruction.py"", line 432, in load
super(Reconstruction, self).load(filepath, setupProjectFile)
File ""D:\Meshroom_Src\meshroom\meshroom\ui\graph.py"", line 314, in load
g.load(filepath, setupProjectFile)
File ""D:\Meshroom_Src\meshroom\meshroom\core\graph.py"", line 247, in load
with open(filepath) as jsonFile:
OSError: [Errno 22] Invalid argument: '/D:/Meshroom_Dev/test-project/mostree.mg'",OSError,"    def addRecentProjectFile(self, projectFile):
        projectFile = QUrl(projectFile).path()
        projects = self._recentProjectFiles()

        
        from collections import OrderedDict
        uniqueProjects = OrderedDict.fromkeys(projects)
        projects = list(uniqueProjects)
        
        if projectFile in uniqueProjects:
            projects.remove(projectFile)
        
        projects.insert(0, projectFile)

        
        projects = projects[0:20]

        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginWriteArray(""Projects"")
        for i, p in enumerate(projects):
            settings.setArrayIndex(i)
            settings.setValue(""filepath"", p)
        settings.endArray()
        settings.sync()

        self.recentProjectFilesChanged.emit()","    def addRecentProjectFile(self, projectFile):
        projectFile = QUrl(projectFile).toLocalFile()
        projects = self._recentProjectFiles()

        
        from collections import OrderedDict
        uniqueProjects = OrderedDict.fromkeys(projects)
        projects = list(uniqueProjects)
        
        if projectFile in uniqueProjects:
            projects.remove(projectFile)
        
        projects.insert(0, projectFile)

        
        projects = projects[0:20]

        settings = QSettings()
        settings.beginGroup(""RecentFiles"")
        size = settings.beginWriteArray(""Projects"")
        for i, p in enumerate(projects):
            settings.setArrayIndex(i)
            settings.setValue(""filepath"", p)
        settings.endArray()
        settings.sync()

        self.recentProjectFilesChanged.emit()",[],[],buggy_snippets_files/faddf4c059bd32cc1cad1a1ea75ad1064590bd2f86388f8bcf51c39463cd99a7_before_merge.py,buggy_snippets_files/faddf4c059bd32cc1cad1a1ea75ad1064590bd2f86388f8bcf51c39463cd99a7_after_merge.py
"    def addSfmAugmentation(self, withMVS=False):
        """"""
        Create a new augmentation step connected to the last SfM node of this Reconstruction and
        return the created CameraInit and SfM nodes.

        If the Reconstruction is not initialized (empty initial CameraInit), this method won't
        create anything and return initial CameraInit and SfM nodes.

        Args:
            withMVS (bool): whether to create the MVS pipeline after the augmentation

        Returns:
            Node, Node: CameraInit, StructureFromMotion
        """"""
        sfm = self.lastSfmNode()
        if not sfm:
            return None, None

        if len(self._cameraInits) == 1:
            assert self._cameraInit == self._cameraInits[0]
            # Initial CameraInit is empty, use this one
            if len(self._cameraInits[0].viewpoints) == 0:
                return self._cameraInit, sfm

        with self.groupedGraphModification(""SfM Augmentation""):
            sfm, mvs = multiview.sfmAugmentation(self, self.lastSfmNode(), withMVS=withMVS)

        self.sfmAugmented.emit(sfm[0], mvs[-1] if mvs else sfm[-1])
        return sfm[0], sfm[-1]","    def addSfmAugmentation(self, withMVS=False):
        """"""
        Create a new augmentation step connected to the last SfM node of this Reconstruction and
        return the created CameraInit and SfM nodes.

        If the Reconstruction is not initialized (empty initial CameraInit), this method won't
        create anything and return initial CameraInit and SfM nodes.

        Args:
            withMVS (bool): whether to create the MVS pipeline after the augmentation

        Returns:
            Node, Node: CameraInit, StructureFromMotion
        """"""
        sfm = self.lastSfmNode()
        if not sfm:
            return None, None

        if len(self._cameraInits) == 1:
            assert self._cameraInit == self._cameraInits[0]
            # Initial CameraInit is empty, use this one
            if len(self._cameraInits[0].viewpoints) == 0:
                return self._cameraInit, sfm

        with self.groupedGraphModification(""SfM Augmentation""):
            sfm, mvs = multiview.sfmAugmentation(self, self.lastSfmNode(), withMVS=withMVS)

        self.sfmAugmented.emit(sfm[0], mvs[-1])
        return sfm[0], sfm[-1]",meshroom/ui/reconstruction.py,"import logging
import os
from threading import Thread

from PySide2.QtCore import QObject, Slot, Property, Signal

from meshroom import multiview
from meshroom.common.qt import QObjectListModel
from meshroom.core.node import Node, node_factory, Status
from meshroom.ui.graph import UIGraph


class Message(QObject):
    """""" Simple structure wrapping a high-level message. """"""

    def __init__(self, title, text, detailedText="""", parent=None):
        super(Message, self).__init__(parent)
        self._title = title
        self._text = text
        self._detailedText = detailedText

    title = Property(str, lambda self: self._title, constant=True)
    text = Property(str, lambda self: self._text, constant=True)
    detailedText = Property(str, lambda self: self._detailedText, constant=True)


class LiveSfmManager(QObject):
    """"""
    Manage a live SfM reconstruction by creating augmentation steps in the graph over time,
    based on images progressively added to a watched folder.

    File watching is based on regular polling and not filesystem events to work on network mounts.
    """"""
    def __init__(self, reconstruction):
        super(LiveSfmManager, self).__init__(reconstruction)
        self.reconstruction = reconstruction
        self._folder = ''
        self.timerId = -1
        self.minImagesPerStep = 4
        self.watchTimerInterval = 1000
        self.allImages = []
        self.cameraInit = None
        self.sfm = None
        self._running = False

    def reset(self):
        self.stop(False)
        self.sfm = None
        self.cameraInit = None

    def setRunning(self, value):
        if self._running == value:
            return
        if self._running:
            self.killTimer(self.timerId)
        else:
            self.timerId = self.startTimer(self.watchTimerInterval)
        self._running = value
        self.runningChanged.emit()

    @Slot(str, int)
    def start(self, folder, minImagesPerStep):
        """"""
        Start live SfM augmentation.

        Args:
            folder (str): the folder to watch in which images are added over time
            minImagesPerStep (int): minimum number of images in an augmentation step
        """"""
        # print('[LiveSfmManager] Watching {} for images'.format(folder))
        if not os.path.isdir(folder):
            raise RuntimeError(""Invalid folder provided: {}"".format(folder))
        self._folder = folder
        self.folderChanged.emit()
        self.cameraInit = self.sfm = None
        self.allImages = self.reconstruction.allImagePaths()
        self.minImagesPerStep = minImagesPerStep
        self.setRunning(True)
        self.update()  # trigger initial update

    @Slot()
    def stop(self, requestCompute=True):
        """""" Stop the live SfM reconstruction.

        Request the computation of the last augmentation step if any.
        """"""
        self.setRunning(False)
        if requestCompute:
            self.computeStep()

    def timerEvent(self, evt):
        self.update()

    def update(self):
        """"""
        Look for new images in the watched folder and create SfM augmentation step (or modify existing one)
        to include those images to the reconstruction.
        """"""
        # Get all new images in the watched folder
        filesInFolder = [os.path.join(self._folder, f) for f in os.listdir(self._folder)]
        imagesInFolder = [f for f in filesInFolder if Reconstruction.isImageFile(f)]
        newImages = set(imagesInFolder).difference(self.allImages)
        for imagePath in newImages:
            # print('[LiveSfmManager] New image file : {}'.format(imagePath))
            if not self.cameraInit:
                # Start graph modification: until 'computeAugmentation' is called, every commands
                # used will be part of this macro
                self.reconstruction.beginModification(""SfM Augmentation"")
                # Add SfM augmentation step in the graph
                self.cameraInit, self.sfm = self.reconstruction.addSfmAugmentation()
            self.addImageToStep(imagePath)

        # If we have enough images and the graph is not being computed, compute augmentation step
        if len(self.imagesInStep()) >= self.minImagesPerStep and not self.reconstruction.computing:
            self.computeStep()

    def addImageToStep(self, path):
        """""" Add an image to the current augmentation step. """"""
        self.reconstruction.appendAttribute(self.cameraInit.viewpoints, {'path': path})
        self.allImages.append(path)

    def imagePathsInCameraInit(self, node):
        """""" Get images in the given CameraInit node. """"""
        assert node.nodeType == 'CameraInit'
        return [vp.path.value for vp in node.viewpoints.value]

    def imagesInStep(self):
        """""" Get images in the current augmentation step. """"""
        return self.imagePathsInCameraInit(self.cameraInit) if self.cameraInit else []


    @Slot()
    def computeStep(self):
        """""" Freeze the current augmentation step and request its computation.
        A new step will be created once another image is added to the watched folder during 'update'.
        """"""
        if not self.cameraInit:
            return

        # print('[LiveSfmManager] Compute SfM augmentation')
        # Build intrinsics in the main thread
        self.reconstruction.buildIntrinsics(self.cameraInit, [])
        self.cameraInit = None
        sfm = self.sfm
        self.sfm = None
        # Stop graph modification and start sfm computation
        self.reconstruction.endModification()
        self.reconstruction.execute(sfm)

    runningChanged = Signal()
    running = Property(bool, lambda self: self._running, notify=runningChanged)
    folderChanged = Signal()
    folder = Property(str, lambda self: self._folder, notify=folderChanged)


class Reconstruction(UIGraph):
    """"""
    Specialization of a UIGraph designed to manage a 3D reconstruction.
    """"""

    imageExtensions = ('.jpg', '.jpeg', '.tif', '.tiff', '.png', '.exr', '.rw2', '.cr2', '.nef')

    def __init__(self, graphFilepath='', parent=None):
        super(Reconstruction, self).__init__(graphFilepath, parent)
        self._buildingIntrinsics = False
        self._cameraInit = None
        self._cameraInits = QObjectListModel(parent=self)
        self._endChunk = None
        self._meshFile = ''
        self.intrinsicsBuilt.connect(self.onIntrinsicsAvailable)
        self.graphChanged.connect(self.onGraphChanged)
        self._liveSfmManager = LiveSfmManager(self)

        # SfM result
        self._sfm = None
        self._views = None
        self._poses = None
        self._selectedViewId = None

        if graphFilepath:
            self.onGraphChanged()
        else:
            self.new()

    @Slot()
    def new(self):
        """""" Create a new photogrammetry pipeline. """"""
        self.setGraph(multiview.photogrammetry())

    def load(self, filepath):
        try:
            super(Reconstruction, self).load(filepath)
        except Exception as e:
            self.error.emit(
                Message(
                    ""Error while loading {}"".format(os.path.basename(filepath)),
                    ""An unexpected error has occurred"",
                    str(e)
                )
            )

    def onGraphChanged(self):
        """""" React to the change of the internal graph. """"""
        self._liveSfmManager.reset()
        self.sfm = None
        self._endChunk = None
        self.setMeshFile('')
        self.updateCameraInits()
        if not self._graph:
            return

        self.setSfm(self.lastSfmNode())
        try:
            endNode = self._graph.findNode(""Texturing"")
            self._endChunk = endNode.getChunks()[0]  # type: graph.NodeChunk
            endNode.outputMesh.valueChanged.connect(self.updateMeshFile)
            self._endChunk.statusChanged.connect(self.updateMeshFile)
            self.updateMeshFile()
        except KeyError:
            self._endChunk = None
        # TODO: listen specifically for cameraInit creation/deletion
        self._graph.nodes.countChanged.connect(self.updateCameraInits)

    @staticmethod
    def runAsync(func, args=(), kwargs=None):
        thread = Thread(target=func, args=args, kwargs=kwargs)
        thread.start()
        return thread

    def getViewpoints(self):
        """""" Return the Viewpoints model. """"""
        # TODO: handle multiple Viewpoints models
        return self._cameraInit.viewpoints.value if self._cameraInit else None

    def updateCameraInits(self):
        cameraInits = self._graph.nodesByType(""CameraInit"", sortedByIndex=True)
        if set(self._cameraInits.objectList()) == set(cameraInits):
            return
        self._cameraInits.setObjectList(cameraInits)
        self.setCameraInit(cameraInits[0] if cameraInits else None)

    def setCameraInit(self, cameraInit):
        """""" Set the internal CameraInit node. """"""
        # TODO: handle multiple CameraInit nodes
        if self._cameraInit == cameraInit:
            return
        self._cameraInit = cameraInit
        self.cameraInitChanged.emit()

    def getCameraInitIndex(self):
        if not self._cameraInit:
            return -1
        return self._cameraInits.indexOf(self._cameraInit)

    def setCameraInitIndex(self, idx):
        self.setCameraInit(self._cameraInits[idx])

    def updateMeshFile(self):
        if self._endChunk and self._endChunk.status.status == Status.SUCCESS:
            self.setMeshFile(self._endChunk.node.outputMesh.value)
        else:
            self.setMeshFile('')

    def setMeshFile(self, mf):
        if self._meshFile == mf:
            return
        self._meshFile = mf
        self.meshFileChanged.emit()

    def lastSfmNode(self):
        """""" Retrieve the last SfM node from the initial CameraInit node. """"""
        sfmNodes = self._graph.nodesFromNode(self._cameraInits[0], 'StructureFromMotion')[0]
        return sfmNodes[-1] if sfmNodes else None

    def addSfmAugmentation(self, withMVS=False):
        """"""
        Create a new augmentation step connected to the last SfM node of this Reconstruction and
        return the created CameraInit and SfM nodes.

        If the Reconstruction is not initialized (empty initial CameraInit), this method won't
        create anything and return initial CameraInit and SfM nodes.

        Args:
            withMVS (bool): whether to create the MVS pipeline after the augmentation

        Returns:
            Node, Node: CameraInit, StructureFromMotion
        """"""
        sfm = self.lastSfmNode()
        if not sfm:
            return None, None

        if len(self._cameraInits) == 1:
            assert self._cameraInit == self._cameraInits[0]
            # Initial CameraInit is empty, use this one
            if len(self._cameraInits[0].viewpoints) == 0:
                return self._cameraInit, sfm

        with self.groupedGraphModification(""SfM Augmentation""):
            sfm, mvs = multiview.sfmAugmentation(self, self.lastSfmNode(), withMVS=withMVS)

        self.sfmAugmented.emit(sfm[0], mvs[-1] if mvs else sfm[-1])
        return sfm[0], sfm[-1]

    def allImagePaths(self):
        """""" Get all image paths in the reconstruction. """"""
        return [vp.path.value for node in self._cameraInits for vp in node.viewpoints.value]

    def allViewIds(self):
        """""" Get all view Ids involved in the reconstruction. """"""
        return [vp.viewId.value for node in self._cameraInits for vp in node.viewpoints.value]

    @Slot(QObject, Node)
    def handleFilesDrop(self, drop, cameraInit):
        """""" Handle drop events aiming to add images to the Reconstruction.
        Fetching urls from dropEvent is generally expensive in QML/JS (bug ?).
        This method allows to reduce process time by doing it on Python side.
        """"""
        self.importImages(self.getImageFilesFromDrop(drop), cameraInit)

    @staticmethod
    def isImageFile(filepath):
        """""" Return whether filepath is a path to an image file supported by Meshroom. """"""
        return os.path.splitext(filepath)[1].lower() in Reconstruction.imageExtensions

    @staticmethod
    def getImageFilesFromDrop(drop):
        urls = drop.property(""urls"")
        # Build the list of images paths
        images = []
        for url in urls:
            localFile = url.toLocalFile()
            if os.path.isdir(localFile):  # get folder content
                files = [os.path.join(localFile, f) for f in os.listdir(localFile)]
            else:
                files = [localFile]
            images.extend([f for f in files if Reconstruction.isImageFile(f)])
        return images

    def importImages(self, images, cameraInit):
        """""" Add the given list of images to the Reconstruction. """"""
        # Start the process of updating views and intrinsics
        self.runAsync(self.buildIntrinsics, args=(cameraInit, images,))

    def buildIntrinsics(self, cameraInit, additionalViews):
        """"""
        Build up-to-date intrinsics and views based on already loaded + additional images.
        Does not modify the graph, can be called outside the main thread.
        Emits intrinsicBuilt(views, intrinsics) when done.
        """"""
        views = []
        intrinsics = []

        # Duplicate 'cameraInit' outside the graph.
        #   => allows to compute intrinsics without modifying the node or the graph
        # If cameraInit is None (i.e: SfM augmentation):
        #   * create an uninitialized node
        #   * wait for the result before actually creating new nodes in the graph (see onIntrinsicsAvailable)
        attributes = cameraInit.toDict()[""attributes""] if cameraInit else {}
        cameraInitCopy = node_factory(""CameraInit"", **attributes)

        try:
            self.setBuildingIntrinsics(True)
            # Retrieve the list of updated viewpoints and intrinsics
            views, intrinsics = cameraInitCopy.nodeDesc.buildIntrinsics(cameraInitCopy, additionalViews)
        except Exception:
            import traceback
            logging.error(""Error while building intrinsics : {}"".format(traceback.format_exc()))

        # Delete the duplicate
        cameraInitCopy.deleteLater()

        self.setBuildingIntrinsics(False)
        # always emit intrinsicsBuilt signal to inform listeners
        # in other threads that computation is over
        self.intrinsicsBuilt.emit(cameraInit, views, intrinsics)

    def onIntrinsicsAvailable(self, cameraInit, views, intrinsics):
        """""" Update CameraInit with given views and intrinsics. """"""
        augmentSfM = cameraInit is None
        commandTitle = ""Add {} Images""

        # SfM augmentation
        if augmentSfM:
            # filter out views already involved in the reconstruction
            allViewIds = self.allViewIds()
            views = [view for view in views if int(view[""viewId""]) not in allViewIds]
            commandTitle = ""Augment Reconstruction ({} Images)""

        # No additional views: early return
        if not views:
            return

        commandTitle = commandTitle.format(len(views))
        # allow updates between commands so that node depths
        # are updated after ""addSfmAugmentation"" (useful for auto layout)
        with self.groupedGraphModification(commandTitle, disableUpdates=False):
            if augmentSfM:
                cameraInit, self.sfm = self.addSfmAugmentation(withMVS=True)
            with self.groupedGraphModification(""Set Views and Intrinsics""):
                self.setAttribute(cameraInit.viewpoints, views)
                self.setAttribute(cameraInit.intrinsics, intrinsics)
        self.setCameraInit(cameraInit)

    def setBuildingIntrinsics(self, value):
        if self._buildingIntrinsics == value:
            return
        self._buildingIntrinsics = value
        self.buildingIntrinsicsChanged.emit()

    cameraInitChanged = Signal()
    cameraInit = Property(QObject, lambda self: self._cameraInit, notify=cameraInitChanged)
    cameraInitIndex = Property(int, getCameraInitIndex, setCameraInitIndex, notify=cameraInitChanged)
    viewpoints = Property(QObject, getViewpoints, notify=cameraInitChanged)
    cameraInits = Property(QObject, lambda self: self._cameraInits, constant=True)
    intrinsicsBuilt = Signal(QObject, list, list)
    buildingIntrinsicsChanged = Signal()
    buildingIntrinsics = Property(bool, lambda self: self._buildingIntrinsics, notify=buildingIntrinsicsChanged)
    meshFileChanged = Signal()
    meshFile = Property(str, lambda self: self._meshFile, notify=meshFileChanged)
    liveSfmManager = Property(QObject, lambda self: self._liveSfmManager, constant=True)

    def updateViewsAndPoses(self):
        """"""
        Update internal views and poses based on the current SfM node.
        """"""
        if not self._sfm:
            self._views = []
            self._poses = []
        else:
            self._views, self._poses = self._sfm.nodeDesc.getViewsAndPoses(self._sfm)
        self.sfmReportChanged.emit()

    def getSfm(self):
        """""" Returns the current SfM node. """"""
        return self._sfm

    def _unsetSfm(self):
        """""" Unset current SfM node. This is shortcut equivalent to _setSfm(None). """"""
        self._setSfm(None)

    def _setSfm(self, node):
        """""" Set current SfM node to 'node' and update views and poses.
        Notes: this should not be called directly, use setSfm instead.
        See Also: setSfm
        """"""
        self._sfm = node
        # Update views and poses and do so each time
        # the status of the SfM node's only chunk changes
        self.updateViewsAndPoses()
        if self._sfm:
            # when destroyed, directly use '_setSfm' to bypass
            # disconnection step in 'setSfm' (at this point, 'self._sfm' underlying object
            # has been destroyed and can't be evaluated anymore)
            self._sfm.destroyed.connect(self._unsetSfm)
            self._sfm.chunks[0].statusChanged.connect(self.updateViewsAndPoses)
        self.sfmChanged.emit()

    def setSfm(self, node):
        """""" Set the current SfM node.
        This node will be used to retrieve sparse reconstruction result like camera poses.
        """"""
        # disconnect from previous SfM node if any
        if self._sfm:
            self._sfm.chunks[0].statusChanged.disconnect(self.updateViewsAndPoses)
            self._sfm.destroyed.disconnect(self._unsetSfm)
        self._setSfm(node)

    @Slot(QObject, result=bool)
    def isInViews(self, viewpoint):
        # keys are strings (faster lookup)
        return str(viewpoint.viewId.value) in self._views

    @Slot(QObject, result=bool)
    def isReconstructed(self, viewpoint):
        # keys are strings (faster lookup)
        return str(viewpoint.poseId.value) in self._poses

    def setSelectedViewId(self, viewId):
        if viewId == self._selectedViewId:
            return
        self._selectedViewId = viewId
        self.selectedViewIdChanged.emit()

    selectedViewIdChanged = Signal()
    selectedViewId = Property(str, lambda self: self._selectedViewId, setSelectedViewId, notify=selectedViewIdChanged)

    sfmChanged = Signal()
    sfm = Property(QObject, getSfm, setSfm, notify=sfmChanged)
    sfmReportChanged = Signal()
    # convenient property for QML binding re-evaluation when sfm report changes
    sfmReport = Property(bool, lambda self: len(self._poses) > 0, notify=sfmReportChanged)
    sfmAugmented = Signal(Node, Node)

    # Signals to propagate high-level messages
    error = Signal(Message)
    warning = Signal(Message)
    info = Signal(Message)
","import logging
import os
from threading import Thread

from PySide2.QtCore import QObject, Slot, Property, Signal

from meshroom import multiview
from meshroom.common.qt import QObjectListModel
from meshroom.core.node import Node, node_factory, Status
from meshroom.ui.graph import UIGraph


class Message(QObject):
    """""" Simple structure wrapping a high-level message. """"""

    def __init__(self, title, text, detailedText="""", parent=None):
        super(Message, self).__init__(parent)
        self._title = title
        self._text = text
        self._detailedText = detailedText

    title = Property(str, lambda self: self._title, constant=True)
    text = Property(str, lambda self: self._text, constant=True)
    detailedText = Property(str, lambda self: self._detailedText, constant=True)


class LiveSfmManager(QObject):
    """"""
    Manage a live SfM reconstruction by creating augmentation steps in the graph over time,
    based on images progressively added to a watched folder.

    File watching is based on regular polling and not filesystem events to work on network mounts.
    """"""
    def __init__(self, reconstruction):
        super(LiveSfmManager, self).__init__(reconstruction)
        self.reconstruction = reconstruction
        self._folder = ''
        self.timerId = -1
        self.minImagesPerStep = 4
        self.watchTimerInterval = 1000
        self.allImages = []
        self.cameraInit = None
        self.sfm = None
        self._running = False

    def reset(self):
        self.stop(False)
        self.sfm = None
        self.cameraInit = None

    def setRunning(self, value):
        if self._running == value:
            return
        if self._running:
            self.killTimer(self.timerId)
        else:
            self.timerId = self.startTimer(self.watchTimerInterval)
        self._running = value
        self.runningChanged.emit()

    @Slot(str, int)
    def start(self, folder, minImagesPerStep):
        """"""
        Start live SfM augmentation.

        Args:
            folder (str): the folder to watch in which images are added over time
            minImagesPerStep (int): minimum number of images in an augmentation step
        """"""
        # print('[LiveSfmManager] Watching {} for images'.format(folder))
        if not os.path.isdir(folder):
            raise RuntimeError(""Invalid folder provided: {}"".format(folder))
        self._folder = folder
        self.folderChanged.emit()
        self.cameraInit = self.sfm = None
        self.allImages = self.reconstruction.allImagePaths()
        self.minImagesPerStep = minImagesPerStep
        self.setRunning(True)
        self.update()  # trigger initial update

    @Slot()
    def stop(self, requestCompute=True):
        """""" Stop the live SfM reconstruction.

        Request the computation of the last augmentation step if any.
        """"""
        self.setRunning(False)
        if requestCompute:
            self.computeStep()

    def timerEvent(self, evt):
        self.update()

    def update(self):
        """"""
        Look for new images in the watched folder and create SfM augmentation step (or modify existing one)
        to include those images to the reconstruction.
        """"""
        # Get all new images in the watched folder
        filesInFolder = [os.path.join(self._folder, f) for f in os.listdir(self._folder)]
        imagesInFolder = [f for f in filesInFolder if Reconstruction.isImageFile(f)]
        newImages = set(imagesInFolder).difference(self.allImages)
        for imagePath in newImages:
            # print('[LiveSfmManager] New image file : {}'.format(imagePath))
            if not self.cameraInit:
                # Start graph modification: until 'computeAugmentation' is called, every commands
                # used will be part of this macro
                self.reconstruction.beginModification(""SfM Augmentation"")
                # Add SfM augmentation step in the graph
                self.cameraInit, self.sfm = self.reconstruction.addSfmAugmentation()
            self.addImageToStep(imagePath)

        # If we have enough images and the graph is not being computed, compute augmentation step
        if len(self.imagesInStep()) >= self.minImagesPerStep and not self.reconstruction.computing:
            self.computeStep()

    def addImageToStep(self, path):
        """""" Add an image to the current augmentation step. """"""
        self.reconstruction.appendAttribute(self.cameraInit.viewpoints, {'path': path})
        self.allImages.append(path)

    def imagePathsInCameraInit(self, node):
        """""" Get images in the given CameraInit node. """"""
        assert node.nodeType == 'CameraInit'
        return [vp.path.value for vp in node.viewpoints.value]

    def imagesInStep(self):
        """""" Get images in the current augmentation step. """"""
        return self.imagePathsInCameraInit(self.cameraInit) if self.cameraInit else []


    @Slot()
    def computeStep(self):
        """""" Freeze the current augmentation step and request its computation.
        A new step will be created once another image is added to the watched folder during 'update'.
        """"""
        if not self.cameraInit:
            return

        # print('[LiveSfmManager] Compute SfM augmentation')
        # Build intrinsics in the main thread
        self.reconstruction.buildIntrinsics(self.cameraInit, [])
        self.cameraInit = None
        sfm = self.sfm
        self.sfm = None
        # Stop graph modification and start sfm computation
        self.reconstruction.endModification()
        self.reconstruction.execute(sfm)

    runningChanged = Signal()
    running = Property(bool, lambda self: self._running, notify=runningChanged)
    folderChanged = Signal()
    folder = Property(str, lambda self: self._folder, notify=folderChanged)


class Reconstruction(UIGraph):
    """"""
    Specialization of a UIGraph designed to manage a 3D reconstruction.
    """"""

    imageExtensions = ('.jpg', '.jpeg', '.tif', '.tiff', '.png', '.exr', '.rw2', '.cr2', '.nef')

    def __init__(self, graphFilepath='', parent=None):
        super(Reconstruction, self).__init__(graphFilepath, parent)
        self._buildingIntrinsics = False
        self._cameraInit = None
        self._cameraInits = QObjectListModel(parent=self)
        self._endChunk = None
        self._meshFile = ''
        self.intrinsicsBuilt.connect(self.onIntrinsicsAvailable)
        self.graphChanged.connect(self.onGraphChanged)
        self._liveSfmManager = LiveSfmManager(self)

        # SfM result
        self._sfm = None
        self._views = None
        self._poses = None
        self._selectedViewId = None

        if graphFilepath:
            self.onGraphChanged()
        else:
            self.new()

    @Slot()
    def new(self):
        """""" Create a new photogrammetry pipeline. """"""
        self.setGraph(multiview.photogrammetry())

    def load(self, filepath):
        try:
            super(Reconstruction, self).load(filepath)
        except Exception as e:
            self.error.emit(
                Message(
                    ""Error while loading {}"".format(os.path.basename(filepath)),
                    ""An unexpected error has occurred"",
                    str(e)
                )
            )

    def onGraphChanged(self):
        """""" React to the change of the internal graph. """"""
        self._liveSfmManager.reset()
        self.sfm = None
        self._endChunk = None
        self.setMeshFile('')
        self.updateCameraInits()
        if not self._graph:
            return

        self.setSfm(self.lastSfmNode())
        try:
            endNode = self._graph.findNode(""Texturing"")
            self._endChunk = endNode.getChunks()[0]  # type: graph.NodeChunk
            endNode.outputMesh.valueChanged.connect(self.updateMeshFile)
            self._endChunk.statusChanged.connect(self.updateMeshFile)
            self.updateMeshFile()
        except KeyError:
            self._endChunk = None
        # TODO: listen specifically for cameraInit creation/deletion
        self._graph.nodes.countChanged.connect(self.updateCameraInits)

    @staticmethod
    def runAsync(func, args=(), kwargs=None):
        thread = Thread(target=func, args=args, kwargs=kwargs)
        thread.start()
        return thread

    def getViewpoints(self):
        """""" Return the Viewpoints model. """"""
        # TODO: handle multiple Viewpoints models
        return self._cameraInit.viewpoints.value if self._cameraInit else None

    def updateCameraInits(self):
        cameraInits = self._graph.nodesByType(""CameraInit"", sortedByIndex=True)
        if set(self._cameraInits.objectList()) == set(cameraInits):
            return
        self._cameraInits.setObjectList(cameraInits)
        self.setCameraInit(cameraInits[0] if cameraInits else None)

    def setCameraInit(self, cameraInit):
        """""" Set the internal CameraInit node. """"""
        # TODO: handle multiple CameraInit nodes
        if self._cameraInit == cameraInit:
            return
        self._cameraInit = cameraInit
        self.cameraInitChanged.emit()

    def getCameraInitIndex(self):
        if not self._cameraInit:
            return -1
        return self._cameraInits.indexOf(self._cameraInit)

    def setCameraInitIndex(self, idx):
        self.setCameraInit(self._cameraInits[idx])

    def updateMeshFile(self):
        if self._endChunk and self._endChunk.status.status == Status.SUCCESS:
            self.setMeshFile(self._endChunk.node.outputMesh.value)
        else:
            self.setMeshFile('')

    def setMeshFile(self, mf):
        if self._meshFile == mf:
            return
        self._meshFile = mf
        self.meshFileChanged.emit()

    def lastSfmNode(self):
        """""" Retrieve the last SfM node from the initial CameraInit node. """"""
        sfmNodes = self._graph.nodesFromNode(self._cameraInits[0], 'StructureFromMotion')[0]
        return sfmNodes[-1] if sfmNodes else None

    def addSfmAugmentation(self, withMVS=False):
        """"""
        Create a new augmentation step connected to the last SfM node of this Reconstruction and
        return the created CameraInit and SfM nodes.

        If the Reconstruction is not initialized (empty initial CameraInit), this method won't
        create anything and return initial CameraInit and SfM nodes.

        Args:
            withMVS (bool): whether to create the MVS pipeline after the augmentation

        Returns:
            Node, Node: CameraInit, StructureFromMotion
        """"""
        sfm = self.lastSfmNode()
        if not sfm:
            return None, None

        if len(self._cameraInits) == 1:
            assert self._cameraInit == self._cameraInits[0]
            # Initial CameraInit is empty, use this one
            if len(self._cameraInits[0].viewpoints) == 0:
                return self._cameraInit, sfm

        with self.groupedGraphModification(""SfM Augmentation""):
            sfm, mvs = multiview.sfmAugmentation(self, self.lastSfmNode(), withMVS=withMVS)

        self.sfmAugmented.emit(sfm[0], mvs[-1])
        return sfm[0], sfm[-1]

    def allImagePaths(self):
        """""" Get all image paths in the reconstruction. """"""
        return [vp.path.value for node in self._cameraInits for vp in node.viewpoints.value]

    def allViewIds(self):
        """""" Get all view Ids involved in the reconstruction. """"""
        return [vp.viewId.value for node in self._cameraInits for vp in node.viewpoints.value]

    @Slot(QObject, Node)
    def handleFilesDrop(self, drop, cameraInit):
        """""" Handle drop events aiming to add images to the Reconstruction.
        Fetching urls from dropEvent is generally expensive in QML/JS (bug ?).
        This method allows to reduce process time by doing it on Python side.
        """"""
        self.importImages(self.getImageFilesFromDrop(drop), cameraInit)

    @staticmethod
    def isImageFile(filepath):
        """""" Return whether filepath is a path to an image file supported by Meshroom. """"""
        return os.path.splitext(filepath)[1].lower() in Reconstruction.imageExtensions

    @staticmethod
    def getImageFilesFromDrop(drop):
        urls = drop.property(""urls"")
        # Build the list of images paths
        images = []
        for url in urls:
            localFile = url.toLocalFile()
            if os.path.isdir(localFile):  # get folder content
                files = [os.path.join(localFile, f) for f in os.listdir(localFile)]
            else:
                files = [localFile]
            images.extend([f for f in files if Reconstruction.isImageFile(f)])
        return images

    def importImages(self, images, cameraInit):
        """""" Add the given list of images to the Reconstruction. """"""
        # Start the process of updating views and intrinsics
        self.runAsync(self.buildIntrinsics, args=(cameraInit, images,))

    def buildIntrinsics(self, cameraInit, additionalViews):
        """"""
        Build up-to-date intrinsics and views based on already loaded + additional images.
        Does not modify the graph, can be called outside the main thread.
        Emits intrinsicBuilt(views, intrinsics) when done.
        """"""
        views = []
        intrinsics = []

        # Duplicate 'cameraInit' outside the graph.
        #   => allows to compute intrinsics without modifying the node or the graph
        # If cameraInit is None (i.e: SfM augmentation):
        #   * create an uninitialized node
        #   * wait for the result before actually creating new nodes in the graph (see onIntrinsicsAvailable)
        attributes = cameraInit.toDict()[""attributes""] if cameraInit else {}
        cameraInitCopy = node_factory(""CameraInit"", **attributes)

        try:
            self.setBuildingIntrinsics(True)
            # Retrieve the list of updated viewpoints and intrinsics
            views, intrinsics = cameraInitCopy.nodeDesc.buildIntrinsics(cameraInitCopy, additionalViews)
        except Exception:
            import traceback
            logging.error(""Error while building intrinsics : {}"".format(traceback.format_exc()))

        # Delete the duplicate
        cameraInitCopy.deleteLater()

        self.setBuildingIntrinsics(False)
        # always emit intrinsicsBuilt signal to inform listeners
        # in other threads that computation is over
        self.intrinsicsBuilt.emit(cameraInit, views, intrinsics)

    def onIntrinsicsAvailable(self, cameraInit, views, intrinsics):
        """""" Update CameraInit with given views and intrinsics. """"""
        augmentSfM = cameraInit is None
        commandTitle = ""Add {} Images""

        # SfM augmentation
        if augmentSfM:
            # filter out views already involved in the reconstruction
            allViewIds = self.allViewIds()
            views = [view for view in views if int(view[""viewId""]) not in allViewIds]
            commandTitle = ""Augment Reconstruction ({} Images)""

        # No additional views: early return
        if not views:
            return

        commandTitle = commandTitle.format(len(views))
        # allow updates between commands so that node depths
        # are updated after ""addSfmAugmentation"" (useful for auto layout)
        with self.groupedGraphModification(commandTitle, disableUpdates=False):
            if augmentSfM:
                cameraInit, self.sfm = self.addSfmAugmentation(withMVS=True)
            with self.groupedGraphModification(""Set Views and Intrinsics""):
                self.setAttribute(cameraInit.viewpoints, views)
                self.setAttribute(cameraInit.intrinsics, intrinsics)
        self.setCameraInit(cameraInit)

    def setBuildingIntrinsics(self, value):
        if self._buildingIntrinsics == value:
            return
        self._buildingIntrinsics = value
        self.buildingIntrinsicsChanged.emit()

    cameraInitChanged = Signal()
    cameraInit = Property(QObject, lambda self: self._cameraInit, notify=cameraInitChanged)
    cameraInitIndex = Property(int, getCameraInitIndex, setCameraInitIndex, notify=cameraInitChanged)
    viewpoints = Property(QObject, getViewpoints, notify=cameraInitChanged)
    cameraInits = Property(QObject, lambda self: self._cameraInits, constant=True)
    intrinsicsBuilt = Signal(QObject, list, list)
    buildingIntrinsicsChanged = Signal()
    buildingIntrinsics = Property(bool, lambda self: self._buildingIntrinsics, notify=buildingIntrinsicsChanged)
    meshFileChanged = Signal()
    meshFile = Property(str, lambda self: self._meshFile, notify=meshFileChanged)
    liveSfmManager = Property(QObject, lambda self: self._liveSfmManager, constant=True)

    def updateViewsAndPoses(self):
        """"""
        Update internal views and poses based on the current SfM node.
        """"""
        if not self._sfm:
            self._views = []
            self._poses = []
        else:
            self._views, self._poses = self._sfm.nodeDesc.getViewsAndPoses(self._sfm)
        self.sfmReportChanged.emit()

    def getSfm(self):
        """""" Returns the current SfM node. """"""
        return self._sfm

    def _unsetSfm(self):
        """""" Unset current SfM node. This is shortcut equivalent to _setSfm(None). """"""
        self._setSfm(None)

    def _setSfm(self, node):
        """""" Set current SfM node to 'node' and update views and poses.
        Notes: this should not be called directly, use setSfm instead.
        See Also: setSfm
        """"""
        self._sfm = node
        # Update views and poses and do so each time
        # the status of the SfM node's only chunk changes
        self.updateViewsAndPoses()
        if self._sfm:
            # when destroyed, directly use '_setSfm' to bypass
            # disconnection step in 'setSfm' (at this point, 'self._sfm' underlying object
            # has been destroyed and can't be evaluated anymore)
            self._sfm.destroyed.connect(self._unsetSfm)
            self._sfm.chunks[0].statusChanged.connect(self.updateViewsAndPoses)
        self.sfmChanged.emit()

    def setSfm(self, node):
        """""" Set the current SfM node.
        This node will be used to retrieve sparse reconstruction result like camera poses.
        """"""
        # disconnect from previous SfM node if any
        if self._sfm:
            self._sfm.chunks[0].statusChanged.disconnect(self.updateViewsAndPoses)
            self._sfm.destroyed.disconnect(self._unsetSfm)
        self._setSfm(node)

    @Slot(QObject, result=bool)
    def isInViews(self, viewpoint):
        # keys are strings (faster lookup)
        return str(viewpoint.viewId.value) in self._views

    @Slot(QObject, result=bool)
    def isReconstructed(self, viewpoint):
        # keys are strings (faster lookup)
        return str(viewpoint.poseId.value) in self._poses

    def setSelectedViewId(self, viewId):
        if viewId == self._selectedViewId:
            return
        self._selectedViewId = viewId
        self.selectedViewIdChanged.emit()

    selectedViewIdChanged = Signal()
    selectedViewId = Property(str, lambda self: self._selectedViewId, setSelectedViewId, notify=selectedViewIdChanged)

    sfmChanged = Signal()
    sfm = Property(QObject, getSfm, setSfm, notify=sfmChanged)
    sfmReportChanged = Signal()
    # convenient property for QML binding re-evaluation when sfm report changes
    sfmReport = Property(bool, lambda self: len(self._poses) > 0, notify=sfmReportChanged)
    sfmAugmented = Signal(Node, Node)

    # Signals to propagate high-level messages
    error = Signal(Message)
    warning = Signal(Message)
    info = Signal(Message)
",Reconstruction.addSfmAugmentation,https://github.com/alicevision/meshroom/issues/127,"[{'piece_type': 'error message', 'piece_content': 'Traceback (most recent call last):\nFile ""C:\\Users\\andre\\work\\meshroom\\meshroom\\ui\\reconstruction.py"", line 72, in start\nraise RuntimeError(""Invalid folder provided: {}"".format(folder))\nRuntimeError: Invalid folder provided: /F:/ai-ml-models/images/live'}]","Traceback (most recent call last):
File ""C:\Users\andre\work\meshroom\meshroom\ui\reconstruction.py"", line 72, in start
raise RuntimeError(""Invalid folder provided: {}"".format(folder))
RuntimeError: Invalid folder provided: /F:/ai-ml-models/images/live",RuntimeError,"    def addSfmAugmentation(self, withMVS=False):
        
        sfm = self.lastSfmNode()
        if not sfm:
            return None, None

        if len(self._cameraInits) == 1:
            assert self._cameraInit == self._cameraInits[0]
            
            if len(self._cameraInits[0].viewpoints) == 0:
                return self._cameraInit, sfm

        with self.groupedGraphModification(""SfM Augmentation""):
            sfm, mvs = multiview.sfmAugmentation(self, self.lastSfmNode(), withMVS=withMVS)

        self.sfmAugmented.emit(sfm[0], mvs[-1])
        return sfm[0], sfm[-1]","    def addSfmAugmentation(self, withMVS=False):
        
        sfm = self.lastSfmNode()
        if not sfm:
            return None, None

        if len(self._cameraInits) == 1:
            assert self._cameraInit == self._cameraInits[0]
            
            if len(self._cameraInits[0].viewpoints) == 0:
                return self._cameraInit, sfm

        with self.groupedGraphModification(""SfM Augmentation""):
            sfm, mvs = multiview.sfmAugmentation(self, self.lastSfmNode(), withMVS=withMVS)

        self.sfmAugmented.emit(sfm[0], mvs[-1] if mvs else sfm[-1])
        return sfm[0], sfm[-1]",[],[],buggy_snippets_files/dffb9602005cbea45f7d0c6d2f7f7a475f84d5df43256ef336fea453a6155d5e_before_merge.py,buggy_snippets_files/dffb9602005cbea45f7d0c6d2f7f7a475f84d5df43256ef336fea453a6155d5e_after_merge.py
"    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        # Look the ""Pymathics Modules"" part, and if it does not exist, create it.
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        # For each module, create the documentation object and load the chapters in the pymathics part.
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True","    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        # Look the ""Pymathics Modules"" part, and if it does not exist, create it.
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        # For each module, create the documentation object and load the chapters in the pymathics part.
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule.name} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True",mathics/doc/doc.py,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
from os import listdir, path
import pickle
import importlib

from django.utils.html import escape, linebreaks
from django.utils.safestring import mark_safe

from mathics import settings

from mathics import builtin
from mathics.builtin import get_module_doc
from mathics.core.evaluation import Message, Print
from mathics.doc.utils import slugify

CHAPTER_RE = re.compile('(?s)<chapter title=""(.*?)"">(.*?)</chapter>')
SECTION_RE = re.compile('(?s)(.*?)<section title=""(.*?)"">(.*?)</section>')
SUBSECTION_RE = re.compile('(?s)<subsection title=""(.*?)"">')
SUBSECTION_END_RE = re.compile('</subsection>')

TESTCASE_RE = re.compile(r'''(?mx)^
    ((?:.|\n)*?)
    ^\s*(>|\#)>[ ](.*)
    ((?:\n\s*(?:[:|=.][ ]|\.).*)*)
''')
TESTCASE_OUT_RE = re.compile(r'^\s*([:|=])(.*)$')

MATHICS_RE = re.compile(r""(?<!\\)\'(.*?)(?<!\\)\'"")

# preserve space before and after inline code variables
LATEX_RE = re.compile(r""(\s?)\$(\w+?)\$(\s?)"")

DL_RE = re.compile(r""(?s)<dl>(.*?)</dl>"")
DL_ITEM_RE = re.compile(
    r""(?s)<(?P<tag>d[td])>(?P<content>.*?)(?:</(?P=tag)>|)\s*(?:(?=<d[td]>)|$)"")
LIST_RE = re.compile(r""(?s)<(?P<tag>ul|ol)>(?P<content>.*?)</(?P=tag)>"")
LIST_ITEM_RE = re.compile(r""(?s)<li>(.*?)(?:</li>|(?=<li>)|$)"")
CONSOLE_RE = re.compile(
    r""(?s)<(?P<tag>con|console)>(?P<content>.*?)</(?P=tag)>"")
IMG_RE = re.compile(
    r'<img src=""(?P<src>.*?)"" title=""(?P<title>.*?)"" label=""(?P<label>.*?)"">')
REF_RE = re.compile(r'<ref label=""(?P<label>.*?)"">')
PYTHON_RE = re.compile(r'(?s)<python>(.*?)</python>')
LATEX_CHAR_RE = re.compile(r""(?<!\\)(\^)"")

QUOTATIONS_RE = re.compile(r'\""([\w\s,]*?)\""')
HYPERTEXT_RE = re.compile(r""(?s)<(?P<tag>em|url)>(?P<content>.*?)</(?P=tag)>"")

OUTSIDE_ASY_RE = re.compile(r""(?s)((?:^|\\end\{asy\}).*?(?:$|\\begin\{asy\}))"")
LATEX_TEXT_RE = re.compile(
    r""(?s)\\text\{([^{}]*?(?:[^{}]*?\{[^{}]*?(?:[^{}]*?\{[^{}]*?\}[^{}]*?)*?""
    r""[^{}]*?\}[^{}]*?)*?[^{}]*?)\}"")
LATEX_TESTOUT_RE = re.compile(
    r""(?s)\\begin\{(?P<tag>testmessage|testprint|testresult)\}""
    r""(?P<content>.*?)\\end\{(?P=tag)\}"")
LATEX_TESTOUT_DELIM_RE = re.compile(r',')
NUMBER_RE = re.compile(r'(\d*(?<!\.)\.\d+|\d+\.(?!\.)\d*|\d+)')
LATEX_ARRAY_RE = re.compile(
    r'(?s)\\begin\{testresult\}\\begin\{array\}\{l\}(.*?)'
    r'\\end\{array\}\\end\{testresult\}')
LATEX_INLINE_END_RE = re.compile(r""(?s)(?P<all>\\lstinline'[^']*?'\}?[.,;:])"")
LATEX_CONSOLE_RE = re.compile(r""\\console\{(.*?)\}"")

ALLOWED_TAGS = ('dl', 'dd', 'dt', 'em', 'url', 'ul',
                'ol', 'li', 'con', 'console', 'img', 'ref', 'subsection')
ALLOWED_TAGS_RE = dict((allowed, re.compile(
    '&lt;(%s.*?)&gt;' % allowed)) for allowed in ALLOWED_TAGS)

SPECIAL_COMMANDS = {
    'LaTeX': (r'<em>LaTeX</em>', r'\LaTeX{}'),
    'Mathematica': (r'<em>Mathematica</em>&reg;',
                    r'\emph{Mathematica}\textregistered{}'),
    'Mathics': (r'<em>Mathics</em>', r'\emph{Mathics}'),
    'Sage': (r'<em>Sage</em>', r'\emph{Sage}'),
    'Wolfram': (r'<em>Wolfram</em>', r'\emph{Wolfram}'),

    'skip': (r'<br /><br />', r'\bigskip'),
}

try:
    with open(settings.DOC_XML_DATA, 'rb') as xml_data_file:
        xml_data = pickle.load(xml_data_file)
except IOError:
    xml_data = {}


def filter_comments(doc):
    return '\n'.join(line for line in doc.splitlines()
                     if not line.lstrip().startswith('##'))


def strip_system_prefix(name):
    if name.startswith('System`'):
        stripped_name = name[len('System`'):]
        # don't return Private`sym for System`Private`sym
        if '`' not in stripped_name:
            return stripped_name
    return name


def get_latex_escape_char(text):
    for escape_char in (""'"", '~', '@'):
        if escape_char not in text:
            return escape_char
    raise ValueError


def _replace_all(text, pairs):
    for (i, j) in pairs:
        text = text.replace(i, j)
    return text


def escape_latex_output(text):
    "" Escape Mathics output ""

    text = _replace_all(text, [('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
                               ('~', '\\~'), ('&', '\\&'), ('%', '\\%'),
                               ('$', r'\$'), ('_', '\\_')])
    return text


def escape_latex_code(text):
    "" Escape verbatim Mathics input ""

    text = escape_latex_output(text)
    escape_char = get_latex_escape_char(text)
    return '\\lstinline%s%s%s' % (escape_char, text, escape_char)


def escape_latex(text):
    "" Escape documentation text ""

    def repl_python(match):
        return r""""""\begin{lstlisting}[style=python]
%s
\end{lstlisting}"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = _replace_all(text, [
        ('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
        ('~', '\\~{ }'), ('&', '\\&'), ('%', '\\%'), ('#','\\#')
    ])

    def repl(match):
        text = match.group(1)
        if text:
            text = _replace_all(text, [(""\\'"", ""'""), ('^', '\\^')])
            escape_char = get_latex_escape_char(text)
            text = LATEX_RE.sub(
                lambda m: ""%s%s\\codevar{\\textit{%s}}%s\\lstinline%s"" % (
                    escape_char, m.group(1), m.group(2), m.group(3),
                    escape_char),
                text)
            if text.startswith(' '):
                text = r'\ ' + text[1:]
            if text.endswith(' '):
                text = text[:-1] + r'\ '
            return ""\\code{\\lstinline%s%s%s}"" % (
                escape_char, text, escape_char)
        else:
            # treat double '' literaly
            return ""''""

    text = MATHICS_RE.sub(repl, text)

    text = LATEX_RE.sub(lambda m: '%s\\textit{%s}%s' % (
        m.group(1), m.group(2), m.group(3)), text)

    text = text.replace(""\\\\'"", ""'"")

    def repl_dl(match):
        text = match.group(1)
        text = DL_ITEM_RE.sub(lambda m: '\\%(tag)s{%(content)s}\n' %
                              m.groupdict(), text)
        return '\\begin{definitions}%s\\end{definitions}' % text
    text = DL_RE.sub(repl_dl, text)

    def repl_list(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LIST_ITEM_RE.sub(
            lambda m: '\\item %s\n' % m.group(1), content)
        env = 'itemize' if tag == 'ul' else 'enumerate'
        return '\\begin{%s}%s\\end{%s}' % (env, content, env)
    text = LIST_RE.sub(repl_list, text)

    text = _replace_all(text, [
        ('$', r'\$'), ('\u03c0', r'$\pi$'), ('≥', r'$\ge$'), ('≤', r'$\le$'),
        ('≠', r'$\ne$'),
        ('ç',r'\c{c}'),('é',r'\'e'),('ê',r'\^e'),('ñ',r'\~n'),
         ('∫',r'\int'),('',r'd'),   ])

    def repl_char(match):
        char = match.group(1)
        return {
            '^': '$^\wedge$',
        }[char]
    text = LATEX_CHAR_RE.sub(repl_char, text)

    def repl_img(match):
        src = match.group('src')
        title = match.group('title')
        label = match.group('label')
        return r""""""\begin{figure*}[htp]
\centering
\includegraphics[width=\textwidth]{images/%(src)s}
\caption{%(title)s}
\label{%(label)s}
\end{figure*}"""""" % {
            'src': src,
            'title': title,
            'label': label,
        }
    text = IMG_RE.sub(repl_img, text)

    def repl_ref(match):
        return r'figure \ref{%s}' % match.group('label')
    text = REF_RE.sub(repl_ref, text)

    def repl_quotation(match):
        return r""``%s''"" % match.group(1)

    def repl_hypertext(match):
        tag = match.group('tag')
        content = match.group('content')
        if tag == 'em':
            return r'\emph{%s}' % content
        elif tag == 'url':
            return '\\url{%s}' % content

    text = QUOTATIONS_RE.sub(repl_quotation, text)
    text = HYPERTEXT_RE.sub(repl_hypertext, text)

    def repl_console(match):
        tag = match.group('tag')
        content = match.group('content')
        content = content.strip()
        content = content.replace(r'\$', '$')
        if tag == 'con':
            return '\\console{%s}' % content
        else:
            return '\\begin{lstlisting}\n%s\n\\end{lstlisting}' % content
    text = CONSOLE_RE.sub(repl_console, text)

    '''def repl_asy(match):
        """"""
        Ensure \begin{asy} and \end{asy} are on their own line,
        but there shall be no extra empty lines
        """"""
        #tag = match.group(1)
        #return '\n%s\n' % tag
        #print ""replace""
        return '\\end{asy}\n\\begin{asy}'
    text = LATEX_BETWEEN_ASY_RE.sub(repl_asy, text)'''

    def repl_subsection(match):
        return '\n\\subsection*{%s}\n' % match.group(1)
    text = SUBSECTION_RE.sub(repl_subsection, text)
    text = SUBSECTION_END_RE.sub('', text)

    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        # ""\"" has been escaped already => 2 \
        text = text.replace('\\\\' + key, tex)

    text = post_sub(text, post_substitutions)

    return text


def post_process_latex(result):
    """"""
    Some post-processing hacks of generated LaTeX code to handle linebreaks
    """"""

    WORD_SPLIT_RE = re.compile(r'(\s+|\\newline\s*)')

    def wrap_word(word):
        if word.strip() == r'\newline':
            return word
        return r'\text{%s}' % word

    def repl_text(match):
        text = match.group(1)
        if not text:
            return r'\text{}'
        words = WORD_SPLIT_RE.split(text)
        assert len(words) >= 1
        if len(words) > 1:
            text = """"
            index = 0
            while index < len(words) - 1:
                text += '%s%s\\allowbreak{}' % (wrap_word(
                    words[index]), wrap_word(words[index + 1]))
                index += 2
            text += wrap_word(words[-1])
        else:
            text = r'\text{%s}' % words[0]
        if not text:
            return r'\text{}'
        text = text.replace('><', r'>}\allowbreak\text{<')
        return text

    def repl_out_delim(match):
        return ',\\allowbreak{}'

    def repl_number(match):
        guard = r'\allowbreak{}'
        inter_groups_pre = r'\,\discretionary{\~{}}{\~{}}{}'
        inter_groups_post = r'\discretionary{\~{}}{\~{}}{}'
        number = match.group(1)
        parts = number.split('.')
        if len(number) <= 3:
            return number
        assert 1 <= len(parts) <= 2
        pre_dec = parts[0]
        groups = []
        while pre_dec:
            groups.append(pre_dec[-3:])
            pre_dec = pre_dec[:-3]
        pre_dec = inter_groups_pre.join(reversed(groups))
        if len(parts) == 2:
            post_dec = parts[1]
            groups = []
            while post_dec:
                groups.append(post_dec[:3])
                post_dec = post_dec[3:]
            post_dec = inter_groups_post.join(groups)
            result = pre_dec + '.' + post_dec
        else:
            result = pre_dec
        return guard + result + guard

    def repl_array(match):
        content = match.group(1)
        lines = content.split('\\\\')
        content = ''.join(r'\begin{dmath*}%s\end{dmath*}' %
                          line for line in lines if line.strip())
        return r'\begin{testresultlist}%s\end{testresultlist}' % content

    def repl_out(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LATEX_TESTOUT_DELIM_RE.sub(repl_out_delim, content)
        content = NUMBER_RE.sub(repl_number, content)
        content = content.replace(r'\left[', r'\left[\allowbreak{}')
        return '\\begin{%s}%s\\end{%s}' % (tag, content, tag)

    def repl_inline_end(match):
        "" Prevent linebreaks between inline code and sentence delimeters ""

        code = match.group('all')
        if code[-2] == '}':
            code = code[:-2] + code[-1] + code[-2]
        return r'\mbox{%s}' % code

    def repl_console(match):
        code = match.group(1)
        code = code.replace('/', r'/\allowbreak{}')
        return r'\console{%s}' % code

    def repl_nonasy(match):
        result = match.group(1)
        result = LATEX_TEXT_RE.sub(repl_text, result)
        result = LATEX_TESTOUT_RE.sub(repl_out, result)
        result = LATEX_ARRAY_RE.sub(repl_array, result)
        result = LATEX_INLINE_END_RE.sub(repl_inline_end, result)
        result = LATEX_CONSOLE_RE.sub(repl_console, result)
        return result

    return OUTSIDE_ASY_RE.sub(repl_nonasy, result)

POST_SUBSTITUTION_TAG = '_POST_SUBSTITUTION%d_'


def pre_sub(re, text, repl_func):
    post_substitutions = []

    def repl_pre(match):
        repl = repl_func(match)
        index = len(post_substitutions)
        post_substitutions.append(repl)
        return POST_SUBSTITUTION_TAG % index

    text = re.sub(repl_pre, text)

    return text, post_substitutions


def post_sub(text, post_substitutions):
    for index, sub in enumerate(post_substitutions):
        text = text.replace(POST_SUBSTITUTION_TAG % index, sub)
    return text


def escape_html(text, verbatim_mode=False, counters=None, single_line=False):
    def repl_python(match):
        return r""""""<pre><![CDATA[
%s
]]></pre>"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    if not verbatim_mode:
        def repl_quotation(match):
            return r""&ldquo;%s&rdquo;"" % match.group(1)
        text = QUOTATIONS_RE.sub(repl_quotation, text)

    if counters is None:
        counters = {}

    text = text.replace('""', '&quot;')
    if not verbatim_mode:
        def repl_latex(match):
            return '%s<var>%s</var>%s' % (
                match.group(1), match.group(2), match.group(3))

        text = LATEX_RE.sub(repl_latex, text)

        def repl_mathics(match):
            text = match.group(1)
            text = text.replace(""\\'"", ""'"")
            text = text.replace(' ', '&nbsp;')
            if text:
                return ""<code>%s</code>"" % text
            else:
                return ""'""

        def repl_allowed(match):
            content = _replace_all(match.group(1), [
                ('&ldquo;', '""'), ('&rdquo;', '""'), ('&quot;', '""')])
            return '<%s>' % content

        text = MATHICS_RE.sub(repl_mathics, text)
        for allowed in ALLOWED_TAGS:
            text = ALLOWED_TAGS_RE[allowed].sub(repl_allowed, text)
            text = text.replace('&lt;/%s&gt;' % allowed, '</%s>' % allowed)

        def repl_dl(match):
            text = match.group(1)
            text = DL_ITEM_RE.sub(
                lambda m: '<%(tag)s>%(content)s</%(tag)s>\n' % m.groupdict(),
                text)
            return '<dl>%s</dl>' % text

        text = DL_RE.sub(repl_dl, text)

        def repl_list(match):
            tag = match.group('tag')
            content = match.group('content')
            content = LIST_ITEM_RE.sub(
                lambda m: '<li>%s</li>' % m.group(1), content)
            return '<%s>%s</%s>' % (tag, content, tag)

        text = LIST_RE.sub(repl_list, text)

        def repl_hypertext(match):
            tag = match.group('tag')
            content = match.group('content')
            if tag == 'em':
                return r'<em>%s</em>' % content
            elif tag == 'url':
                return r'<a href=""%s"">%s</a>' % (content, content)

        text = HYPERTEXT_RE.sub(repl_hypertext, text)

        def repl_console(match):
            tag = match.group('tag')
            content = match.group('content')
            tag = 'div' if tag == 'console' else 'span'
            content = content.strip()
            pre = post = ''

            # gets replaced for <br /> later by DocText.html()
            content = content.replace('\n', '<br>')

            return r'<%s class=""console"">%s%s%s</%s>' % (
                tag, pre, content, post, tag)

        text = CONSOLE_RE.sub(repl_console, text)

        def repl_img(match):
            src = match.group('src')
            title = match.group('title')
            return (r'<a href=""/media/doc/%(src)s.pdf"">'
                    r'<img src=""/media/doc/%(src)s.png"" title=""%(title)s"" />'
                    r'</a>') % {'src': src, 'title': title}
        text = IMG_RE.sub(repl_img, text)

        def repl_ref(match):
            # TODO: this is not an optimal solution - maybe we need figure
            # numbers in the XML doc as well?
            return r'the following figure'
        text = REF_RE.sub(repl_ref, text)

        def repl_subsection(match):
            return '\n<h2>%s</h2>\n' % match.group(1)
        text = SUBSECTION_RE.sub(repl_subsection, text)
        text = SUBSECTION_END_RE.sub('', text)

        text = text.replace(""\\'"", ""'"")
    else:
        text = text.replace(' ', '&nbsp;')
        text = '<code>%s</code>' % text
    text = text.replace(""'"", '&#39;')
    text = text.replace('---', '&mdash;')
    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        text = text.replace('\\' + key, xml)

    if not single_line:
        text = linebreaks(text)
        text = text.replace('<br />', '\n').replace('<br>', '<br />')

    text = post_sub(text, post_substitutions)

    text = text.replace('<p><pre>', '<pre>').replace('</pre></p>', '</pre>')

    return text


class Tests(object):
    def __init__(self, part, chapter, section, tests):
        self.part, self.chapter = part, chapter
        self.section, self.tests = section, tests


class DocElement(object):
    def href(self, ajax=False):
        if ajax:
            return ""javascript:loadDoc('%s')"" % self.get_url()
        else:
            return ""/doc%s"" % self.get_url()

    def get_prev(self):
        return self.get_prev_next()[0]

    def get_next(self):
        return self.get_prev_next()[1]

    def get_collection(self):
        return []

    def get_prev_next(self):
        collection = self.get_collection()
        index = collection.index(self)
        prev = collection[index - 1] if index > 0 else None
        next = collection[index + 1] if index < len(collection) - 1 else None
        return prev, next

    def get_title_html(self):
        return mark_safe(escape_html(self.title, single_line=True))


class Documentation(DocElement):

    def __str__(self):
        return '\n\n\n'.join(str(part) for part in self.parts)

    def get_tests(self):
        for part in self.parts:
            for chapter in part.chapters:
                tests = chapter.doc.get_tests()
                if tests:
                    yield Tests(part.title, chapter.title, '', tests)
                for section in chapter.sections:
                    if section.installed:
                        tests = section.doc.get_tests()
                        if tests:
                            yield Tests(
                                part.title, chapter.title, section.title, tests)

    def get_part(self, part_slug):
        return self.parts_by_slug.get(part_slug)

    def get_chapter(self, part_slug, chapter_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            return part.chapters_by_slug.get(chapter_slug)
        return None
        """"""for part in self.parts:
            if part.slug == part_slug:
                for chapter in self:
                    pass""""""

    def get_section(self, part_slug, chapter_slug, section_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            chapter = part.chapters_by_slug.get(chapter_slug)
            if chapter:
                return chapter.sections_by_slug.get(section_slug)
        return None

    def latex(self, output):
        parts = []
        appendix = False
        for part in self.parts:
            text = part.latex(output)
            if part.is_appendix and not appendix:
                appendix = True
                text = '\n\\appendix\n' + text
            parts.append(text)
        result = '\n\n'.join(parts)
        result = post_process_latex(result)
        return result

    def get_url(self):
        return '/'

    def search(self, query):
        query = query.strip()
        query_parts = [q.strip().lower() for q in query.split()]

        def matches(text):
            text = text.lower()
            return all(q in text for q in query_parts)

        result = []
        for part in self.parts:
            if matches(part.title):
                result.append((False, part))
            for chapter in part.chapters:
                if matches(chapter.title):
                    result.append((False, chapter))
                for section in chapter.sections:
                    if matches(section.title):
                        result.append((section.title == query, section))
                    elif query == section.operator:
                        result.append((True, section))
        return result


class MathicsMainDocumentation(Documentation):
    def __init__(self):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = settings.DOC_DIR
        self.xml_data_file = settings.DOC_XML_DATA
        self.tex_data_file = settings.DOC_TEX_DATA
        self.latex_file = settings.DOC_LATEX_FILE
        self.pymathics_doc_loaded = False
        files = listdir(self.doc_dir)
        files.sort()
        appendix = []

        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        for title, modules, builtins_by_module, start in [(
            ""Reference of built-in symbols"", builtin.modules,
            builtin.builtins_by_module, True)]:     # nopep8
            # (""Reference of optional symbols"", optional.modules,
            #  optional.optional_builtins_by_module, False)]:

            builtin_part = DocPart(self, title, is_reference=start)
            for module in modules:
                title, text = get_module_doc(module)
                chapter = DocChapter(builtin_part, title, Doc(text))
                builtins = builtins_by_module[module.__name__]
                for instance in builtins:
                    installed = True
                    for package in getattr(instance, 'requires', []):
                        try:
                            importlib.import_module(package)
                        except ImportError:
                            installed = False
                            break
                    section = DocSection(
                        chapter, strip_system_prefix(instance.get_name()),
                        instance.__doc__ or '',
                        operator=instance.get_operator(),
                        installed=installed)
                    chapter.sections.append(section)
                builtin_part.chapters.append(chapter)
            self.parts.append(builtin_part)

        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)

    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        # Look the ""Pymathics Modules"" part, and if it does not exist, create it.
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        # For each module, create the documentation object and load the chapters in the pymathics part.
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True


class PyMathicsDocumentation(Documentation):
    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        # Load the module and verifies it is a pymathics module
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        try:
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        except (AttributeError, KeyError, IndexError):
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        # Paths
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        # Load the dictionary of mathics symbols defined in the module
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        # Defines de default first part, in case we are building an independent documentation module.
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        # Builds the automatic documentation
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        # Adds possible appendices
        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)


class DocPart(DocElement):
    def __init__(self, doc, title, is_reference=False):
        self.doc = doc
        self.title = title
        self.slug = slugify(title)
        self.chapters = []
        self.chapters_by_slug = {}
        self.is_reference = is_reference
        self.is_appendix = False
        doc.parts_by_slug[self.slug] = self

    def __str__(self):
        return '%s\n\n%s' % (
            self.title, '\n'.join(str(chapter) for chapter in self.chapters))

    def latex(self, output):
        result = '\n\n\\part{%s}\n\n' % escape_latex(self.title) + (
            '\n\n'.join(chapter.latex(output) for chapter in self.chapters))
        if self.is_reference:
            result = '\n\n\\referencestart' + result
        return result

    def get_url(self):
        return '/%s/' % self.slug

    def get_collection(self):
        return self.doc.parts


class DocChapter(DocElement):
    def __init__(self, part, title, doc=None):
        self.part = part
        self.title = title
        self.slug = slugify(title)
        self.doc = doc
        self.sections = []
        self.sections_by_slug = {}
        part.chapters_by_slug[self.slug] = self

    def __str__(self):
        return '= %s =\n\n%s' % (
            self.title, '\n'.join(str(section) for section in self.sections))

    def latex(self, output):
        intro = self.doc.latex(output).strip()
        if intro:
            short = 'short' if len(intro) < 300 else ''
            intro = '\\begin{chapterintro%s}\n%s\n\n\\end{chapterintro%s}' % (
                short, intro, short)
        return ''.join([
            '\n\n\\chapter{%(title)s}\n\\chapterstart\n\n%(intro)s' % {
                'title': escape_latex(self.title),
                'intro': intro},
            '\\chaptersections\n',
            '\n\n'.join(
                section.latex(output) for section in self.sections),
            '\n\\chapterend\n'])

    def get_url(self):
        return '/%s/%s/' % (self.part.slug, self.slug)

    def get_collection(self):
        return self.part.chapters


class DocSection(DocElement):
    def __init__(self, chapter, title, text, operator=None, installed=True):
        self.chapter = chapter
        self.title = title
        self.slug = slugify(title)
        if text.count(""<dl>"") != text.count(""</dl>""):
            raise ValueError(""Missing opening or closing <dl> tag in ""
                             ""{} documentation"".format(title))
        self.doc = Doc(text)
        self.operator = operator
        self.installed = installed
        chapter.sections_by_slug[self.slug] = self

    def __str__(self):
        return '== %s ==\n%s' % (self.title, self.doc)

    def latex(self, output):
        title = escape_latex(self.title)
        if self.operator:
            title += "" (\\code{%s})"" % escape_latex_code(self.operator)
        index = '\index{%s}' % escape_latex(
            self.title) if self.chapter.part.is_reference else ''
        return (
            '\n\n\\section*{%(title)s}%(index)s\n'
            '\\sectionstart\n\n%(content)s\\sectionend'
            '\\addcontentsline{toc}{section}{%(title)s}') % {
                'title': title,
                'index': index,
                'content': self.doc.latex(output)
            }

    def get_url(self):
        return '/%s/%s/%s/' % (
            self.chapter.part.slug, self.chapter.slug, self.slug)

    def get_collection(self):
        return self.chapter.sections

    def html_data(self):
        indices = set()
        for test in self.doc.items:
            indices.update(test.test_indices())
        result = {}
        for index in indices:
            result[index] = xml_data.get((
                self.chapter.part.title, self.chapter.title, self.title,
                index))
        return result


class Doc(object):
    def __init__(self, doc):
        self.items = []
        # remove commented lines
        doc = filter_comments(doc)
        # pre-substitute Python code because it might contain tests
        doc, post_substitutions = pre_sub(
            PYTHON_RE, doc, lambda m: '<python>%s</python>' % m.group(1))
        # HACK: Artificially construct a last testcase to get the ""intertext""
        # after the last (real) testcase. Ignore the test, of course.
        doc += '\n>> test\n = test'
        testcases = TESTCASE_RE.findall(doc)
        tests = None
        for index in range(len(testcases)):
            testcase = list(testcases[index])
            text = testcase.pop(0).strip()
            if text:
                if tests is not None:
                    self.items.append(tests)
                    tests = None
                text = post_sub(text, post_substitutions)
                self.items.append(DocText(text))
                tests = None
            if index < len(testcases) - 1:
                test = DocTest(index, testcase)
                if tests is None:
                    tests = DocTests()
                if not test.ignore:
                    tests.tests.append(test)
            if tests is not None:
                self.items.append(tests)
                tests = None

    def __str__(self):
        return '\n'.join(str(item) for item in self.items)

    def text(self, detail_level):
        # used for introspection
        # TODO parse XML and pretty print
        # HACK
        item = str(self.items[0])
        item = '\n'.join(line.strip() for line in item.split('\n'))
        item = item.replace('<dl>', '')
        item = item.replace('</dl>', '')
        item = item.replace('<dt>', '  ')
        item = item.replace('</dt>', '')
        item = item.replace('<dd>', '    ')
        item = item.replace('</dd>', '')
        item = '\n'.join(line for line in item.split('\n') if not line.isspace())
        return item

    def get_tests(self):
        tests = []
        for item in self.items:
            tests.extend(item.get_tests())
        return tests

    def latex(self, output):
        return '\n'.join(item.latex(output) for item in self.items
                         if not item.is_private())

    def html(self):
        counters = {}
        return mark_safe('\n'.join(item.html(counters) for item in self.items
                         if not item.is_private()))


class DocText(object):
    def __init__(self, text):
        self.text = text

    def get_tests(self):
        return []

    def is_private(self):
        return False

    def __str__(self):
        return self.text

    def latex(self, output):
        return escape_latex(self.text)

    def html(self, counters=None):
        result = escape_html(self.text, counters=counters)
        return result

    def test_indices(self):
        return []


class DocTests(object):
    def __init__(self):
        self.tests = []

    def get_tests(self):
        return self.tests

    def is_private(self):
        return all(test.private for test in self.tests)

    def __str__(self):
        return '\n'.join(str(test) for test in self.tests)

    def latex(self, output):
        if len(self.tests) == 0:
            return ""\n""

        testLatexStrings = [test.latex(output) for test in self.tests
                       if not test.private]
        testLatexStrings = [t for t in testLatexStrings if len(t)>1]
        if len(testLatexStrings) == 0:
            return ""\n""
        
        return '\\begin{tests}%%\n%s%%\n\\end{tests}' % (
            '%\n'.join(testLatexStrings))

    def html(self, counters=None):
        if len(self.tests) == 0:
            return ""\n""        
        return '<ul class=""tests"">%s</ul>' % (
            '\n'.join('<li>%s</li>' % test.html() for test in self.tests
                      if not test.private))

    def test_indices(self):
        return [test.index for test in self.tests]


class DocTest(object):
    """"""
    DocTest formatting rules:

    #> signifies private test that does not appear as part of the documentation
    X> outputs the docs as normal, but the test is not run
    = compares the result text
    : compares an (error) Message
    | signifies Print outpt
    """"""
    def __init__(self, index, testcase):
        self.index = index
        self.result = None
        self.outs = []
        # Private test cases are executed, but NOT shown as part of the docs
        self.private = testcase[0] == '#'
        # Ignored test cases are NOT executed, but shown as part of the docs
        if testcase[0] == 'X':
            self.ignore = True
            # substitute '>' again so we get the correct formatting
            testcase[0] = '>'
        else:
            self.ignore = False

        self.test = testcase[1].strip()

        self.key = None
        outs = testcase[2].splitlines()
        for line in outs:
            line = line.strip()
            if line:
                if line.startswith('.'):
                    text = line[1:]
                    if text.startswith(' '):
                        text = text[1:]
                    text = '\n' + text
                    if self.result is not None:
                        self.result += text
                    elif self.outs:
                        self.outs[-1] += text
                    continue

                match = TESTCASE_OUT_RE.match(line)
                symbol, text = match.group(1), match.group(2)
                text = text.strip()
                if symbol == '=':
                    self.result = text
                elif text:
                    if symbol == ':':
                        out = Message('', '', text)
                    elif symbol == '|':
                        out = Print(text)
                    self.outs.append(out)

    def __str__(self):
        return self.test

    def latex(self, output):
        text = ''
        text += ""\\begin{testcase}\n""
        text += ""\\test{%s}\n"" % escape_latex_code(self.test)
        if self.key is None:
            return ''
        results = output[self.key]['results']
        for result in results:
            for out in result['out']:
                kind = 'message' if out['message'] else 'print'
                text += ""\\begin{test%s}%s\\end{test%s}"" % (
                    kind, escape_latex_output(out['text']), kind)
            if result['result']:  # is not None and result['result'].strip():
                text += ""\\begin{testresult}%s\\end{testresult}"" % result[
                    'result']
        text += ""\\end{testcase}""
        return text

    def html(self):
        result = '<div class=""test""><span class=""move""></span>'
        result += '<ul class=""test"" id=""test_%d"">' % self.index
        result += '<li class=""test"">%s</li>' % escape_html(self.test, True)
        result += '</ul>'
        result += '</div>'
        return result
","#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
from os import listdir, path
import pickle
import importlib

from django.utils.html import escape, linebreaks
from django.utils.safestring import mark_safe

from mathics import settings

from mathics import builtin
from mathics.builtin import get_module_doc
from mathics.core.evaluation import Message, Print
from mathics.doc.utils import slugify

CHAPTER_RE = re.compile('(?s)<chapter title=""(.*?)"">(.*?)</chapter>')
SECTION_RE = re.compile('(?s)(.*?)<section title=""(.*?)"">(.*?)</section>')
SUBSECTION_RE = re.compile('(?s)<subsection title=""(.*?)"">')
SUBSECTION_END_RE = re.compile('</subsection>')

TESTCASE_RE = re.compile(r'''(?mx)^
    ((?:.|\n)*?)
    ^\s*(>|\#)>[ ](.*)
    ((?:\n\s*(?:[:|=.][ ]|\.).*)*)
''')
TESTCASE_OUT_RE = re.compile(r'^\s*([:|=])(.*)$')

MATHICS_RE = re.compile(r""(?<!\\)\'(.*?)(?<!\\)\'"")

# preserve space before and after inline code variables
LATEX_RE = re.compile(r""(\s?)\$(\w+?)\$(\s?)"")

DL_RE = re.compile(r""(?s)<dl>(.*?)</dl>"")
DL_ITEM_RE = re.compile(
    r""(?s)<(?P<tag>d[td])>(?P<content>.*?)(?:</(?P=tag)>|)\s*(?:(?=<d[td]>)|$)"")
LIST_RE = re.compile(r""(?s)<(?P<tag>ul|ol)>(?P<content>.*?)</(?P=tag)>"")
LIST_ITEM_RE = re.compile(r""(?s)<li>(.*?)(?:</li>|(?=<li>)|$)"")
CONSOLE_RE = re.compile(
    r""(?s)<(?P<tag>con|console)>(?P<content>.*?)</(?P=tag)>"")
IMG_RE = re.compile(
    r'<img src=""(?P<src>.*?)"" title=""(?P<title>.*?)"" label=""(?P<label>.*?)"">')
REF_RE = re.compile(r'<ref label=""(?P<label>.*?)"">')
PYTHON_RE = re.compile(r'(?s)<python>(.*?)</python>')
LATEX_CHAR_RE = re.compile(r""(?<!\\)(\^)"")

QUOTATIONS_RE = re.compile(r'\""([\w\s,]*?)\""')
HYPERTEXT_RE = re.compile(r""(?s)<(?P<tag>em|url)>(?P<content>.*?)</(?P=tag)>"")

OUTSIDE_ASY_RE = re.compile(r""(?s)((?:^|\\end\{asy\}).*?(?:$|\\begin\{asy\}))"")
LATEX_TEXT_RE = re.compile(
    r""(?s)\\text\{([^{}]*?(?:[^{}]*?\{[^{}]*?(?:[^{}]*?\{[^{}]*?\}[^{}]*?)*?""
    r""[^{}]*?\}[^{}]*?)*?[^{}]*?)\}"")
LATEX_TESTOUT_RE = re.compile(
    r""(?s)\\begin\{(?P<tag>testmessage|testprint|testresult)\}""
    r""(?P<content>.*?)\\end\{(?P=tag)\}"")
LATEX_TESTOUT_DELIM_RE = re.compile(r',')
NUMBER_RE = re.compile(r'(\d*(?<!\.)\.\d+|\d+\.(?!\.)\d*|\d+)')
LATEX_ARRAY_RE = re.compile(
    r'(?s)\\begin\{testresult\}\\begin\{array\}\{l\}(.*?)'
    r'\\end\{array\}\\end\{testresult\}')
LATEX_INLINE_END_RE = re.compile(r""(?s)(?P<all>\\lstinline'[^']*?'\}?[.,;:])"")
LATEX_CONSOLE_RE = re.compile(r""\\console\{(.*?)\}"")

ALLOWED_TAGS = ('dl', 'dd', 'dt', 'em', 'url', 'ul',
                'ol', 'li', 'con', 'console', 'img', 'ref', 'subsection')
ALLOWED_TAGS_RE = dict((allowed, re.compile(
    '&lt;(%s.*?)&gt;' % allowed)) for allowed in ALLOWED_TAGS)

SPECIAL_COMMANDS = {
    'LaTeX': (r'<em>LaTeX</em>', r'\LaTeX{}'),
    'Mathematica': (r'<em>Mathematica</em>&reg;',
                    r'\emph{Mathematica}\textregistered{}'),
    'Mathics': (r'<em>Mathics</em>', r'\emph{Mathics}'),
    'Sage': (r'<em>Sage</em>', r'\emph{Sage}'),
    'Wolfram': (r'<em>Wolfram</em>', r'\emph{Wolfram}'),

    'skip': (r'<br /><br />', r'\bigskip'),
}

try:
    with open(settings.DOC_XML_DATA, 'rb') as xml_data_file:
        xml_data = pickle.load(xml_data_file)
except IOError:
    xml_data = {}


def filter_comments(doc):
    return '\n'.join(line for line in doc.splitlines()
                     if not line.lstrip().startswith('##'))


def strip_system_prefix(name):
    if name.startswith('System`'):
        stripped_name = name[len('System`'):]
        # don't return Private`sym for System`Private`sym
        if '`' not in stripped_name:
            return stripped_name
    return name


def get_latex_escape_char(text):
    for escape_char in (""'"", '~', '@'):
        if escape_char not in text:
            return escape_char
    raise ValueError


def _replace_all(text, pairs):
    for (i, j) in pairs:
        text = text.replace(i, j)
    return text


def escape_latex_output(text):
    "" Escape Mathics output ""

    text = _replace_all(text, [('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
                               ('~', '\\~'), ('&', '\\&'), ('%', '\\%'),
                               ('$', r'\$'), ('_', '\\_')])
    return text


def escape_latex_code(text):
    "" Escape verbatim Mathics input ""

    text = escape_latex_output(text)
    escape_char = get_latex_escape_char(text)
    return '\\lstinline%s%s%s' % (escape_char, text, escape_char)


def escape_latex(text):
    "" Escape documentation text ""

    def repl_python(match):
        return r""""""\begin{lstlisting}[style=python]
%s
\end{lstlisting}"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = _replace_all(text, [
        ('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
        ('~', '\\~{ }'), ('&', '\\&'), ('%', '\\%'), ('#','\\#')
    ])

    def repl(match):
        text = match.group(1)
        if text:
            text = _replace_all(text, [(""\\'"", ""'""), ('^', '\\^')])
            escape_char = get_latex_escape_char(text)
            text = LATEX_RE.sub(
                lambda m: ""%s%s\\codevar{\\textit{%s}}%s\\lstinline%s"" % (
                    escape_char, m.group(1), m.group(2), m.group(3),
                    escape_char),
                text)
            if text.startswith(' '):
                text = r'\ ' + text[1:]
            if text.endswith(' '):
                text = text[:-1] + r'\ '
            return ""\\code{\\lstinline%s%s%s}"" % (
                escape_char, text, escape_char)
        else:
            # treat double '' literaly
            return ""''""

    text = MATHICS_RE.sub(repl, text)

    text = LATEX_RE.sub(lambda m: '%s\\textit{%s}%s' % (
        m.group(1), m.group(2), m.group(3)), text)

    text = text.replace(""\\\\'"", ""'"")

    def repl_dl(match):
        text = match.group(1)
        text = DL_ITEM_RE.sub(lambda m: '\\%(tag)s{%(content)s}\n' %
                              m.groupdict(), text)
        return '\\begin{definitions}%s\\end{definitions}' % text
    text = DL_RE.sub(repl_dl, text)

    def repl_list(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LIST_ITEM_RE.sub(
            lambda m: '\\item %s\n' % m.group(1), content)
        env = 'itemize' if tag == 'ul' else 'enumerate'
        return '\\begin{%s}%s\\end{%s}' % (env, content, env)
    text = LIST_RE.sub(repl_list, text)

    text = _replace_all(text, [
        ('$', r'\$'), ('\u03c0', r'$\pi$'), ('≥', r'$\ge$'), ('≤', r'$\le$'),
        ('≠', r'$\ne$'),
        ('ç',r'\c{c}'),('é',r'\'e'),('ê',r'\^e'),('ñ',r'\~n'),
         ('∫',r'\int'),('',r'd'),   ])

    def repl_char(match):
        char = match.group(1)
        return {
            '^': '$^\wedge$',
        }[char]
    text = LATEX_CHAR_RE.sub(repl_char, text)

    def repl_img(match):
        src = match.group('src')
        title = match.group('title')
        label = match.group('label')
        return r""""""\begin{figure*}[htp]
\centering
\includegraphics[width=\textwidth]{images/%(src)s}
\caption{%(title)s}
\label{%(label)s}
\end{figure*}"""""" % {
            'src': src,
            'title': title,
            'label': label,
        }
    text = IMG_RE.sub(repl_img, text)

    def repl_ref(match):
        return r'figure \ref{%s}' % match.group('label')
    text = REF_RE.sub(repl_ref, text)

    def repl_quotation(match):
        return r""``%s''"" % match.group(1)

    def repl_hypertext(match):
        tag = match.group('tag')
        content = match.group('content')
        if tag == 'em':
            return r'\emph{%s}' % content
        elif tag == 'url':
            return '\\url{%s}' % content

    text = QUOTATIONS_RE.sub(repl_quotation, text)
    text = HYPERTEXT_RE.sub(repl_hypertext, text)

    def repl_console(match):
        tag = match.group('tag')
        content = match.group('content')
        content = content.strip()
        content = content.replace(r'\$', '$')
        if tag == 'con':
            return '\\console{%s}' % content
        else:
            return '\\begin{lstlisting}\n%s\n\\end{lstlisting}' % content
    text = CONSOLE_RE.sub(repl_console, text)

    '''def repl_asy(match):
        """"""
        Ensure \begin{asy} and \end{asy} are on their own line,
        but there shall be no extra empty lines
        """"""
        #tag = match.group(1)
        #return '\n%s\n' % tag
        #print ""replace""
        return '\\end{asy}\n\\begin{asy}'
    text = LATEX_BETWEEN_ASY_RE.sub(repl_asy, text)'''

    def repl_subsection(match):
        return '\n\\subsection*{%s}\n' % match.group(1)
    text = SUBSECTION_RE.sub(repl_subsection, text)
    text = SUBSECTION_END_RE.sub('', text)

    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        # ""\"" has been escaped already => 2 \
        text = text.replace('\\\\' + key, tex)

    text = post_sub(text, post_substitutions)

    return text


def post_process_latex(result):
    """"""
    Some post-processing hacks of generated LaTeX code to handle linebreaks
    """"""

    WORD_SPLIT_RE = re.compile(r'(\s+|\\newline\s*)')

    def wrap_word(word):
        if word.strip() == r'\newline':
            return word
        return r'\text{%s}' % word

    def repl_text(match):
        text = match.group(1)
        if not text:
            return r'\text{}'
        words = WORD_SPLIT_RE.split(text)
        assert len(words) >= 1
        if len(words) > 1:
            text = """"
            index = 0
            while index < len(words) - 1:
                text += '%s%s\\allowbreak{}' % (wrap_word(
                    words[index]), wrap_word(words[index + 1]))
                index += 2
            text += wrap_word(words[-1])
        else:
            text = r'\text{%s}' % words[0]
        if not text:
            return r'\text{}'
        text = text.replace('><', r'>}\allowbreak\text{<')
        return text

    def repl_out_delim(match):
        return ',\\allowbreak{}'

    def repl_number(match):
        guard = r'\allowbreak{}'
        inter_groups_pre = r'\,\discretionary{\~{}}{\~{}}{}'
        inter_groups_post = r'\discretionary{\~{}}{\~{}}{}'
        number = match.group(1)
        parts = number.split('.')
        if len(number) <= 3:
            return number
        assert 1 <= len(parts) <= 2
        pre_dec = parts[0]
        groups = []
        while pre_dec:
            groups.append(pre_dec[-3:])
            pre_dec = pre_dec[:-3]
        pre_dec = inter_groups_pre.join(reversed(groups))
        if len(parts) == 2:
            post_dec = parts[1]
            groups = []
            while post_dec:
                groups.append(post_dec[:3])
                post_dec = post_dec[3:]
            post_dec = inter_groups_post.join(groups)
            result = pre_dec + '.' + post_dec
        else:
            result = pre_dec
        return guard + result + guard

    def repl_array(match):
        content = match.group(1)
        lines = content.split('\\\\')
        content = ''.join(r'\begin{dmath*}%s\end{dmath*}' %
                          line for line in lines if line.strip())
        return r'\begin{testresultlist}%s\end{testresultlist}' % content

    def repl_out(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LATEX_TESTOUT_DELIM_RE.sub(repl_out_delim, content)
        content = NUMBER_RE.sub(repl_number, content)
        content = content.replace(r'\left[', r'\left[\allowbreak{}')
        return '\\begin{%s}%s\\end{%s}' % (tag, content, tag)

    def repl_inline_end(match):
        "" Prevent linebreaks between inline code and sentence delimeters ""

        code = match.group('all')
        if code[-2] == '}':
            code = code[:-2] + code[-1] + code[-2]
        return r'\mbox{%s}' % code

    def repl_console(match):
        code = match.group(1)
        code = code.replace('/', r'/\allowbreak{}')
        return r'\console{%s}' % code

    def repl_nonasy(match):
        result = match.group(1)
        result = LATEX_TEXT_RE.sub(repl_text, result)
        result = LATEX_TESTOUT_RE.sub(repl_out, result)
        result = LATEX_ARRAY_RE.sub(repl_array, result)
        result = LATEX_INLINE_END_RE.sub(repl_inline_end, result)
        result = LATEX_CONSOLE_RE.sub(repl_console, result)
        return result

    return OUTSIDE_ASY_RE.sub(repl_nonasy, result)

POST_SUBSTITUTION_TAG = '_POST_SUBSTITUTION%d_'


def pre_sub(re, text, repl_func):
    post_substitutions = []

    def repl_pre(match):
        repl = repl_func(match)
        index = len(post_substitutions)
        post_substitutions.append(repl)
        return POST_SUBSTITUTION_TAG % index

    text = re.sub(repl_pre, text)

    return text, post_substitutions


def post_sub(text, post_substitutions):
    for index, sub in enumerate(post_substitutions):
        text = text.replace(POST_SUBSTITUTION_TAG % index, sub)
    return text


def escape_html(text, verbatim_mode=False, counters=None, single_line=False):
    def repl_python(match):
        return r""""""<pre><![CDATA[
%s
]]></pre>"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    if not verbatim_mode:
        def repl_quotation(match):
            return r""&ldquo;%s&rdquo;"" % match.group(1)
        text = QUOTATIONS_RE.sub(repl_quotation, text)

    if counters is None:
        counters = {}

    text = text.replace('""', '&quot;')
    if not verbatim_mode:
        def repl_latex(match):
            return '%s<var>%s</var>%s' % (
                match.group(1), match.group(2), match.group(3))

        text = LATEX_RE.sub(repl_latex, text)

        def repl_mathics(match):
            text = match.group(1)
            text = text.replace(""\\'"", ""'"")
            text = text.replace(' ', '&nbsp;')
            if text:
                return ""<code>%s</code>"" % text
            else:
                return ""'""

        def repl_allowed(match):
            content = _replace_all(match.group(1), [
                ('&ldquo;', '""'), ('&rdquo;', '""'), ('&quot;', '""')])
            return '<%s>' % content

        text = MATHICS_RE.sub(repl_mathics, text)
        for allowed in ALLOWED_TAGS:
            text = ALLOWED_TAGS_RE[allowed].sub(repl_allowed, text)
            text = text.replace('&lt;/%s&gt;' % allowed, '</%s>' % allowed)

        def repl_dl(match):
            text = match.group(1)
            text = DL_ITEM_RE.sub(
                lambda m: '<%(tag)s>%(content)s</%(tag)s>\n' % m.groupdict(),
                text)
            return '<dl>%s</dl>' % text

        text = DL_RE.sub(repl_dl, text)

        def repl_list(match):
            tag = match.group('tag')
            content = match.group('content')
            content = LIST_ITEM_RE.sub(
                lambda m: '<li>%s</li>' % m.group(1), content)
            return '<%s>%s</%s>' % (tag, content, tag)

        text = LIST_RE.sub(repl_list, text)

        def repl_hypertext(match):
            tag = match.group('tag')
            content = match.group('content')
            if tag == 'em':
                return r'<em>%s</em>' % content
            elif tag == 'url':
                return r'<a href=""%s"">%s</a>' % (content, content)

        text = HYPERTEXT_RE.sub(repl_hypertext, text)

        def repl_console(match):
            tag = match.group('tag')
            content = match.group('content')
            tag = 'div' if tag == 'console' else 'span'
            content = content.strip()
            pre = post = ''

            # gets replaced for <br /> later by DocText.html()
            content = content.replace('\n', '<br>')

            return r'<%s class=""console"">%s%s%s</%s>' % (
                tag, pre, content, post, tag)

        text = CONSOLE_RE.sub(repl_console, text)

        def repl_img(match):
            src = match.group('src')
            title = match.group('title')
            return (r'<a href=""/media/doc/%(src)s.pdf"">'
                    r'<img src=""/media/doc/%(src)s.png"" title=""%(title)s"" />'
                    r'</a>') % {'src': src, 'title': title}
        text = IMG_RE.sub(repl_img, text)

        def repl_ref(match):
            # TODO: this is not an optimal solution - maybe we need figure
            # numbers in the XML doc as well?
            return r'the following figure'
        text = REF_RE.sub(repl_ref, text)

        def repl_subsection(match):
            return '\n<h2>%s</h2>\n' % match.group(1)
        text = SUBSECTION_RE.sub(repl_subsection, text)
        text = SUBSECTION_END_RE.sub('', text)

        text = text.replace(""\\'"", ""'"")
    else:
        text = text.replace(' ', '&nbsp;')
        text = '<code>%s</code>' % text
    text = text.replace(""'"", '&#39;')
    text = text.replace('---', '&mdash;')
    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        text = text.replace('\\' + key, xml)

    if not single_line:
        text = linebreaks(text)
        text = text.replace('<br />', '\n').replace('<br>', '<br />')

    text = post_sub(text, post_substitutions)

    text = text.replace('<p><pre>', '<pre>').replace('</pre></p>', '</pre>')

    return text


class Tests(object):
    def __init__(self, part, chapter, section, tests):
        self.part, self.chapter = part, chapter
        self.section, self.tests = section, tests


class DocElement(object):
    def href(self, ajax=False):
        if ajax:
            return ""javascript:loadDoc('%s')"" % self.get_url()
        else:
            return ""/doc%s"" % self.get_url()

    def get_prev(self):
        return self.get_prev_next()[0]

    def get_next(self):
        return self.get_prev_next()[1]

    def get_collection(self):
        return []

    def get_prev_next(self):
        collection = self.get_collection()
        index = collection.index(self)
        prev = collection[index - 1] if index > 0 else None
        next = collection[index + 1] if index < len(collection) - 1 else None
        return prev, next

    def get_title_html(self):
        return mark_safe(escape_html(self.title, single_line=True))


class Documentation(DocElement):

    def __str__(self):
        return '\n\n\n'.join(str(part) for part in self.parts)

    def get_tests(self):
        for part in self.parts:
            for chapter in part.chapters:
                tests = chapter.doc.get_tests()
                if tests:
                    yield Tests(part.title, chapter.title, '', tests)
                for section in chapter.sections:
                    if section.installed:
                        tests = section.doc.get_tests()
                        if tests:
                            yield Tests(
                                part.title, chapter.title, section.title, tests)

    def get_part(self, part_slug):
        return self.parts_by_slug.get(part_slug)

    def get_chapter(self, part_slug, chapter_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            return part.chapters_by_slug.get(chapter_slug)
        return None
        """"""for part in self.parts:
            if part.slug == part_slug:
                for chapter in self:
                    pass""""""

    def get_section(self, part_slug, chapter_slug, section_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            chapter = part.chapters_by_slug.get(chapter_slug)
            if chapter:
                return chapter.sections_by_slug.get(section_slug)
        return None

    def latex(self, output):
        parts = []
        appendix = False
        for part in self.parts:
            text = part.latex(output)
            if part.is_appendix and not appendix:
                appendix = True
                text = '\n\\appendix\n' + text
            parts.append(text)
        result = '\n\n'.join(parts)
        result = post_process_latex(result)
        return result

    def get_url(self):
        return '/'

    def search(self, query):
        query = query.strip()
        query_parts = [q.strip().lower() for q in query.split()]

        def matches(text):
            text = text.lower()
            return all(q in text for q in query_parts)

        result = []
        for part in self.parts:
            if matches(part.title):
                result.append((False, part))
            for chapter in part.chapters:
                if matches(chapter.title):
                    result.append((False, chapter))
                for section in chapter.sections:
                    if matches(section.title):
                        result.append((section.title == query, section))
                    elif query == section.operator:
                        result.append((True, section))
        return result


class MathicsMainDocumentation(Documentation):
    def __init__(self):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = settings.DOC_DIR
        self.xml_data_file = settings.DOC_XML_DATA
        self.tex_data_file = settings.DOC_TEX_DATA
        self.latex_file = settings.DOC_LATEX_FILE
        self.pymathics_doc_loaded = False
        files = listdir(self.doc_dir)
        files.sort()
        appendix = []

        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        for title, modules, builtins_by_module, start in [(
            ""Reference of built-in symbols"", builtin.modules,
            builtin.builtins_by_module, True)]:     # nopep8
            # (""Reference of optional symbols"", optional.modules,
            #  optional.optional_builtins_by_module, False)]:

            builtin_part = DocPart(self, title, is_reference=start)
            for module in modules:
                title, text = get_module_doc(module)
                chapter = DocChapter(builtin_part, title, Doc(text))
                builtins = builtins_by_module[module.__name__]
                for instance in builtins:
                    installed = True
                    for package in getattr(instance, 'requires', []):
                        try:
                            importlib.import_module(package)
                        except ImportError:
                            installed = False
                            break
                    section = DocSection(
                        chapter, strip_system_prefix(instance.get_name()),
                        instance.__doc__ or '',
                        operator=instance.get_operator(),
                        installed=installed)
                    chapter.sections.append(section)
                builtin_part.chapters.append(chapter)
            self.parts.append(builtin_part)

        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)

    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        # Look the ""Pymathics Modules"" part, and if it does not exist, create it.
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        # For each module, create the documentation object and load the chapters in the pymathics part.
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule.name} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True


class PyMathicsDocumentation(Documentation):
    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        # Load the module and verifies it is a pymathics module
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        if hasattr(self.pymathicsmodule, ""pymathics_version_data""):
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        else:
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        # Paths
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        # Load the dictionary of mathics symbols defined in the module
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        # Defines de default first part, in case we are building an independent documentation module.
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        # Builds the automatic documentation
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        # Adds possible appendices
        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)


class DocPart(DocElement):
    def __init__(self, doc, title, is_reference=False):
        self.doc = doc
        self.title = title
        self.slug = slugify(title)
        self.chapters = []
        self.chapters_by_slug = {}
        self.is_reference = is_reference
        self.is_appendix = False
        doc.parts_by_slug[self.slug] = self

    def __str__(self):
        return '%s\n\n%s' % (
            self.title, '\n'.join(str(chapter) for chapter in self.chapters))

    def latex(self, output):
        result = '\n\n\\part{%s}\n\n' % escape_latex(self.title) + (
            '\n\n'.join(chapter.latex(output) for chapter in self.chapters))
        if self.is_reference:
            result = '\n\n\\referencestart' + result
        return result

    def get_url(self):
        return '/%s/' % self.slug

    def get_collection(self):
        return self.doc.parts


class DocChapter(DocElement):
    def __init__(self, part, title, doc=None):
        self.part = part
        self.title = title
        self.slug = slugify(title)
        self.doc = doc
        self.sections = []
        self.sections_by_slug = {}
        part.chapters_by_slug[self.slug] = self

    def __str__(self):
        return '= %s =\n\n%s' % (
            self.title, '\n'.join(str(section) for section in self.sections))

    def latex(self, output):
        intro = self.doc.latex(output).strip()
        if intro:
            short = 'short' if len(intro) < 300 else ''
            intro = '\\begin{chapterintro%s}\n%s\n\n\\end{chapterintro%s}' % (
                short, intro, short)
        return ''.join([
            '\n\n\\chapter{%(title)s}\n\\chapterstart\n\n%(intro)s' % {
                'title': escape_latex(self.title),
                'intro': intro},
            '\\chaptersections\n',
            '\n\n'.join(
                section.latex(output) for section in self.sections),
            '\n\\chapterend\n'])

    def get_url(self):
        return '/%s/%s/' % (self.part.slug, self.slug)

    def get_collection(self):
        return self.part.chapters


class DocSection(DocElement):
    def __init__(self, chapter, title, text, operator=None, installed=True):
        self.chapter = chapter
        self.title = title
        self.slug = slugify(title)
        if text.count(""<dl>"") != text.count(""</dl>""):
            raise ValueError(""Missing opening or closing <dl> tag in ""
                             ""{} documentation"".format(title))
        self.doc = Doc(text)
        self.operator = operator
        self.installed = installed
        chapter.sections_by_slug[self.slug] = self

    def __str__(self):
        return '== %s ==\n%s' % (self.title, self.doc)

    def latex(self, output):
        title = escape_latex(self.title)
        if self.operator:
            title += "" (\\code{%s})"" % escape_latex_code(self.operator)
        index = '\index{%s}' % escape_latex(
            self.title) if self.chapter.part.is_reference else ''
        return (
            '\n\n\\section*{%(title)s}%(index)s\n'
            '\\sectionstart\n\n%(content)s\\sectionend'
            '\\addcontentsline{toc}{section}{%(title)s}') % {
                'title': title,
                'index': index,
                'content': self.doc.latex(output)
            }

    def get_url(self):
        return '/%s/%s/%s/' % (
            self.chapter.part.slug, self.chapter.slug, self.slug)

    def get_collection(self):
        return self.chapter.sections

    def html_data(self):
        indices = set()
        for test in self.doc.items:
            indices.update(test.test_indices())
        result = {}
        for index in indices:
            result[index] = xml_data.get((
                self.chapter.part.title, self.chapter.title, self.title,
                index))
        return result


class Doc(object):
    def __init__(self, doc):
        self.items = []
        # remove commented lines
        doc = filter_comments(doc)
        # pre-substitute Python code because it might contain tests
        doc, post_substitutions = pre_sub(
            PYTHON_RE, doc, lambda m: '<python>%s</python>' % m.group(1))
        # HACK: Artificially construct a last testcase to get the ""intertext""
        # after the last (real) testcase. Ignore the test, of course.
        doc += '\n>> test\n = test'
        testcases = TESTCASE_RE.findall(doc)
        tests = None
        for index in range(len(testcases)):
            testcase = list(testcases[index])
            text = testcase.pop(0).strip()
            if text:
                if tests is not None:
                    self.items.append(tests)
                    tests = None
                text = post_sub(text, post_substitutions)
                self.items.append(DocText(text))
                tests = None
            if index < len(testcases) - 1:
                test = DocTest(index, testcase)
                if tests is None:
                    tests = DocTests()
                if not test.ignore:
                    tests.tests.append(test)
            if tests is not None:
                self.items.append(tests)
                tests = None

    def __str__(self):
        return '\n'.join(str(item) for item in self.items)

    def text(self, detail_level):
        # used for introspection
        # TODO parse XML and pretty print
        # HACK
        item = str(self.items[0])
        item = '\n'.join(line.strip() for line in item.split('\n'))
        item = item.replace('<dl>', '')
        item = item.replace('</dl>', '')
        item = item.replace('<dt>', '  ')
        item = item.replace('</dt>', '')
        item = item.replace('<dd>', '    ')
        item = item.replace('</dd>', '')
        item = '\n'.join(line for line in item.split('\n') if not line.isspace())
        return item

    def get_tests(self):
        tests = []
        for item in self.items:
            tests.extend(item.get_tests())
        return tests

    def latex(self, output):
        return '\n'.join(item.latex(output) for item in self.items
                         if not item.is_private())

    def html(self):
        counters = {}
        return mark_safe('\n'.join(item.html(counters) for item in self.items
                         if not item.is_private()))


class DocText(object):
    def __init__(self, text):
        self.text = text

    def get_tests(self):
        return []

    def is_private(self):
        return False

    def __str__(self):
        return self.text

    def latex(self, output):
        return escape_latex(self.text)

    def html(self, counters=None):
        result = escape_html(self.text, counters=counters)
        return result

    def test_indices(self):
        return []


class DocTests(object):
    def __init__(self):
        self.tests = []

    def get_tests(self):
        return self.tests

    def is_private(self):
        return all(test.private for test in self.tests)

    def __str__(self):
        return '\n'.join(str(test) for test in self.tests)

    def latex(self, output):
        if len(self.tests) == 0:
            return ""\n""

        testLatexStrings = [test.latex(output) for test in self.tests
                       if not test.private]
        testLatexStrings = [t for t in testLatexStrings if len(t)>1]
        if len(testLatexStrings) == 0:
            return ""\n""
        
        return '\\begin{tests}%%\n%s%%\n\\end{tests}' % (
            '%\n'.join(testLatexStrings))

    def html(self, counters=None):
        if len(self.tests) == 0:
            return ""\n""        
        return '<ul class=""tests"">%s</ul>' % (
            '\n'.join('<li>%s</li>' % test.html() for test in self.tests
                      if not test.private))

    def test_indices(self):
        return [test.index for test in self.tests]


class DocTest(object):
    """"""
    DocTest formatting rules:

    #> signifies private test that does not appear as part of the documentation
    X> outputs the docs as normal, but the test is not run
    = compares the result text
    : compares an (error) Message
    | signifies Print outpt
    """"""
    def __init__(self, index, testcase):
        self.index = index
        self.result = None
        self.outs = []
        # Private test cases are executed, but NOT shown as part of the docs
        self.private = testcase[0] == '#'
        # Ignored test cases are NOT executed, but shown as part of the docs
        if testcase[0] == 'X':
            self.ignore = True
            # substitute '>' again so we get the correct formatting
            testcase[0] = '>'
        else:
            self.ignore = False

        self.test = testcase[1].strip()

        self.key = None
        outs = testcase[2].splitlines()
        for line in outs:
            line = line.strip()
            if line:
                if line.startswith('.'):
                    text = line[1:]
                    if text.startswith(' '):
                        text = text[1:]
                    text = '\n' + text
                    if self.result is not None:
                        self.result += text
                    elif self.outs:
                        self.outs[-1] += text
                    continue

                match = TESTCASE_OUT_RE.match(line)
                symbol, text = match.group(1), match.group(2)
                text = text.strip()
                if symbol == '=':
                    self.result = text
                elif text:
                    if symbol == ':':
                        out = Message('', '', text)
                    elif symbol == '|':
                        out = Print(text)
                    self.outs.append(out)

    def __str__(self):
        return self.test

    def latex(self, output):
        text = ''
        text += ""\\begin{testcase}\n""
        text += ""\\test{%s}\n"" % escape_latex_code(self.test)
        if self.key is None:
            return ''
        results = output[self.key]['results']
        for result in results:
            for out in result['out']:
                kind = 'message' if out['message'] else 'print'
                text += ""\\begin{test%s}%s\\end{test%s}"" % (
                    kind, escape_latex_output(out['text']), kind)
            if result['result']:  # is not None and result['result'].strip():
                text += ""\\begin{testresult}%s\\end{testresult}"" % result[
                    'result']
        text += ""\\end{testcase}""
        return text

    def html(self):
        result = '<div class=""test""><span class=""move""></span>'
        result += '<ul class=""test"" id=""test_%d"">' % self.index
        result += '<li class=""test"">%s</li>' % escape_html(self.test, True)
        result += '</ul>'
        result += '</div>'
        return result
",MathicsMainDocumentation.load_pymathics_doc,https://github.com/mathics/Mathics/issues/906,"[{'piece_type': 'error message', 'piece_content': '$ mathicsserver\nwarning: database file /home/pablo/.local/var/mathics/mathics.sqlite not found\n\nMigrating database /home/pablo/.local/var/mathics/mathics.sqlite\nTraceback (most recent call last):\nFile ""/home/pablo/Documents/Mathics/mathics/manage.py"", line 13, in <module>\nexecute_from_command_line(sys.argv)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 381, in execute_from_command_line\nutility.execute()\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 375, in execute\nself.fetch_command(subcommand).run_from_argv(self.argv)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 323, in run_from_argv\nself.execute(*args, **cmd_options)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 361, in execute\nself.check()\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 390, in check\ninclude_deployment_checks=include_deployment_checks,\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/commands/migrate.py"", line 65, in _run_checks\nissues.extend(super()._run_checks(**kwargs))\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 377, in _run_checks\nreturn checks.run_checks(**kwargs)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/registry.py"", line 72, in run_checks\nnew_errors = check(app_configs=app_configs)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 40, in check_url_namespaces_unique\nall_namespaces = _load_all_namespaces(resolver)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 57, in _load_all_namespaces\nurl_patterns = getattr(resolver, \'url_patterns\', [])\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__\nres = instance.__dict__[self.name] = self.func(instance)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 571, in url_patterns\npatterns = getattr(self.urlconf_module, ""urlpatterns"", self.urlconf_module)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__\nres = instance.__dict__[self.name] = self.func(instance)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 564, in urlconf_module\nreturn import_module(self.urlconf_name)\nFile ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module\nreturn _bootstrap._gcd_import(name[level:], package, level)\nFile ""<frozen importlib._bootstrap>"", line 994, in _gcd_import\nFile ""<frozen importlib._bootstrap>"", line 971, in _find_and_load\nFile ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked\nFile ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked\nFile ""<frozen importlib._bootstrap_external>"", line 678, in exec_module\nFile ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed\nFile ""/home/pablo/Documents/Mathics/mathics/urls.py"", line 14, in <module>\nurl(r\'^\', include(\'mathics.web.urls\')),\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/conf.py"", line 34, in include\nurlconf_module = import_module(urlconf_module)\nFile ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module\nreturn _bootstrap._gcd_import(name[level:], package, level)\nFile ""<frozen importlib._bootstrap>"", line 994, in _gcd_import\nFile ""<frozen importlib._bootstrap>"", line 971, in _find_and_load\nFile ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked\nFile ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked\nFile ""<frozen importlib._bootstrap_external>"", line 678, in exec_module\nFile ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed\nFile ""/home/pablo/Documents/Mathics/mathics/web/urls.py"", line 6, in <module>\nfrom mathics.web.views import query, main_view, login, logout, save, open, get_worksheets, doc_search, doc_part, doc_chapter, doc_section, doc\nFile ""/home/pablo/Documents/Mathics/mathics/web/views.py"", line 28, in <module>\ndocumentation.load_pymathics_doc()\nFile ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 727, in load_pymathics_doc\npymathicsdoc = PyMathicsDocumentation(pymmodule)\nFile ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 765, in __init__\nself.name = self.pymathicsmodule.pymathics_version_data[\'name\']\nKeyError: \'name\'\nerror: failed to create database'}]","$ mathicsserver
warning: database file /home/pablo/.local/var/mathics/mathics.sqlite not found

Migrating database /home/pablo/.local/var/mathics/mathics.sqlite
Traceback (most recent call last):
File ""/home/pablo/Documents/Mathics/mathics/manage.py"", line 13, in <module>
execute_from_command_line(sys.argv)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 381, in execute_from_command_line
utility.execute()
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 375, in execute
self.fetch_command(subcommand).run_from_argv(self.argv)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 323, in run_from_argv
self.execute(*args, **cmd_options)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 361, in execute
self.check()
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 390, in check
include_deployment_checks=include_deployment_checks,
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/commands/migrate.py"", line 65, in _run_checks
issues.extend(super()._run_checks(**kwargs))
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 377, in _run_checks
return checks.run_checks(**kwargs)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/registry.py"", line 72, in run_checks
new_errors = check(app_configs=app_configs)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 40, in check_url_namespaces_unique
all_namespaces = _load_all_namespaces(resolver)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 57, in _load_all_namespaces
url_patterns = getattr(resolver, 'url_patterns', [])
File ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__
res = instance.__dict__[self.name] = self.func(instance)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 571, in url_patterns
patterns = getattr(self.urlconf_module, ""urlpatterns"", self.urlconf_module)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__
res = instance.__dict__[self.name] = self.func(instance)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 564, in urlconf_module
return import_module(self.urlconf_name)
File ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module
return _bootstrap._gcd_import(name[level:], package, level)
File ""<frozen importlib._bootstrap>"", line 994, in _gcd_import
File ""<frozen importlib._bootstrap>"", line 971, in _find_and_load
File ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked
File ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked
File ""<frozen importlib._bootstrap_external>"", line 678, in exec_module
File ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed
File ""/home/pablo/Documents/Mathics/mathics/urls.py"", line 14, in <module>
url(r'^', include('mathics.web.urls')),
File ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/conf.py"", line 34, in include
urlconf_module = import_module(urlconf_module)
File ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module
return _bootstrap._gcd_import(name[level:], package, level)
File ""<frozen importlib._bootstrap>"", line 994, in _gcd_import
File ""<frozen importlib._bootstrap>"", line 971, in _find_and_load
File ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked
File ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked
File ""<frozen importlib._bootstrap_external>"", line 678, in exec_module
File ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed
File ""/home/pablo/Documents/Mathics/mathics/web/urls.py"", line 6, in <module>
from mathics.web.views import query, main_view, login, logout, save, open, get_worksheets, doc_search, doc_part, doc_chapter, doc_section, doc
File ""/home/pablo/Documents/Mathics/mathics/web/views.py"", line 28, in <module>
documentation.load_pymathics_doc()
File ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 727, in load_pymathics_doc
pymathicsdoc = PyMathicsDocumentation(pymmodule)
File ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 765, in __init__
self.name = self.pymathicsmodule.pymathics_version_data['name']
KeyError: 'name'
error: failed to create database",KeyError,"    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule.name} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True","    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True",[],[],buggy_snippets_files/c98cf1a03e1d7e716b228fbe8420bc4461d7e635cdc765c6739adf7ed3361e73_before_merge.py,buggy_snippets_files/c98cf1a03e1d7e716b228fbe8420bc4461d7e635cdc765c6739adf7ed3361e73_after_merge.py
"    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        # Load the module and verifies it is a pymathics module
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        try:
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        except (AttributeError, KeyError, IndexError):
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        # Paths
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        # Load the dictionary of mathics symbols defined in the module
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        # Defines de default first part, in case we are building an independent documentation module.
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        # Builds the automatic documentation
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        # Adds possible appendices
        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)","    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        # Load the module and verifies it is a pymathics module
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        if hasattr(self.pymathicsmodule, ""pymathics_version_data""):
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        else:
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        # Paths
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        # Load the dictionary of mathics symbols defined in the module
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        # Defines de default first part, in case we are building an independent documentation module.
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        # Builds the automatic documentation
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        # Adds possible appendices
        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)",mathics/doc/doc.py,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
from os import listdir, path
import pickle
import importlib

from django.utils.html import escape, linebreaks
from django.utils.safestring import mark_safe

from mathics import settings

from mathics import builtin
from mathics.builtin import get_module_doc
from mathics.core.evaluation import Message, Print
from mathics.doc.utils import slugify

CHAPTER_RE = re.compile('(?s)<chapter title=""(.*?)"">(.*?)</chapter>')
SECTION_RE = re.compile('(?s)(.*?)<section title=""(.*?)"">(.*?)</section>')
SUBSECTION_RE = re.compile('(?s)<subsection title=""(.*?)"">')
SUBSECTION_END_RE = re.compile('</subsection>')

TESTCASE_RE = re.compile(r'''(?mx)^
    ((?:.|\n)*?)
    ^\s*(>|\#)>[ ](.*)
    ((?:\n\s*(?:[:|=.][ ]|\.).*)*)
''')
TESTCASE_OUT_RE = re.compile(r'^\s*([:|=])(.*)$')

MATHICS_RE = re.compile(r""(?<!\\)\'(.*?)(?<!\\)\'"")

# preserve space before and after inline code variables
LATEX_RE = re.compile(r""(\s?)\$(\w+?)\$(\s?)"")

DL_RE = re.compile(r""(?s)<dl>(.*?)</dl>"")
DL_ITEM_RE = re.compile(
    r""(?s)<(?P<tag>d[td])>(?P<content>.*?)(?:</(?P=tag)>|)\s*(?:(?=<d[td]>)|$)"")
LIST_RE = re.compile(r""(?s)<(?P<tag>ul|ol)>(?P<content>.*?)</(?P=tag)>"")
LIST_ITEM_RE = re.compile(r""(?s)<li>(.*?)(?:</li>|(?=<li>)|$)"")
CONSOLE_RE = re.compile(
    r""(?s)<(?P<tag>con|console)>(?P<content>.*?)</(?P=tag)>"")
IMG_RE = re.compile(
    r'<img src=""(?P<src>.*?)"" title=""(?P<title>.*?)"" label=""(?P<label>.*?)"">')
REF_RE = re.compile(r'<ref label=""(?P<label>.*?)"">')
PYTHON_RE = re.compile(r'(?s)<python>(.*?)</python>')
LATEX_CHAR_RE = re.compile(r""(?<!\\)(\^)"")

QUOTATIONS_RE = re.compile(r'\""([\w\s,]*?)\""')
HYPERTEXT_RE = re.compile(r""(?s)<(?P<tag>em|url)>(?P<content>.*?)</(?P=tag)>"")

OUTSIDE_ASY_RE = re.compile(r""(?s)((?:^|\\end\{asy\}).*?(?:$|\\begin\{asy\}))"")
LATEX_TEXT_RE = re.compile(
    r""(?s)\\text\{([^{}]*?(?:[^{}]*?\{[^{}]*?(?:[^{}]*?\{[^{}]*?\}[^{}]*?)*?""
    r""[^{}]*?\}[^{}]*?)*?[^{}]*?)\}"")
LATEX_TESTOUT_RE = re.compile(
    r""(?s)\\begin\{(?P<tag>testmessage|testprint|testresult)\}""
    r""(?P<content>.*?)\\end\{(?P=tag)\}"")
LATEX_TESTOUT_DELIM_RE = re.compile(r',')
NUMBER_RE = re.compile(r'(\d*(?<!\.)\.\d+|\d+\.(?!\.)\d*|\d+)')
LATEX_ARRAY_RE = re.compile(
    r'(?s)\\begin\{testresult\}\\begin\{array\}\{l\}(.*?)'
    r'\\end\{array\}\\end\{testresult\}')
LATEX_INLINE_END_RE = re.compile(r""(?s)(?P<all>\\lstinline'[^']*?'\}?[.,;:])"")
LATEX_CONSOLE_RE = re.compile(r""\\console\{(.*?)\}"")

ALLOWED_TAGS = ('dl', 'dd', 'dt', 'em', 'url', 'ul',
                'ol', 'li', 'con', 'console', 'img', 'ref', 'subsection')
ALLOWED_TAGS_RE = dict((allowed, re.compile(
    '&lt;(%s.*?)&gt;' % allowed)) for allowed in ALLOWED_TAGS)

SPECIAL_COMMANDS = {
    'LaTeX': (r'<em>LaTeX</em>', r'\LaTeX{}'),
    'Mathematica': (r'<em>Mathematica</em>&reg;',
                    r'\emph{Mathematica}\textregistered{}'),
    'Mathics': (r'<em>Mathics</em>', r'\emph{Mathics}'),
    'Sage': (r'<em>Sage</em>', r'\emph{Sage}'),
    'Wolfram': (r'<em>Wolfram</em>', r'\emph{Wolfram}'),

    'skip': (r'<br /><br />', r'\bigskip'),
}

try:
    with open(settings.DOC_XML_DATA, 'rb') as xml_data_file:
        xml_data = pickle.load(xml_data_file)
except IOError:
    xml_data = {}


def filter_comments(doc):
    return '\n'.join(line for line in doc.splitlines()
                     if not line.lstrip().startswith('##'))


def strip_system_prefix(name):
    if name.startswith('System`'):
        stripped_name = name[len('System`'):]
        # don't return Private`sym for System`Private`sym
        if '`' not in stripped_name:
            return stripped_name
    return name


def get_latex_escape_char(text):
    for escape_char in (""'"", '~', '@'):
        if escape_char not in text:
            return escape_char
    raise ValueError


def _replace_all(text, pairs):
    for (i, j) in pairs:
        text = text.replace(i, j)
    return text


def escape_latex_output(text):
    "" Escape Mathics output ""

    text = _replace_all(text, [('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
                               ('~', '\\~'), ('&', '\\&'), ('%', '\\%'),
                               ('$', r'\$'), ('_', '\\_')])
    return text


def escape_latex_code(text):
    "" Escape verbatim Mathics input ""

    text = escape_latex_output(text)
    escape_char = get_latex_escape_char(text)
    return '\\lstinline%s%s%s' % (escape_char, text, escape_char)


def escape_latex(text):
    "" Escape documentation text ""

    def repl_python(match):
        return r""""""\begin{lstlisting}[style=python]
%s
\end{lstlisting}"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = _replace_all(text, [
        ('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
        ('~', '\\~{ }'), ('&', '\\&'), ('%', '\\%'), ('#','\\#')
    ])

    def repl(match):
        text = match.group(1)
        if text:
            text = _replace_all(text, [(""\\'"", ""'""), ('^', '\\^')])
            escape_char = get_latex_escape_char(text)
            text = LATEX_RE.sub(
                lambda m: ""%s%s\\codevar{\\textit{%s}}%s\\lstinline%s"" % (
                    escape_char, m.group(1), m.group(2), m.group(3),
                    escape_char),
                text)
            if text.startswith(' '):
                text = r'\ ' + text[1:]
            if text.endswith(' '):
                text = text[:-1] + r'\ '
            return ""\\code{\\lstinline%s%s%s}"" % (
                escape_char, text, escape_char)
        else:
            # treat double '' literaly
            return ""''""

    text = MATHICS_RE.sub(repl, text)

    text = LATEX_RE.sub(lambda m: '%s\\textit{%s}%s' % (
        m.group(1), m.group(2), m.group(3)), text)

    text = text.replace(""\\\\'"", ""'"")

    def repl_dl(match):
        text = match.group(1)
        text = DL_ITEM_RE.sub(lambda m: '\\%(tag)s{%(content)s}\n' %
                              m.groupdict(), text)
        return '\\begin{definitions}%s\\end{definitions}' % text
    text = DL_RE.sub(repl_dl, text)

    def repl_list(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LIST_ITEM_RE.sub(
            lambda m: '\\item %s\n' % m.group(1), content)
        env = 'itemize' if tag == 'ul' else 'enumerate'
        return '\\begin{%s}%s\\end{%s}' % (env, content, env)
    text = LIST_RE.sub(repl_list, text)

    text = _replace_all(text, [
        ('$', r'\$'), ('\u03c0', r'$\pi$'), ('≥', r'$\ge$'), ('≤', r'$\le$'),
        ('≠', r'$\ne$'),
        ('ç',r'\c{c}'),('é',r'\'e'),('ê',r'\^e'),('ñ',r'\~n'),
         ('∫',r'\int'),('',r'd'),   ])

    def repl_char(match):
        char = match.group(1)
        return {
            '^': '$^\wedge$',
        }[char]
    text = LATEX_CHAR_RE.sub(repl_char, text)

    def repl_img(match):
        src = match.group('src')
        title = match.group('title')
        label = match.group('label')
        return r""""""\begin{figure*}[htp]
\centering
\includegraphics[width=\textwidth]{images/%(src)s}
\caption{%(title)s}
\label{%(label)s}
\end{figure*}"""""" % {
            'src': src,
            'title': title,
            'label': label,
        }
    text = IMG_RE.sub(repl_img, text)

    def repl_ref(match):
        return r'figure \ref{%s}' % match.group('label')
    text = REF_RE.sub(repl_ref, text)

    def repl_quotation(match):
        return r""``%s''"" % match.group(1)

    def repl_hypertext(match):
        tag = match.group('tag')
        content = match.group('content')
        if tag == 'em':
            return r'\emph{%s}' % content
        elif tag == 'url':
            return '\\url{%s}' % content

    text = QUOTATIONS_RE.sub(repl_quotation, text)
    text = HYPERTEXT_RE.sub(repl_hypertext, text)

    def repl_console(match):
        tag = match.group('tag')
        content = match.group('content')
        content = content.strip()
        content = content.replace(r'\$', '$')
        if tag == 'con':
            return '\\console{%s}' % content
        else:
            return '\\begin{lstlisting}\n%s\n\\end{lstlisting}' % content
    text = CONSOLE_RE.sub(repl_console, text)

    '''def repl_asy(match):
        """"""
        Ensure \begin{asy} and \end{asy} are on their own line,
        but there shall be no extra empty lines
        """"""
        #tag = match.group(1)
        #return '\n%s\n' % tag
        #print ""replace""
        return '\\end{asy}\n\\begin{asy}'
    text = LATEX_BETWEEN_ASY_RE.sub(repl_asy, text)'''

    def repl_subsection(match):
        return '\n\\subsection*{%s}\n' % match.group(1)
    text = SUBSECTION_RE.sub(repl_subsection, text)
    text = SUBSECTION_END_RE.sub('', text)

    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        # ""\"" has been escaped already => 2 \
        text = text.replace('\\\\' + key, tex)

    text = post_sub(text, post_substitutions)

    return text


def post_process_latex(result):
    """"""
    Some post-processing hacks of generated LaTeX code to handle linebreaks
    """"""

    WORD_SPLIT_RE = re.compile(r'(\s+|\\newline\s*)')

    def wrap_word(word):
        if word.strip() == r'\newline':
            return word
        return r'\text{%s}' % word

    def repl_text(match):
        text = match.group(1)
        if not text:
            return r'\text{}'
        words = WORD_SPLIT_RE.split(text)
        assert len(words) >= 1
        if len(words) > 1:
            text = """"
            index = 0
            while index < len(words) - 1:
                text += '%s%s\\allowbreak{}' % (wrap_word(
                    words[index]), wrap_word(words[index + 1]))
                index += 2
            text += wrap_word(words[-1])
        else:
            text = r'\text{%s}' % words[0]
        if not text:
            return r'\text{}'
        text = text.replace('><', r'>}\allowbreak\text{<')
        return text

    def repl_out_delim(match):
        return ',\\allowbreak{}'

    def repl_number(match):
        guard = r'\allowbreak{}'
        inter_groups_pre = r'\,\discretionary{\~{}}{\~{}}{}'
        inter_groups_post = r'\discretionary{\~{}}{\~{}}{}'
        number = match.group(1)
        parts = number.split('.')
        if len(number) <= 3:
            return number
        assert 1 <= len(parts) <= 2
        pre_dec = parts[0]
        groups = []
        while pre_dec:
            groups.append(pre_dec[-3:])
            pre_dec = pre_dec[:-3]
        pre_dec = inter_groups_pre.join(reversed(groups))
        if len(parts) == 2:
            post_dec = parts[1]
            groups = []
            while post_dec:
                groups.append(post_dec[:3])
                post_dec = post_dec[3:]
            post_dec = inter_groups_post.join(groups)
            result = pre_dec + '.' + post_dec
        else:
            result = pre_dec
        return guard + result + guard

    def repl_array(match):
        content = match.group(1)
        lines = content.split('\\\\')
        content = ''.join(r'\begin{dmath*}%s\end{dmath*}' %
                          line for line in lines if line.strip())
        return r'\begin{testresultlist}%s\end{testresultlist}' % content

    def repl_out(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LATEX_TESTOUT_DELIM_RE.sub(repl_out_delim, content)
        content = NUMBER_RE.sub(repl_number, content)
        content = content.replace(r'\left[', r'\left[\allowbreak{}')
        return '\\begin{%s}%s\\end{%s}' % (tag, content, tag)

    def repl_inline_end(match):
        "" Prevent linebreaks between inline code and sentence delimeters ""

        code = match.group('all')
        if code[-2] == '}':
            code = code[:-2] + code[-1] + code[-2]
        return r'\mbox{%s}' % code

    def repl_console(match):
        code = match.group(1)
        code = code.replace('/', r'/\allowbreak{}')
        return r'\console{%s}' % code

    def repl_nonasy(match):
        result = match.group(1)
        result = LATEX_TEXT_RE.sub(repl_text, result)
        result = LATEX_TESTOUT_RE.sub(repl_out, result)
        result = LATEX_ARRAY_RE.sub(repl_array, result)
        result = LATEX_INLINE_END_RE.sub(repl_inline_end, result)
        result = LATEX_CONSOLE_RE.sub(repl_console, result)
        return result

    return OUTSIDE_ASY_RE.sub(repl_nonasy, result)

POST_SUBSTITUTION_TAG = '_POST_SUBSTITUTION%d_'


def pre_sub(re, text, repl_func):
    post_substitutions = []

    def repl_pre(match):
        repl = repl_func(match)
        index = len(post_substitutions)
        post_substitutions.append(repl)
        return POST_SUBSTITUTION_TAG % index

    text = re.sub(repl_pre, text)

    return text, post_substitutions


def post_sub(text, post_substitutions):
    for index, sub in enumerate(post_substitutions):
        text = text.replace(POST_SUBSTITUTION_TAG % index, sub)
    return text


def escape_html(text, verbatim_mode=False, counters=None, single_line=False):
    def repl_python(match):
        return r""""""<pre><![CDATA[
%s
]]></pre>"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    if not verbatim_mode:
        def repl_quotation(match):
            return r""&ldquo;%s&rdquo;"" % match.group(1)
        text = QUOTATIONS_RE.sub(repl_quotation, text)

    if counters is None:
        counters = {}

    text = text.replace('""', '&quot;')
    if not verbatim_mode:
        def repl_latex(match):
            return '%s<var>%s</var>%s' % (
                match.group(1), match.group(2), match.group(3))

        text = LATEX_RE.sub(repl_latex, text)

        def repl_mathics(match):
            text = match.group(1)
            text = text.replace(""\\'"", ""'"")
            text = text.replace(' ', '&nbsp;')
            if text:
                return ""<code>%s</code>"" % text
            else:
                return ""'""

        def repl_allowed(match):
            content = _replace_all(match.group(1), [
                ('&ldquo;', '""'), ('&rdquo;', '""'), ('&quot;', '""')])
            return '<%s>' % content

        text = MATHICS_RE.sub(repl_mathics, text)
        for allowed in ALLOWED_TAGS:
            text = ALLOWED_TAGS_RE[allowed].sub(repl_allowed, text)
            text = text.replace('&lt;/%s&gt;' % allowed, '</%s>' % allowed)

        def repl_dl(match):
            text = match.group(1)
            text = DL_ITEM_RE.sub(
                lambda m: '<%(tag)s>%(content)s</%(tag)s>\n' % m.groupdict(),
                text)
            return '<dl>%s</dl>' % text

        text = DL_RE.sub(repl_dl, text)

        def repl_list(match):
            tag = match.group('tag')
            content = match.group('content')
            content = LIST_ITEM_RE.sub(
                lambda m: '<li>%s</li>' % m.group(1), content)
            return '<%s>%s</%s>' % (tag, content, tag)

        text = LIST_RE.sub(repl_list, text)

        def repl_hypertext(match):
            tag = match.group('tag')
            content = match.group('content')
            if tag == 'em':
                return r'<em>%s</em>' % content
            elif tag == 'url':
                return r'<a href=""%s"">%s</a>' % (content, content)

        text = HYPERTEXT_RE.sub(repl_hypertext, text)

        def repl_console(match):
            tag = match.group('tag')
            content = match.group('content')
            tag = 'div' if tag == 'console' else 'span'
            content = content.strip()
            pre = post = ''

            # gets replaced for <br /> later by DocText.html()
            content = content.replace('\n', '<br>')

            return r'<%s class=""console"">%s%s%s</%s>' % (
                tag, pre, content, post, tag)

        text = CONSOLE_RE.sub(repl_console, text)

        def repl_img(match):
            src = match.group('src')
            title = match.group('title')
            return (r'<a href=""/media/doc/%(src)s.pdf"">'
                    r'<img src=""/media/doc/%(src)s.png"" title=""%(title)s"" />'
                    r'</a>') % {'src': src, 'title': title}
        text = IMG_RE.sub(repl_img, text)

        def repl_ref(match):
            # TODO: this is not an optimal solution - maybe we need figure
            # numbers in the XML doc as well?
            return r'the following figure'
        text = REF_RE.sub(repl_ref, text)

        def repl_subsection(match):
            return '\n<h2>%s</h2>\n' % match.group(1)
        text = SUBSECTION_RE.sub(repl_subsection, text)
        text = SUBSECTION_END_RE.sub('', text)

        text = text.replace(""\\'"", ""'"")
    else:
        text = text.replace(' ', '&nbsp;')
        text = '<code>%s</code>' % text
    text = text.replace(""'"", '&#39;')
    text = text.replace('---', '&mdash;')
    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        text = text.replace('\\' + key, xml)

    if not single_line:
        text = linebreaks(text)
        text = text.replace('<br />', '\n').replace('<br>', '<br />')

    text = post_sub(text, post_substitutions)

    text = text.replace('<p><pre>', '<pre>').replace('</pre></p>', '</pre>')

    return text


class Tests(object):
    def __init__(self, part, chapter, section, tests):
        self.part, self.chapter = part, chapter
        self.section, self.tests = section, tests


class DocElement(object):
    def href(self, ajax=False):
        if ajax:
            return ""javascript:loadDoc('%s')"" % self.get_url()
        else:
            return ""/doc%s"" % self.get_url()

    def get_prev(self):
        return self.get_prev_next()[0]

    def get_next(self):
        return self.get_prev_next()[1]

    def get_collection(self):
        return []

    def get_prev_next(self):
        collection = self.get_collection()
        index = collection.index(self)
        prev = collection[index - 1] if index > 0 else None
        next = collection[index + 1] if index < len(collection) - 1 else None
        return prev, next

    def get_title_html(self):
        return mark_safe(escape_html(self.title, single_line=True))


class Documentation(DocElement):

    def __str__(self):
        return '\n\n\n'.join(str(part) for part in self.parts)

    def get_tests(self):
        for part in self.parts:
            for chapter in part.chapters:
                tests = chapter.doc.get_tests()
                if tests:
                    yield Tests(part.title, chapter.title, '', tests)
                for section in chapter.sections:
                    if section.installed:
                        tests = section.doc.get_tests()
                        if tests:
                            yield Tests(
                                part.title, chapter.title, section.title, tests)

    def get_part(self, part_slug):
        return self.parts_by_slug.get(part_slug)

    def get_chapter(self, part_slug, chapter_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            return part.chapters_by_slug.get(chapter_slug)
        return None
        """"""for part in self.parts:
            if part.slug == part_slug:
                for chapter in self:
                    pass""""""

    def get_section(self, part_slug, chapter_slug, section_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            chapter = part.chapters_by_slug.get(chapter_slug)
            if chapter:
                return chapter.sections_by_slug.get(section_slug)
        return None

    def latex(self, output):
        parts = []
        appendix = False
        for part in self.parts:
            text = part.latex(output)
            if part.is_appendix and not appendix:
                appendix = True
                text = '\n\\appendix\n' + text
            parts.append(text)
        result = '\n\n'.join(parts)
        result = post_process_latex(result)
        return result

    def get_url(self):
        return '/'

    def search(self, query):
        query = query.strip()
        query_parts = [q.strip().lower() for q in query.split()]

        def matches(text):
            text = text.lower()
            return all(q in text for q in query_parts)

        result = []
        for part in self.parts:
            if matches(part.title):
                result.append((False, part))
            for chapter in part.chapters:
                if matches(chapter.title):
                    result.append((False, chapter))
                for section in chapter.sections:
                    if matches(section.title):
                        result.append((section.title == query, section))
                    elif query == section.operator:
                        result.append((True, section))
        return result


class MathicsMainDocumentation(Documentation):
    def __init__(self):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = settings.DOC_DIR
        self.xml_data_file = settings.DOC_XML_DATA
        self.tex_data_file = settings.DOC_TEX_DATA
        self.latex_file = settings.DOC_LATEX_FILE
        self.pymathics_doc_loaded = False
        files = listdir(self.doc_dir)
        files.sort()
        appendix = []

        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        for title, modules, builtins_by_module, start in [(
            ""Reference of built-in symbols"", builtin.modules,
            builtin.builtins_by_module, True)]:     # nopep8
            # (""Reference of optional symbols"", optional.modules,
            #  optional.optional_builtins_by_module, False)]:

            builtin_part = DocPart(self, title, is_reference=start)
            for module in modules:
                title, text = get_module_doc(module)
                chapter = DocChapter(builtin_part, title, Doc(text))
                builtins = builtins_by_module[module.__name__]
                for instance in builtins:
                    installed = True
                    for package in getattr(instance, 'requires', []):
                        try:
                            importlib.import_module(package)
                        except ImportError:
                            installed = False
                            break
                    section = DocSection(
                        chapter, strip_system_prefix(instance.get_name()),
                        instance.__doc__ or '',
                        operator=instance.get_operator(),
                        installed=installed)
                    chapter.sections.append(section)
                builtin_part.chapters.append(chapter)
            self.parts.append(builtin_part)

        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)

    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        # Look the ""Pymathics Modules"" part, and if it does not exist, create it.
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        # For each module, create the documentation object and load the chapters in the pymathics part.
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True


class PyMathicsDocumentation(Documentation):
    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        # Load the module and verifies it is a pymathics module
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        try:
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        except (AttributeError, KeyError, IndexError):
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        # Paths
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        # Load the dictionary of mathics symbols defined in the module
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        # Defines de default first part, in case we are building an independent documentation module.
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        # Builds the automatic documentation
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        # Adds possible appendices
        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)


class DocPart(DocElement):
    def __init__(self, doc, title, is_reference=False):
        self.doc = doc
        self.title = title
        self.slug = slugify(title)
        self.chapters = []
        self.chapters_by_slug = {}
        self.is_reference = is_reference
        self.is_appendix = False
        doc.parts_by_slug[self.slug] = self

    def __str__(self):
        return '%s\n\n%s' % (
            self.title, '\n'.join(str(chapter) for chapter in self.chapters))

    def latex(self, output):
        result = '\n\n\\part{%s}\n\n' % escape_latex(self.title) + (
            '\n\n'.join(chapter.latex(output) for chapter in self.chapters))
        if self.is_reference:
            result = '\n\n\\referencestart' + result
        return result

    def get_url(self):
        return '/%s/' % self.slug

    def get_collection(self):
        return self.doc.parts


class DocChapter(DocElement):
    def __init__(self, part, title, doc=None):
        self.part = part
        self.title = title
        self.slug = slugify(title)
        self.doc = doc
        self.sections = []
        self.sections_by_slug = {}
        part.chapters_by_slug[self.slug] = self

    def __str__(self):
        return '= %s =\n\n%s' % (
            self.title, '\n'.join(str(section) for section in self.sections))

    def latex(self, output):
        intro = self.doc.latex(output).strip()
        if intro:
            short = 'short' if len(intro) < 300 else ''
            intro = '\\begin{chapterintro%s}\n%s\n\n\\end{chapterintro%s}' % (
                short, intro, short)
        return ''.join([
            '\n\n\\chapter{%(title)s}\n\\chapterstart\n\n%(intro)s' % {
                'title': escape_latex(self.title),
                'intro': intro},
            '\\chaptersections\n',
            '\n\n'.join(
                section.latex(output) for section in self.sections),
            '\n\\chapterend\n'])

    def get_url(self):
        return '/%s/%s/' % (self.part.slug, self.slug)

    def get_collection(self):
        return self.part.chapters


class DocSection(DocElement):
    def __init__(self, chapter, title, text, operator=None, installed=True):
        self.chapter = chapter
        self.title = title
        self.slug = slugify(title)
        if text.count(""<dl>"") != text.count(""</dl>""):
            raise ValueError(""Missing opening or closing <dl> tag in ""
                             ""{} documentation"".format(title))
        self.doc = Doc(text)
        self.operator = operator
        self.installed = installed
        chapter.sections_by_slug[self.slug] = self

    def __str__(self):
        return '== %s ==\n%s' % (self.title, self.doc)

    def latex(self, output):
        title = escape_latex(self.title)
        if self.operator:
            title += "" (\\code{%s})"" % escape_latex_code(self.operator)
        index = '\index{%s}' % escape_latex(
            self.title) if self.chapter.part.is_reference else ''
        return (
            '\n\n\\section*{%(title)s}%(index)s\n'
            '\\sectionstart\n\n%(content)s\\sectionend'
            '\\addcontentsline{toc}{section}{%(title)s}') % {
                'title': title,
                'index': index,
                'content': self.doc.latex(output)
            }

    def get_url(self):
        return '/%s/%s/%s/' % (
            self.chapter.part.slug, self.chapter.slug, self.slug)

    def get_collection(self):
        return self.chapter.sections

    def html_data(self):
        indices = set()
        for test in self.doc.items:
            indices.update(test.test_indices())
        result = {}
        for index in indices:
            result[index] = xml_data.get((
                self.chapter.part.title, self.chapter.title, self.title,
                index))
        return result


class Doc(object):
    def __init__(self, doc):
        self.items = []
        # remove commented lines
        doc = filter_comments(doc)
        # pre-substitute Python code because it might contain tests
        doc, post_substitutions = pre_sub(
            PYTHON_RE, doc, lambda m: '<python>%s</python>' % m.group(1))
        # HACK: Artificially construct a last testcase to get the ""intertext""
        # after the last (real) testcase. Ignore the test, of course.
        doc += '\n>> test\n = test'
        testcases = TESTCASE_RE.findall(doc)
        tests = None
        for index in range(len(testcases)):
            testcase = list(testcases[index])
            text = testcase.pop(0).strip()
            if text:
                if tests is not None:
                    self.items.append(tests)
                    tests = None
                text = post_sub(text, post_substitutions)
                self.items.append(DocText(text))
                tests = None
            if index < len(testcases) - 1:
                test = DocTest(index, testcase)
                if tests is None:
                    tests = DocTests()
                if not test.ignore:
                    tests.tests.append(test)
            if tests is not None:
                self.items.append(tests)
                tests = None

    def __str__(self):
        return '\n'.join(str(item) for item in self.items)

    def text(self, detail_level):
        # used for introspection
        # TODO parse XML and pretty print
        # HACK
        item = str(self.items[0])
        item = '\n'.join(line.strip() for line in item.split('\n'))
        item = item.replace('<dl>', '')
        item = item.replace('</dl>', '')
        item = item.replace('<dt>', '  ')
        item = item.replace('</dt>', '')
        item = item.replace('<dd>', '    ')
        item = item.replace('</dd>', '')
        item = '\n'.join(line for line in item.split('\n') if not line.isspace())
        return item

    def get_tests(self):
        tests = []
        for item in self.items:
            tests.extend(item.get_tests())
        return tests

    def latex(self, output):
        return '\n'.join(item.latex(output) for item in self.items
                         if not item.is_private())

    def html(self):
        counters = {}
        return mark_safe('\n'.join(item.html(counters) for item in self.items
                         if not item.is_private()))


class DocText(object):
    def __init__(self, text):
        self.text = text

    def get_tests(self):
        return []

    def is_private(self):
        return False

    def __str__(self):
        return self.text

    def latex(self, output):
        return escape_latex(self.text)

    def html(self, counters=None):
        result = escape_html(self.text, counters=counters)
        return result

    def test_indices(self):
        return []


class DocTests(object):
    def __init__(self):
        self.tests = []

    def get_tests(self):
        return self.tests

    def is_private(self):
        return all(test.private for test in self.tests)

    def __str__(self):
        return '\n'.join(str(test) for test in self.tests)

    def latex(self, output):
        if len(self.tests) == 0:
            return ""\n""

        testLatexStrings = [test.latex(output) for test in self.tests
                       if not test.private]
        testLatexStrings = [t for t in testLatexStrings if len(t)>1]
        if len(testLatexStrings) == 0:
            return ""\n""
        
        return '\\begin{tests}%%\n%s%%\n\\end{tests}' % (
            '%\n'.join(testLatexStrings))

    def html(self, counters=None):
        if len(self.tests) == 0:
            return ""\n""        
        return '<ul class=""tests"">%s</ul>' % (
            '\n'.join('<li>%s</li>' % test.html() for test in self.tests
                      if not test.private))

    def test_indices(self):
        return [test.index for test in self.tests]


class DocTest(object):
    """"""
    DocTest formatting rules:

    #> signifies private test that does not appear as part of the documentation
    X> outputs the docs as normal, but the test is not run
    = compares the result text
    : compares an (error) Message
    | signifies Print outpt
    """"""
    def __init__(self, index, testcase):
        self.index = index
        self.result = None
        self.outs = []
        # Private test cases are executed, but NOT shown as part of the docs
        self.private = testcase[0] == '#'
        # Ignored test cases are NOT executed, but shown as part of the docs
        if testcase[0] == 'X':
            self.ignore = True
            # substitute '>' again so we get the correct formatting
            testcase[0] = '>'
        else:
            self.ignore = False

        self.test = testcase[1].strip()

        self.key = None
        outs = testcase[2].splitlines()
        for line in outs:
            line = line.strip()
            if line:
                if line.startswith('.'):
                    text = line[1:]
                    if text.startswith(' '):
                        text = text[1:]
                    text = '\n' + text
                    if self.result is not None:
                        self.result += text
                    elif self.outs:
                        self.outs[-1] += text
                    continue

                match = TESTCASE_OUT_RE.match(line)
                symbol, text = match.group(1), match.group(2)
                text = text.strip()
                if symbol == '=':
                    self.result = text
                elif text:
                    if symbol == ':':
                        out = Message('', '', text)
                    elif symbol == '|':
                        out = Print(text)
                    self.outs.append(out)

    def __str__(self):
        return self.test

    def latex(self, output):
        text = ''
        text += ""\\begin{testcase}\n""
        text += ""\\test{%s}\n"" % escape_latex_code(self.test)
        if self.key is None:
            return ''
        results = output[self.key]['results']
        for result in results:
            for out in result['out']:
                kind = 'message' if out['message'] else 'print'
                text += ""\\begin{test%s}%s\\end{test%s}"" % (
                    kind, escape_latex_output(out['text']), kind)
            if result['result']:  # is not None and result['result'].strip():
                text += ""\\begin{testresult}%s\\end{testresult}"" % result[
                    'result']
        text += ""\\end{testcase}""
        return text

    def html(self):
        result = '<div class=""test""><span class=""move""></span>'
        result += '<ul class=""test"" id=""test_%d"">' % self.index
        result += '<li class=""test"">%s</li>' % escape_html(self.test, True)
        result += '</ul>'
        result += '</div>'
        return result
","#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import re
from os import listdir, path
import pickle
import importlib

from django.utils.html import escape, linebreaks
from django.utils.safestring import mark_safe

from mathics import settings

from mathics import builtin
from mathics.builtin import get_module_doc
from mathics.core.evaluation import Message, Print
from mathics.doc.utils import slugify

CHAPTER_RE = re.compile('(?s)<chapter title=""(.*?)"">(.*?)</chapter>')
SECTION_RE = re.compile('(?s)(.*?)<section title=""(.*?)"">(.*?)</section>')
SUBSECTION_RE = re.compile('(?s)<subsection title=""(.*?)"">')
SUBSECTION_END_RE = re.compile('</subsection>')

TESTCASE_RE = re.compile(r'''(?mx)^
    ((?:.|\n)*?)
    ^\s*(>|\#)>[ ](.*)
    ((?:\n\s*(?:[:|=.][ ]|\.).*)*)
''')
TESTCASE_OUT_RE = re.compile(r'^\s*([:|=])(.*)$')

MATHICS_RE = re.compile(r""(?<!\\)\'(.*?)(?<!\\)\'"")

# preserve space before and after inline code variables
LATEX_RE = re.compile(r""(\s?)\$(\w+?)\$(\s?)"")

DL_RE = re.compile(r""(?s)<dl>(.*?)</dl>"")
DL_ITEM_RE = re.compile(
    r""(?s)<(?P<tag>d[td])>(?P<content>.*?)(?:</(?P=tag)>|)\s*(?:(?=<d[td]>)|$)"")
LIST_RE = re.compile(r""(?s)<(?P<tag>ul|ol)>(?P<content>.*?)</(?P=tag)>"")
LIST_ITEM_RE = re.compile(r""(?s)<li>(.*?)(?:</li>|(?=<li>)|$)"")
CONSOLE_RE = re.compile(
    r""(?s)<(?P<tag>con|console)>(?P<content>.*?)</(?P=tag)>"")
IMG_RE = re.compile(
    r'<img src=""(?P<src>.*?)"" title=""(?P<title>.*?)"" label=""(?P<label>.*?)"">')
REF_RE = re.compile(r'<ref label=""(?P<label>.*?)"">')
PYTHON_RE = re.compile(r'(?s)<python>(.*?)</python>')
LATEX_CHAR_RE = re.compile(r""(?<!\\)(\^)"")

QUOTATIONS_RE = re.compile(r'\""([\w\s,]*?)\""')
HYPERTEXT_RE = re.compile(r""(?s)<(?P<tag>em|url)>(?P<content>.*?)</(?P=tag)>"")

OUTSIDE_ASY_RE = re.compile(r""(?s)((?:^|\\end\{asy\}).*?(?:$|\\begin\{asy\}))"")
LATEX_TEXT_RE = re.compile(
    r""(?s)\\text\{([^{}]*?(?:[^{}]*?\{[^{}]*?(?:[^{}]*?\{[^{}]*?\}[^{}]*?)*?""
    r""[^{}]*?\}[^{}]*?)*?[^{}]*?)\}"")
LATEX_TESTOUT_RE = re.compile(
    r""(?s)\\begin\{(?P<tag>testmessage|testprint|testresult)\}""
    r""(?P<content>.*?)\\end\{(?P=tag)\}"")
LATEX_TESTOUT_DELIM_RE = re.compile(r',')
NUMBER_RE = re.compile(r'(\d*(?<!\.)\.\d+|\d+\.(?!\.)\d*|\d+)')
LATEX_ARRAY_RE = re.compile(
    r'(?s)\\begin\{testresult\}\\begin\{array\}\{l\}(.*?)'
    r'\\end\{array\}\\end\{testresult\}')
LATEX_INLINE_END_RE = re.compile(r""(?s)(?P<all>\\lstinline'[^']*?'\}?[.,;:])"")
LATEX_CONSOLE_RE = re.compile(r""\\console\{(.*?)\}"")

ALLOWED_TAGS = ('dl', 'dd', 'dt', 'em', 'url', 'ul',
                'ol', 'li', 'con', 'console', 'img', 'ref', 'subsection')
ALLOWED_TAGS_RE = dict((allowed, re.compile(
    '&lt;(%s.*?)&gt;' % allowed)) for allowed in ALLOWED_TAGS)

SPECIAL_COMMANDS = {
    'LaTeX': (r'<em>LaTeX</em>', r'\LaTeX{}'),
    'Mathematica': (r'<em>Mathematica</em>&reg;',
                    r'\emph{Mathematica}\textregistered{}'),
    'Mathics': (r'<em>Mathics</em>', r'\emph{Mathics}'),
    'Sage': (r'<em>Sage</em>', r'\emph{Sage}'),
    'Wolfram': (r'<em>Wolfram</em>', r'\emph{Wolfram}'),

    'skip': (r'<br /><br />', r'\bigskip'),
}

try:
    with open(settings.DOC_XML_DATA, 'rb') as xml_data_file:
        xml_data = pickle.load(xml_data_file)
except IOError:
    xml_data = {}


def filter_comments(doc):
    return '\n'.join(line for line in doc.splitlines()
                     if not line.lstrip().startswith('##'))


def strip_system_prefix(name):
    if name.startswith('System`'):
        stripped_name = name[len('System`'):]
        # don't return Private`sym for System`Private`sym
        if '`' not in stripped_name:
            return stripped_name
    return name


def get_latex_escape_char(text):
    for escape_char in (""'"", '~', '@'):
        if escape_char not in text:
            return escape_char
    raise ValueError


def _replace_all(text, pairs):
    for (i, j) in pairs:
        text = text.replace(i, j)
    return text


def escape_latex_output(text):
    "" Escape Mathics output ""

    text = _replace_all(text, [('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
                               ('~', '\\~'), ('&', '\\&'), ('%', '\\%'),
                               ('$', r'\$'), ('_', '\\_')])
    return text


def escape_latex_code(text):
    "" Escape verbatim Mathics input ""

    text = escape_latex_output(text)
    escape_char = get_latex_escape_char(text)
    return '\\lstinline%s%s%s' % (escape_char, text, escape_char)


def escape_latex(text):
    "" Escape documentation text ""

    def repl_python(match):
        return r""""""\begin{lstlisting}[style=python]
%s
\end{lstlisting}"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = _replace_all(text, [
        ('\\', '\\\\'), ('{', '\\{'), ('}', '\\}'),
        ('~', '\\~{ }'), ('&', '\\&'), ('%', '\\%'), ('#','\\#')
    ])

    def repl(match):
        text = match.group(1)
        if text:
            text = _replace_all(text, [(""\\'"", ""'""), ('^', '\\^')])
            escape_char = get_latex_escape_char(text)
            text = LATEX_RE.sub(
                lambda m: ""%s%s\\codevar{\\textit{%s}}%s\\lstinline%s"" % (
                    escape_char, m.group(1), m.group(2), m.group(3),
                    escape_char),
                text)
            if text.startswith(' '):
                text = r'\ ' + text[1:]
            if text.endswith(' '):
                text = text[:-1] + r'\ '
            return ""\\code{\\lstinline%s%s%s}"" % (
                escape_char, text, escape_char)
        else:
            # treat double '' literaly
            return ""''""

    text = MATHICS_RE.sub(repl, text)

    text = LATEX_RE.sub(lambda m: '%s\\textit{%s}%s' % (
        m.group(1), m.group(2), m.group(3)), text)

    text = text.replace(""\\\\'"", ""'"")

    def repl_dl(match):
        text = match.group(1)
        text = DL_ITEM_RE.sub(lambda m: '\\%(tag)s{%(content)s}\n' %
                              m.groupdict(), text)
        return '\\begin{definitions}%s\\end{definitions}' % text
    text = DL_RE.sub(repl_dl, text)

    def repl_list(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LIST_ITEM_RE.sub(
            lambda m: '\\item %s\n' % m.group(1), content)
        env = 'itemize' if tag == 'ul' else 'enumerate'
        return '\\begin{%s}%s\\end{%s}' % (env, content, env)
    text = LIST_RE.sub(repl_list, text)

    text = _replace_all(text, [
        ('$', r'\$'), ('\u03c0', r'$\pi$'), ('≥', r'$\ge$'), ('≤', r'$\le$'),
        ('≠', r'$\ne$'),
        ('ç',r'\c{c}'),('é',r'\'e'),('ê',r'\^e'),('ñ',r'\~n'),
         ('∫',r'\int'),('',r'd'),   ])

    def repl_char(match):
        char = match.group(1)
        return {
            '^': '$^\wedge$',
        }[char]
    text = LATEX_CHAR_RE.sub(repl_char, text)

    def repl_img(match):
        src = match.group('src')
        title = match.group('title')
        label = match.group('label')
        return r""""""\begin{figure*}[htp]
\centering
\includegraphics[width=\textwidth]{images/%(src)s}
\caption{%(title)s}
\label{%(label)s}
\end{figure*}"""""" % {
            'src': src,
            'title': title,
            'label': label,
        }
    text = IMG_RE.sub(repl_img, text)

    def repl_ref(match):
        return r'figure \ref{%s}' % match.group('label')
    text = REF_RE.sub(repl_ref, text)

    def repl_quotation(match):
        return r""``%s''"" % match.group(1)

    def repl_hypertext(match):
        tag = match.group('tag')
        content = match.group('content')
        if tag == 'em':
            return r'\emph{%s}' % content
        elif tag == 'url':
            return '\\url{%s}' % content

    text = QUOTATIONS_RE.sub(repl_quotation, text)
    text = HYPERTEXT_RE.sub(repl_hypertext, text)

    def repl_console(match):
        tag = match.group('tag')
        content = match.group('content')
        content = content.strip()
        content = content.replace(r'\$', '$')
        if tag == 'con':
            return '\\console{%s}' % content
        else:
            return '\\begin{lstlisting}\n%s\n\\end{lstlisting}' % content
    text = CONSOLE_RE.sub(repl_console, text)

    '''def repl_asy(match):
        """"""
        Ensure \begin{asy} and \end{asy} are on their own line,
        but there shall be no extra empty lines
        """"""
        #tag = match.group(1)
        #return '\n%s\n' % tag
        #print ""replace""
        return '\\end{asy}\n\\begin{asy}'
    text = LATEX_BETWEEN_ASY_RE.sub(repl_asy, text)'''

    def repl_subsection(match):
        return '\n\\subsection*{%s}\n' % match.group(1)
    text = SUBSECTION_RE.sub(repl_subsection, text)
    text = SUBSECTION_END_RE.sub('', text)

    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        # ""\"" has been escaped already => 2 \
        text = text.replace('\\\\' + key, tex)

    text = post_sub(text, post_substitutions)

    return text


def post_process_latex(result):
    """"""
    Some post-processing hacks of generated LaTeX code to handle linebreaks
    """"""

    WORD_SPLIT_RE = re.compile(r'(\s+|\\newline\s*)')

    def wrap_word(word):
        if word.strip() == r'\newline':
            return word
        return r'\text{%s}' % word

    def repl_text(match):
        text = match.group(1)
        if not text:
            return r'\text{}'
        words = WORD_SPLIT_RE.split(text)
        assert len(words) >= 1
        if len(words) > 1:
            text = """"
            index = 0
            while index < len(words) - 1:
                text += '%s%s\\allowbreak{}' % (wrap_word(
                    words[index]), wrap_word(words[index + 1]))
                index += 2
            text += wrap_word(words[-1])
        else:
            text = r'\text{%s}' % words[0]
        if not text:
            return r'\text{}'
        text = text.replace('><', r'>}\allowbreak\text{<')
        return text

    def repl_out_delim(match):
        return ',\\allowbreak{}'

    def repl_number(match):
        guard = r'\allowbreak{}'
        inter_groups_pre = r'\,\discretionary{\~{}}{\~{}}{}'
        inter_groups_post = r'\discretionary{\~{}}{\~{}}{}'
        number = match.group(1)
        parts = number.split('.')
        if len(number) <= 3:
            return number
        assert 1 <= len(parts) <= 2
        pre_dec = parts[0]
        groups = []
        while pre_dec:
            groups.append(pre_dec[-3:])
            pre_dec = pre_dec[:-3]
        pre_dec = inter_groups_pre.join(reversed(groups))
        if len(parts) == 2:
            post_dec = parts[1]
            groups = []
            while post_dec:
                groups.append(post_dec[:3])
                post_dec = post_dec[3:]
            post_dec = inter_groups_post.join(groups)
            result = pre_dec + '.' + post_dec
        else:
            result = pre_dec
        return guard + result + guard

    def repl_array(match):
        content = match.group(1)
        lines = content.split('\\\\')
        content = ''.join(r'\begin{dmath*}%s\end{dmath*}' %
                          line for line in lines if line.strip())
        return r'\begin{testresultlist}%s\end{testresultlist}' % content

    def repl_out(match):
        tag = match.group('tag')
        content = match.group('content')
        content = LATEX_TESTOUT_DELIM_RE.sub(repl_out_delim, content)
        content = NUMBER_RE.sub(repl_number, content)
        content = content.replace(r'\left[', r'\left[\allowbreak{}')
        return '\\begin{%s}%s\\end{%s}' % (tag, content, tag)

    def repl_inline_end(match):
        "" Prevent linebreaks between inline code and sentence delimeters ""

        code = match.group('all')
        if code[-2] == '}':
            code = code[:-2] + code[-1] + code[-2]
        return r'\mbox{%s}' % code

    def repl_console(match):
        code = match.group(1)
        code = code.replace('/', r'/\allowbreak{}')
        return r'\console{%s}' % code

    def repl_nonasy(match):
        result = match.group(1)
        result = LATEX_TEXT_RE.sub(repl_text, result)
        result = LATEX_TESTOUT_RE.sub(repl_out, result)
        result = LATEX_ARRAY_RE.sub(repl_array, result)
        result = LATEX_INLINE_END_RE.sub(repl_inline_end, result)
        result = LATEX_CONSOLE_RE.sub(repl_console, result)
        return result

    return OUTSIDE_ASY_RE.sub(repl_nonasy, result)

POST_SUBSTITUTION_TAG = '_POST_SUBSTITUTION%d_'


def pre_sub(re, text, repl_func):
    post_substitutions = []

    def repl_pre(match):
        repl = repl_func(match)
        index = len(post_substitutions)
        post_substitutions.append(repl)
        return POST_SUBSTITUTION_TAG % index

    text = re.sub(repl_pre, text)

    return text, post_substitutions


def post_sub(text, post_substitutions):
    for index, sub in enumerate(post_substitutions):
        text = text.replace(POST_SUBSTITUTION_TAG % index, sub)
    return text


def escape_html(text, verbatim_mode=False, counters=None, single_line=False):
    def repl_python(match):
        return r""""""<pre><![CDATA[
%s
]]></pre>"""""" % match.group(1).strip()
    text, post_substitutions = pre_sub(PYTHON_RE, text, repl_python)

    text = text.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    if not verbatim_mode:
        def repl_quotation(match):
            return r""&ldquo;%s&rdquo;"" % match.group(1)
        text = QUOTATIONS_RE.sub(repl_quotation, text)

    if counters is None:
        counters = {}

    text = text.replace('""', '&quot;')
    if not verbatim_mode:
        def repl_latex(match):
            return '%s<var>%s</var>%s' % (
                match.group(1), match.group(2), match.group(3))

        text = LATEX_RE.sub(repl_latex, text)

        def repl_mathics(match):
            text = match.group(1)
            text = text.replace(""\\'"", ""'"")
            text = text.replace(' ', '&nbsp;')
            if text:
                return ""<code>%s</code>"" % text
            else:
                return ""'""

        def repl_allowed(match):
            content = _replace_all(match.group(1), [
                ('&ldquo;', '""'), ('&rdquo;', '""'), ('&quot;', '""')])
            return '<%s>' % content

        text = MATHICS_RE.sub(repl_mathics, text)
        for allowed in ALLOWED_TAGS:
            text = ALLOWED_TAGS_RE[allowed].sub(repl_allowed, text)
            text = text.replace('&lt;/%s&gt;' % allowed, '</%s>' % allowed)

        def repl_dl(match):
            text = match.group(1)
            text = DL_ITEM_RE.sub(
                lambda m: '<%(tag)s>%(content)s</%(tag)s>\n' % m.groupdict(),
                text)
            return '<dl>%s</dl>' % text

        text = DL_RE.sub(repl_dl, text)

        def repl_list(match):
            tag = match.group('tag')
            content = match.group('content')
            content = LIST_ITEM_RE.sub(
                lambda m: '<li>%s</li>' % m.group(1), content)
            return '<%s>%s</%s>' % (tag, content, tag)

        text = LIST_RE.sub(repl_list, text)

        def repl_hypertext(match):
            tag = match.group('tag')
            content = match.group('content')
            if tag == 'em':
                return r'<em>%s</em>' % content
            elif tag == 'url':
                return r'<a href=""%s"">%s</a>' % (content, content)

        text = HYPERTEXT_RE.sub(repl_hypertext, text)

        def repl_console(match):
            tag = match.group('tag')
            content = match.group('content')
            tag = 'div' if tag == 'console' else 'span'
            content = content.strip()
            pre = post = ''

            # gets replaced for <br /> later by DocText.html()
            content = content.replace('\n', '<br>')

            return r'<%s class=""console"">%s%s%s</%s>' % (
                tag, pre, content, post, tag)

        text = CONSOLE_RE.sub(repl_console, text)

        def repl_img(match):
            src = match.group('src')
            title = match.group('title')
            return (r'<a href=""/media/doc/%(src)s.pdf"">'
                    r'<img src=""/media/doc/%(src)s.png"" title=""%(title)s"" />'
                    r'</a>') % {'src': src, 'title': title}
        text = IMG_RE.sub(repl_img, text)

        def repl_ref(match):
            # TODO: this is not an optimal solution - maybe we need figure
            # numbers in the XML doc as well?
            return r'the following figure'
        text = REF_RE.sub(repl_ref, text)

        def repl_subsection(match):
            return '\n<h2>%s</h2>\n' % match.group(1)
        text = SUBSECTION_RE.sub(repl_subsection, text)
        text = SUBSECTION_END_RE.sub('', text)

        text = text.replace(""\\'"", ""'"")
    else:
        text = text.replace(' ', '&nbsp;')
        text = '<code>%s</code>' % text
    text = text.replace(""'"", '&#39;')
    text = text.replace('---', '&mdash;')
    for key, (xml, tex) in SPECIAL_COMMANDS.items():
        text = text.replace('\\' + key, xml)

    if not single_line:
        text = linebreaks(text)
        text = text.replace('<br />', '\n').replace('<br>', '<br />')

    text = post_sub(text, post_substitutions)

    text = text.replace('<p><pre>', '<pre>').replace('</pre></p>', '</pre>')

    return text


class Tests(object):
    def __init__(self, part, chapter, section, tests):
        self.part, self.chapter = part, chapter
        self.section, self.tests = section, tests


class DocElement(object):
    def href(self, ajax=False):
        if ajax:
            return ""javascript:loadDoc('%s')"" % self.get_url()
        else:
            return ""/doc%s"" % self.get_url()

    def get_prev(self):
        return self.get_prev_next()[0]

    def get_next(self):
        return self.get_prev_next()[1]

    def get_collection(self):
        return []

    def get_prev_next(self):
        collection = self.get_collection()
        index = collection.index(self)
        prev = collection[index - 1] if index > 0 else None
        next = collection[index + 1] if index < len(collection) - 1 else None
        return prev, next

    def get_title_html(self):
        return mark_safe(escape_html(self.title, single_line=True))


class Documentation(DocElement):

    def __str__(self):
        return '\n\n\n'.join(str(part) for part in self.parts)

    def get_tests(self):
        for part in self.parts:
            for chapter in part.chapters:
                tests = chapter.doc.get_tests()
                if tests:
                    yield Tests(part.title, chapter.title, '', tests)
                for section in chapter.sections:
                    if section.installed:
                        tests = section.doc.get_tests()
                        if tests:
                            yield Tests(
                                part.title, chapter.title, section.title, tests)

    def get_part(self, part_slug):
        return self.parts_by_slug.get(part_slug)

    def get_chapter(self, part_slug, chapter_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            return part.chapters_by_slug.get(chapter_slug)
        return None
        """"""for part in self.parts:
            if part.slug == part_slug:
                for chapter in self:
                    pass""""""

    def get_section(self, part_slug, chapter_slug, section_slug):
        part = self.parts_by_slug.get(part_slug)
        if part:
            chapter = part.chapters_by_slug.get(chapter_slug)
            if chapter:
                return chapter.sections_by_slug.get(section_slug)
        return None

    def latex(self, output):
        parts = []
        appendix = False
        for part in self.parts:
            text = part.latex(output)
            if part.is_appendix and not appendix:
                appendix = True
                text = '\n\\appendix\n' + text
            parts.append(text)
        result = '\n\n'.join(parts)
        result = post_process_latex(result)
        return result

    def get_url(self):
        return '/'

    def search(self, query):
        query = query.strip()
        query_parts = [q.strip().lower() for q in query.split()]

        def matches(text):
            text = text.lower()
            return all(q in text for q in query_parts)

        result = []
        for part in self.parts:
            if matches(part.title):
                result.append((False, part))
            for chapter in part.chapters:
                if matches(chapter.title):
                    result.append((False, chapter))
                for section in chapter.sections:
                    if matches(section.title):
                        result.append((section.title == query, section))
                    elif query == section.operator:
                        result.append((True, section))
        return result


class MathicsMainDocumentation(Documentation):
    def __init__(self):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = settings.DOC_DIR
        self.xml_data_file = settings.DOC_XML_DATA
        self.tex_data_file = settings.DOC_TEX_DATA
        self.latex_file = settings.DOC_LATEX_FILE
        self.pymathics_doc_loaded = False
        files = listdir(self.doc_dir)
        files.sort()
        appendix = []

        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        for title, modules, builtins_by_module, start in [(
            ""Reference of built-in symbols"", builtin.modules,
            builtin.builtins_by_module, True)]:     # nopep8
            # (""Reference of optional symbols"", optional.modules,
            #  optional.optional_builtins_by_module, False)]:

            builtin_part = DocPart(self, title, is_reference=start)
            for module in modules:
                title, text = get_module_doc(module)
                chapter = DocChapter(builtin_part, title, Doc(text))
                builtins = builtins_by_module[module.__name__]
                for instance in builtins:
                    installed = True
                    for package in getattr(instance, 'requires', []):
                        try:
                            importlib.import_module(package)
                        except ImportError:
                            installed = False
                            break
                    section = DocSection(
                        chapter, strip_system_prefix(instance.get_name()),
                        instance.__doc__ or '',
                        operator=instance.get_operator(),
                        installed=installed)
                    chapter.sections.append(section)
                builtin_part.chapters.append(chapter)
            self.parts.append(builtin_part)

        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)

    def load_pymathics_doc(self):
        if self.pymathics_doc_loaded:
            return
        from mathics.settings import default_pymathics_modules
        pymathicspart = None
        # Look the ""Pymathics Modules"" part, and if it does not exist, create it.
        for part in self.parts:
            if part.title == ""Pymathics Modules"":
                pymathicspart = part
        if pymathicspart is None:
            pymathicspart = DocPart(self, ""Pymathics Modules"", is_reference=True)
            self.parts.append(pymathicspart)

        # For each module, create the documentation object and load the chapters in the pymathics part.
        for pymmodule in default_pymathics_modules:
            pymathicsdoc = PyMathicsDocumentation(pymmodule)
            for part in pymathicsdoc.parts:
                for ch in part.chapters:
                    ch.title = f""{pymmodule.name} {part.title} {ch.title}""
                    ch.part = pymathicspart
                    pymathicspart.chapters_by_slug[ch.slug] = ch
                    pymathicspart.chapters.append(ch)

        self.pymathics_doc_loaded = True


class PyMathicsDocumentation(Documentation):
    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        # Load the module and verifies it is a pymathics module
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        if hasattr(self.pymathicsmodule, ""pymathics_version_data""):
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        else:
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        # Paths
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        # Load the dictionary of mathics symbols defined in the module
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        # Defines de default first part, in case we are building an independent documentation module.
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        # Builds the automatic documentation
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        # Adds possible appendices
        for part in appendix:
            self.parts.append(part)

        # set keys of tests
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)


class DocPart(DocElement):
    def __init__(self, doc, title, is_reference=False):
        self.doc = doc
        self.title = title
        self.slug = slugify(title)
        self.chapters = []
        self.chapters_by_slug = {}
        self.is_reference = is_reference
        self.is_appendix = False
        doc.parts_by_slug[self.slug] = self

    def __str__(self):
        return '%s\n\n%s' % (
            self.title, '\n'.join(str(chapter) for chapter in self.chapters))

    def latex(self, output):
        result = '\n\n\\part{%s}\n\n' % escape_latex(self.title) + (
            '\n\n'.join(chapter.latex(output) for chapter in self.chapters))
        if self.is_reference:
            result = '\n\n\\referencestart' + result
        return result

    def get_url(self):
        return '/%s/' % self.slug

    def get_collection(self):
        return self.doc.parts


class DocChapter(DocElement):
    def __init__(self, part, title, doc=None):
        self.part = part
        self.title = title
        self.slug = slugify(title)
        self.doc = doc
        self.sections = []
        self.sections_by_slug = {}
        part.chapters_by_slug[self.slug] = self

    def __str__(self):
        return '= %s =\n\n%s' % (
            self.title, '\n'.join(str(section) for section in self.sections))

    def latex(self, output):
        intro = self.doc.latex(output).strip()
        if intro:
            short = 'short' if len(intro) < 300 else ''
            intro = '\\begin{chapterintro%s}\n%s\n\n\\end{chapterintro%s}' % (
                short, intro, short)
        return ''.join([
            '\n\n\\chapter{%(title)s}\n\\chapterstart\n\n%(intro)s' % {
                'title': escape_latex(self.title),
                'intro': intro},
            '\\chaptersections\n',
            '\n\n'.join(
                section.latex(output) for section in self.sections),
            '\n\\chapterend\n'])

    def get_url(self):
        return '/%s/%s/' % (self.part.slug, self.slug)

    def get_collection(self):
        return self.part.chapters


class DocSection(DocElement):
    def __init__(self, chapter, title, text, operator=None, installed=True):
        self.chapter = chapter
        self.title = title
        self.slug = slugify(title)
        if text.count(""<dl>"") != text.count(""</dl>""):
            raise ValueError(""Missing opening or closing <dl> tag in ""
                             ""{} documentation"".format(title))
        self.doc = Doc(text)
        self.operator = operator
        self.installed = installed
        chapter.sections_by_slug[self.slug] = self

    def __str__(self):
        return '== %s ==\n%s' % (self.title, self.doc)

    def latex(self, output):
        title = escape_latex(self.title)
        if self.operator:
            title += "" (\\code{%s})"" % escape_latex_code(self.operator)
        index = '\index{%s}' % escape_latex(
            self.title) if self.chapter.part.is_reference else ''
        return (
            '\n\n\\section*{%(title)s}%(index)s\n'
            '\\sectionstart\n\n%(content)s\\sectionend'
            '\\addcontentsline{toc}{section}{%(title)s}') % {
                'title': title,
                'index': index,
                'content': self.doc.latex(output)
            }

    def get_url(self):
        return '/%s/%s/%s/' % (
            self.chapter.part.slug, self.chapter.slug, self.slug)

    def get_collection(self):
        return self.chapter.sections

    def html_data(self):
        indices = set()
        for test in self.doc.items:
            indices.update(test.test_indices())
        result = {}
        for index in indices:
            result[index] = xml_data.get((
                self.chapter.part.title, self.chapter.title, self.title,
                index))
        return result


class Doc(object):
    def __init__(self, doc):
        self.items = []
        # remove commented lines
        doc = filter_comments(doc)
        # pre-substitute Python code because it might contain tests
        doc, post_substitutions = pre_sub(
            PYTHON_RE, doc, lambda m: '<python>%s</python>' % m.group(1))
        # HACK: Artificially construct a last testcase to get the ""intertext""
        # after the last (real) testcase. Ignore the test, of course.
        doc += '\n>> test\n = test'
        testcases = TESTCASE_RE.findall(doc)
        tests = None
        for index in range(len(testcases)):
            testcase = list(testcases[index])
            text = testcase.pop(0).strip()
            if text:
                if tests is not None:
                    self.items.append(tests)
                    tests = None
                text = post_sub(text, post_substitutions)
                self.items.append(DocText(text))
                tests = None
            if index < len(testcases) - 1:
                test = DocTest(index, testcase)
                if tests is None:
                    tests = DocTests()
                if not test.ignore:
                    tests.tests.append(test)
            if tests is not None:
                self.items.append(tests)
                tests = None

    def __str__(self):
        return '\n'.join(str(item) for item in self.items)

    def text(self, detail_level):
        # used for introspection
        # TODO parse XML and pretty print
        # HACK
        item = str(self.items[0])
        item = '\n'.join(line.strip() for line in item.split('\n'))
        item = item.replace('<dl>', '')
        item = item.replace('</dl>', '')
        item = item.replace('<dt>', '  ')
        item = item.replace('</dt>', '')
        item = item.replace('<dd>', '    ')
        item = item.replace('</dd>', '')
        item = '\n'.join(line for line in item.split('\n') if not line.isspace())
        return item

    def get_tests(self):
        tests = []
        for item in self.items:
            tests.extend(item.get_tests())
        return tests

    def latex(self, output):
        return '\n'.join(item.latex(output) for item in self.items
                         if not item.is_private())

    def html(self):
        counters = {}
        return mark_safe('\n'.join(item.html(counters) for item in self.items
                         if not item.is_private()))


class DocText(object):
    def __init__(self, text):
        self.text = text

    def get_tests(self):
        return []

    def is_private(self):
        return False

    def __str__(self):
        return self.text

    def latex(self, output):
        return escape_latex(self.text)

    def html(self, counters=None):
        result = escape_html(self.text, counters=counters)
        return result

    def test_indices(self):
        return []


class DocTests(object):
    def __init__(self):
        self.tests = []

    def get_tests(self):
        return self.tests

    def is_private(self):
        return all(test.private for test in self.tests)

    def __str__(self):
        return '\n'.join(str(test) for test in self.tests)

    def latex(self, output):
        if len(self.tests) == 0:
            return ""\n""

        testLatexStrings = [test.latex(output) for test in self.tests
                       if not test.private]
        testLatexStrings = [t for t in testLatexStrings if len(t)>1]
        if len(testLatexStrings) == 0:
            return ""\n""
        
        return '\\begin{tests}%%\n%s%%\n\\end{tests}' % (
            '%\n'.join(testLatexStrings))

    def html(self, counters=None):
        if len(self.tests) == 0:
            return ""\n""        
        return '<ul class=""tests"">%s</ul>' % (
            '\n'.join('<li>%s</li>' % test.html() for test in self.tests
                      if not test.private))

    def test_indices(self):
        return [test.index for test in self.tests]


class DocTest(object):
    """"""
    DocTest formatting rules:

    #> signifies private test that does not appear as part of the documentation
    X> outputs the docs as normal, but the test is not run
    = compares the result text
    : compares an (error) Message
    | signifies Print outpt
    """"""
    def __init__(self, index, testcase):
        self.index = index
        self.result = None
        self.outs = []
        # Private test cases are executed, but NOT shown as part of the docs
        self.private = testcase[0] == '#'
        # Ignored test cases are NOT executed, but shown as part of the docs
        if testcase[0] == 'X':
            self.ignore = True
            # substitute '>' again so we get the correct formatting
            testcase[0] = '>'
        else:
            self.ignore = False

        self.test = testcase[1].strip()

        self.key = None
        outs = testcase[2].splitlines()
        for line in outs:
            line = line.strip()
            if line:
                if line.startswith('.'):
                    text = line[1:]
                    if text.startswith(' '):
                        text = text[1:]
                    text = '\n' + text
                    if self.result is not None:
                        self.result += text
                    elif self.outs:
                        self.outs[-1] += text
                    continue

                match = TESTCASE_OUT_RE.match(line)
                symbol, text = match.group(1), match.group(2)
                text = text.strip()
                if symbol == '=':
                    self.result = text
                elif text:
                    if symbol == ':':
                        out = Message('', '', text)
                    elif symbol == '|':
                        out = Print(text)
                    self.outs.append(out)

    def __str__(self):
        return self.test

    def latex(self, output):
        text = ''
        text += ""\\begin{testcase}\n""
        text += ""\\test{%s}\n"" % escape_latex_code(self.test)
        if self.key is None:
            return ''
        results = output[self.key]['results']
        for result in results:
            for out in result['out']:
                kind = 'message' if out['message'] else 'print'
                text += ""\\begin{test%s}%s\\end{test%s}"" % (
                    kind, escape_latex_output(out['text']), kind)
            if result['result']:  # is not None and result['result'].strip():
                text += ""\\begin{testresult}%s\\end{testresult}"" % result[
                    'result']
        text += ""\\end{testcase}""
        return text

    def html(self):
        result = '<div class=""test""><span class=""move""></span>'
        result += '<ul class=""test"" id=""test_%d"">' % self.index
        result += '<li class=""test"">%s</li>' % escape_html(self.test, True)
        result += '</ul>'
        result += '</div>'
        return result
",PyMathicsDocumentation.__init__,https://github.com/mathics/Mathics/issues/906,"[{'piece_type': 'error message', 'piece_content': '$ mathicsserver\nwarning: database file /home/pablo/.local/var/mathics/mathics.sqlite not found\n\nMigrating database /home/pablo/.local/var/mathics/mathics.sqlite\nTraceback (most recent call last):\nFile ""/home/pablo/Documents/Mathics/mathics/manage.py"", line 13, in <module>\nexecute_from_command_line(sys.argv)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 381, in execute_from_command_line\nutility.execute()\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 375, in execute\nself.fetch_command(subcommand).run_from_argv(self.argv)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 323, in run_from_argv\nself.execute(*args, **cmd_options)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 361, in execute\nself.check()\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 390, in check\ninclude_deployment_checks=include_deployment_checks,\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/commands/migrate.py"", line 65, in _run_checks\nissues.extend(super()._run_checks(**kwargs))\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 377, in _run_checks\nreturn checks.run_checks(**kwargs)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/registry.py"", line 72, in run_checks\nnew_errors = check(app_configs=app_configs)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 40, in check_url_namespaces_unique\nall_namespaces = _load_all_namespaces(resolver)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 57, in _load_all_namespaces\nurl_patterns = getattr(resolver, \'url_patterns\', [])\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__\nres = instance.__dict__[self.name] = self.func(instance)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 571, in url_patterns\npatterns = getattr(self.urlconf_module, ""urlpatterns"", self.urlconf_module)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__\nres = instance.__dict__[self.name] = self.func(instance)\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 564, in urlconf_module\nreturn import_module(self.urlconf_name)\nFile ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module\nreturn _bootstrap._gcd_import(name[level:], package, level)\nFile ""<frozen importlib._bootstrap>"", line 994, in _gcd_import\nFile ""<frozen importlib._bootstrap>"", line 971, in _find_and_load\nFile ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked\nFile ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked\nFile ""<frozen importlib._bootstrap_external>"", line 678, in exec_module\nFile ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed\nFile ""/home/pablo/Documents/Mathics/mathics/urls.py"", line 14, in <module>\nurl(r\'^\', include(\'mathics.web.urls\')),\nFile ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/conf.py"", line 34, in include\nurlconf_module = import_module(urlconf_module)\nFile ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module\nreturn _bootstrap._gcd_import(name[level:], package, level)\nFile ""<frozen importlib._bootstrap>"", line 994, in _gcd_import\nFile ""<frozen importlib._bootstrap>"", line 971, in _find_and_load\nFile ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked\nFile ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked\nFile ""<frozen importlib._bootstrap_external>"", line 678, in exec_module\nFile ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed\nFile ""/home/pablo/Documents/Mathics/mathics/web/urls.py"", line 6, in <module>\nfrom mathics.web.views import query, main_view, login, logout, save, open, get_worksheets, doc_search, doc_part, doc_chapter, doc_section, doc\nFile ""/home/pablo/Documents/Mathics/mathics/web/views.py"", line 28, in <module>\ndocumentation.load_pymathics_doc()\nFile ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 727, in load_pymathics_doc\npymathicsdoc = PyMathicsDocumentation(pymmodule)\nFile ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 765, in __init__\nself.name = self.pymathicsmodule.pymathics_version_data[\'name\']\nKeyError: \'name\'\nerror: failed to create database'}]","$ mathicsserver
warning: database file /home/pablo/.local/var/mathics/mathics.sqlite not found

Migrating database /home/pablo/.local/var/mathics/mathics.sqlite
Traceback (most recent call last):
File ""/home/pablo/Documents/Mathics/mathics/manage.py"", line 13, in <module>
execute_from_command_line(sys.argv)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 381, in execute_from_command_line
utility.execute()
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/__init__.py"", line 375, in execute
self.fetch_command(subcommand).run_from_argv(self.argv)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 323, in run_from_argv
self.execute(*args, **cmd_options)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 361, in execute
self.check()
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 390, in check
include_deployment_checks=include_deployment_checks,
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/commands/migrate.py"", line 65, in _run_checks
issues.extend(super()._run_checks(**kwargs))
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/management/base.py"", line 377, in _run_checks
return checks.run_checks(**kwargs)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/registry.py"", line 72, in run_checks
new_errors = check(app_configs=app_configs)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 40, in check_url_namespaces_unique
all_namespaces = _load_all_namespaces(resolver)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/core/checks/urls.py"", line 57, in _load_all_namespaces
url_patterns = getattr(resolver, 'url_patterns', [])
File ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__
res = instance.__dict__[self.name] = self.func(instance)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 571, in url_patterns
patterns = getattr(self.urlconf_module, ""urlpatterns"", self.urlconf_module)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/utils/functional.py"", line 80, in __get__
res = instance.__dict__[self.name] = self.func(instance)
File ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/resolvers.py"", line 564, in urlconf_module
return import_module(self.urlconf_name)
File ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module
return _bootstrap._gcd_import(name[level:], package, level)
File ""<frozen importlib._bootstrap>"", line 994, in _gcd_import
File ""<frozen importlib._bootstrap>"", line 971, in _find_and_load
File ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked
File ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked
File ""<frozen importlib._bootstrap_external>"", line 678, in exec_module
File ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed
File ""/home/pablo/Documents/Mathics/mathics/urls.py"", line 14, in <module>
url(r'^', include('mathics.web.urls')),
File ""/home/pablo/.local/lib/python3.6/site-packages/django/urls/conf.py"", line 34, in include
urlconf_module = import_module(urlconf_module)
File ""/usr/lib/python3.6/importlib/__init__.py"", line 126, in import_module
return _bootstrap._gcd_import(name[level:], package, level)
File ""<frozen importlib._bootstrap>"", line 994, in _gcd_import
File ""<frozen importlib._bootstrap>"", line 971, in _find_and_load
File ""<frozen importlib._bootstrap>"", line 955, in _find_and_load_unlocked
File ""<frozen importlib._bootstrap>"", line 665, in _load_unlocked
File ""<frozen importlib._bootstrap_external>"", line 678, in exec_module
File ""<frozen importlib._bootstrap>"", line 219, in _call_with_frames_removed
File ""/home/pablo/Documents/Mathics/mathics/web/urls.py"", line 6, in <module>
from mathics.web.views import query, main_view, login, logout, save, open, get_worksheets, doc_search, doc_part, doc_chapter, doc_section, doc
File ""/home/pablo/Documents/Mathics/mathics/web/views.py"", line 28, in <module>
documentation.load_pymathics_doc()
File ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 727, in load_pymathics_doc
pymathicsdoc = PyMathicsDocumentation(pymmodule)
File ""/home/pablo/Documents/Mathics/mathics/doc/doc.py"", line 765, in __init__
self.name = self.pymathicsmodule.pymathics_version_data['name']
KeyError: 'name'
error: failed to create database",KeyError,"    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        if hasattr(self.pymathicsmodule, ""pymathics_version_data""):
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        else:
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        
        for part in appendix:
            self.parts.append(part)

        
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)","    def __init__(self, module=None):
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        self.doc_dir = None
        self.xml_data_file = None
        self.tex_data_file = None
        self.latex_file = None
        self.symbols = {}
        if module is None:
            return

        import importlib

        
        try:
            self.pymathicsmodule = importlib.import_module(module)
        except ImportError:
            print(""Module does not exist"")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        try:
            mainfolder = self.pymathicsmodule.__path__[0]
            self.name = self.pymathicsmodule.pymathics_version_data['name']
            self.version = self.pymathicsmodule.pymathics_version_data['version']
            self.author = self.pymathicsmodule.pymathics_version_data['author']
        except (AttributeError, KeyError, IndexError):
            print(module + "" is not a pymathics module."")
            mainfolder = """"
            self.pymathicsmodule = None
            self.parts = []
            return

        
        self.doc_dir = self.pymathicsmodule.__path__[0] + ""/doc/""
        self.xml_data_file = self.doc_dir + ""xml/data""
        self.tex_data_file = self.doc_dir + ""tex/data""
        self.latex_file = self.doc_dir + ""tex/documentation.tex""

        
        self.symbols = {}
        from mathics.builtin import is_builtin, Builtin
        print(""loading symbols"")
        for name in dir(self.pymathicsmodule):
            var = getattr(self.pymathicsmodule, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(self.pymathicsmodule.__name__)] == self.pymathicsmodule.__name__):     
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    self.symbols[instance.get_name()] = instance
        
        self.title = ""Overview""
        self.parts = []
        self.parts_by_slug = {}
        try:
            files = listdir(self.doc_dir)
            files.sort()
        except FileNotFoundError:
            self.doc_dir = """"
            self.xml_data_file = """"
            self.tex_data_file = """"
            self.latex_file = """"
            files = []
        appendix = []
        for file in files:
            part_title = file[2:]
            if part_title.endswith('.mdoc'):
                part_title = part_title[:-len('.mdoc')]
                part = DocPart(self, part_title)
                text = open(self.doc_dir + file, 'rb').read().decode('utf8')
                text = filter_comments(text)
                chapters = CHAPTER_RE.findall(text)
                for title, text in chapters:
                    chapter = DocChapter(part, title)
                    text += '<section title=""""></section>'
                    sections = SECTION_RE.findall(text)
                    for pre_text, title, text in sections:
                        if not chapter.doc:
                            chapter.doc = Doc(pre_text)
                        if title:
                            section = DocSection(chapter, title, text)
                            chapter.sections.append(section)
                    part.chapters.append(chapter)
                if file[0].isdigit():
                    self.parts.append(part)
                else:
                    part.is_appendix = True
                    appendix.append(part)

        
        builtin_part = DocPart(self, ""Pymathics Modules"", is_reference=True)
        title, text = get_module_doc(self.pymathicsmodule)
        chapter = DocChapter(builtin_part, title, Doc(text))
        for name in self.symbols:
            instance = self.symbols[name]
            installed = True
            for package in getattr(instance, 'requires', []):
                try:
                    importlib.import_module(package)
                except ImportError:
                    installed = False
                    break
            section = DocSection(
                chapter, strip_system_prefix(name),
                instance.__doc__ or '',
                operator=instance.get_operator(),
                installed=installed)
            chapter.sections.append(section)
        builtin_part.chapters.append(chapter)
        self.parts.append(builtin_part)
        
        for part in appendix:
            self.parts.append(part)

        
        for tests in self.get_tests():
            for test in tests.tests:
                test.key = (
                    tests.part, tests.chapter, tests.section, test.index)",[],[],buggy_snippets_files/e25fc0ee1437ed1d1f04be0b911ea080e215816018e4f41e36263c16d5f3e7fd_before_merge.py,buggy_snippets_files/e25fc0ee1437ed1d1f04be0b911ea080e215816018e4f41e36263c16d5f3e7fd_after_merge.py
"    def clear_pymathics_modules(self):
        from mathics.builtin import builtins, builtins_by_module
        # Remove all modules that are not in mathics
        # print(""cleaning pymathics modules"")
        for key in list(builtins_by_module.keys()):
            if not key.startswith(""mathics.""):
                print(f""removing module \""{key}\"" not in mathics."")
                del builtins_by_module[key]
        # print(""reloading symbols from current builtins."")
        for s in self.pymathics:
            if s in self.builtin:
                # If there was a true built-in definition for the symbol, restore it, else, remove he symbol. 
                if self.pymathics[s]:
                    self.builtin[s] = self.pymathics[s]
                    builtins[s] = None
                    for key, val in builtins_by_module.items():
                        for simb in val:
                            if simb.get_name() == s:
                                builtins[s] = simb
                                break
                        if builtins[s] is not None:
                            break
                    if builtins[s] is None:
                        builtins.__delitem__(s)
                else:
                    self.builtin.__delitem__(s)
                    builtins.__delitem__(s)
        self.pymathics = {}
        # print(""everything is clean"")
        return None","    def clear_pymathics_modules(self):
        from mathics.builtin import builtins, builtins_by_module
        # Remove all modules that are not in mathics
        # print(""cleaning pymathics modules"")
        for key in list(builtins_by_module.keys()):
            if key[:8] != ""mathics."":
                print(""removing module "", key, "" not in mathics."")
                del builtins_by_module[key]
        # print(""reloading symbols from current builtins."")
        for s in self.pymathics:
            if s in self.builtin:
                # If there was a true built-in definition for the symbol, restore it, else, remove he symbol. 
                if self.pymathics[s]:
                    self.builtin[s] = self.pymathics[s]
                    builtins[s] = None
                    for key, val in builtins_by_module:
                        for simb in val:
                            if simb.get_name() == s:
                                builtins[s] = simb
                                break
                        if builtins[s] is not None:
                            break
                    if builtins[s] is None:
                        builtins.__delitem__(s)
                else:
                    self.builtin.__delitem__(s)
                    builtins.__delitem__(s)
        self.pymathics = {}
        # print(""everything is clean"")
        return None",mathics/core/definitions.py,"#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pickle

import os
import base64
import re
import bisect

from collections import defaultdict

import typing

from mathics.core.expression import Expression, Symbol, String, fully_qualified_symbol_name, strip_context
from mathics.core.characters import letters, letterlikes


names_wildcards = ""@*""
base_names_pattern = r'((?![0-9])([0-9${0}{1}{2}])+)'.format(letters, letterlikes, names_wildcards)
full_names_pattern = r'(`?{0}(`{0})*)'.format(base_names_pattern)


def get_file_time(file) -> float:
    try:
        return os.stat(file).st_mtime
    except OSError:
        return 0


def valuesname(name) -> str:
    "" 'NValues' -> 'n' ""

    assert name.startswith('System`'), name
    if name == 'System`Messages':
        return 'messages'
    else:
        return name[7:-6].lower()


class PyMathicsLoadException(Exception):
    def __init__(self, module):
        self.name = module + "" is not a valid pymathics module""
        self.module = module

class Definitions(object):
    def __init__(self, add_builtin=False, builtin_filename=None, extension_modules=[]) -> None:
        super(Definitions, self).__init__()
        self.builtin = {}
        self.user = {}
        self.pymathics = {} 
        self.definitions_cache = {}
        self.lookup_cache = {}
        self.proxy = defaultdict(set)
        self.now = 0    # increments whenever something is updated

        if add_builtin:
            from mathics.builtin import modules, contribute
            from mathics.core.evaluation import Evaluation
            from mathics.settings import ROOT_DIR

            loaded = False
            if builtin_filename is not None:
                builtin_dates = [get_file_time(module.__file__)
                                 for module in modules]
                builtin_time = max(builtin_dates)
                if get_file_time(builtin_filename) > builtin_time:
                    builtin_file = open(builtin_filename, 'rb')
                    self.builtin = pickle.load(builtin_file)
                    loaded = True
            if not loaded:
                contribute(self)
                for module in extension_modules:
                    try:
                        loaded_module = self.load_pymathics_module(module, remove_on_quit=False)
                    except PyMathicsLoadException as e:
                        print(e.module + ' is not a valid pymathics module.')
                        continue
                    except ImportError as e:
                        print(e.__repr__())
                        continue
                    #print(module + loaded_module.pymathics_version_data['version'] + ""  by "" + loaded_module.pymathics_version_data['author'])

                if builtin_filename is not None:
                    builtin_file = open(builtin_filename, 'wb')
                    pickle.dump(self.builtin, builtin_file, -1)

            # Load symbols from the autoload folder
            for root, dirs, files in os.walk(os.path.join(ROOT_DIR, 'autoload')):
                for path in [os.path.join(root, f) for f in files if f.endswith('.m')]:
                    Expression('Get', String(path)).evaluate(Evaluation(self))

            # Move any user definitions created by autoloaded files to
            # builtins, and clear out the user definitions list. This
            # means that any autoloaded definitions become shared
            # between users and no longer disappear after a Quit[].
            #
            # Autoloads that accidentally define a name in Global`
            # could cause confusion, so check for this.
            #
            for name in self.user:
                if name.startswith('Global`'):
                    raise ValueError(""autoload defined %s."" % name)
            self.builtin.update(self.user)
            self.user = {}
            self.clear_cache()

    def load_pymathics_module(self, module, remove_on_quit=True):
        '''
        loads Mathics builtin objects and their definitions
        from an external python module
        '''
        import importlib
        from mathics.builtin import is_builtin, builtins, builtins_by_module, Builtin
        loaded_module = importlib.import_module(module)
        builtins_by_module[loaded_module.__name__] = []
        vars = dir(loaded_module)
        newsymbols = {}
        if not ('pymathics_version_data' in vars):
            raise PyMathicsLoadException(module)
        for name in vars:
            var = getattr(loaded_module, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(loaded_module.__name__)] == loaded_module.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    builtins[instance.get_name()] = instance
                    builtins_by_module[loaded_module.__name__].append(instance)
                    newsymbols[instance.get_name()] = instance

        for name in newsymbols:
            if remove_on_quit and name not in self.pymathics:
                self.pymathics[name] = self.builtin.get(name, None)
        self.builtin.update(newsymbols)
        for name, item in newsymbols.items():
            if name != 'System`MakeBoxes':
                item.contribute(self)
        return loaded_module

    def clear_pymathics_modules(self):
        from mathics.builtin import builtins, builtins_by_module
        # Remove all modules that are not in mathics
        # print(""cleaning pymathics modules"")
        for key in list(builtins_by_module.keys()):
            if not key.startswith(""mathics.""):
                print(f""removing module \""{key}\"" not in mathics."")
                del builtins_by_module[key]
        # print(""reloading symbols from current builtins."")
        for s in self.pymathics:
            if s in self.builtin:
                # If there was a true built-in definition for the symbol, restore it, else, remove he symbol. 
                if self.pymathics[s]:
                    self.builtin[s] = self.pymathics[s]
                    builtins[s] = None
                    for key, val in builtins_by_module.items():
                        for simb in val:
                            if simb.get_name() == s:
                                builtins[s] = simb
                                break
                        if builtins[s] is not None:
                            break
                    if builtins[s] is None:
                        builtins.__delitem__(s)
                else:
                    self.builtin.__delitem__(s)
                    builtins.__delitem__(s)
        self.pymathics = {}
        # print(""everything is clean"")
        return None

    def clear_cache(self, name=None):
        # the definitions cache (self.definitions_cache) caches (incomplete and complete) names -> Definition(),
        # e.g. ""xy"" -> d and ""MyContext`xy"" -> d. we need to clear this cache if a Definition() changes (which
        # would happen if a Definition is combined from a builtin and a user definition and some content in the
        # user definition is updated) or if the lookup rules change and we could end up at a completely different
        # Definition.

        # the lookup cache (self.lookup_cache) caches what lookup_name() does. we only need to update this if some
        # change happens that might change the result lookup_name() calculates. we do not need to change it if a
        # Definition() changes.

        # self.proxy keeps track of all the names we cache. if we need to clear the caches for only one name, e.g.
        # 'MySymbol', then we need to be able to look up all the entries that might be related to it, e.g. 'MySymbol',
        # 'A`MySymbol', 'C`A`MySymbol', and so on. proxy identifies symbols using their stripped name and thus might
        # give us symbols in other contexts that are actually not affected. still, this is a safe solution.

        if name is None:
            self.definitions_cache = {}
            self.lookup_cache = {}
            self.proxy = defaultdict(set)
        else:
            definitions_cache = self.definitions_cache
            lookup_cache = self.lookup_cache
            tail = strip_context(name)
            for k in self.proxy.pop(tail, []):
                definitions_cache.pop(k, None)
                lookup_cache.pop(k, None)

    def clear_definitions_cache(self, name) -> None:
        definitions_cache = self.definitions_cache
        tail = strip_context(name)
        for k in self.proxy.pop(tail, []):
            definitions_cache.pop(k, None)

    def last_changed(self, expr) -> int:
        # timestamp for the most recently changed part of a given expression.
        if isinstance(expr, Symbol):
            symb = self.get_definition(expr.get_name(), only_if_exists=True)
            if symb is None:
                # symbol doesn't exist so it was never changed
                return 0
            try:
                return symb.changed
            except AttributeError:
                # must be system symbol
                symb.changed = 0
                return 0
        result = 0
        head = expr.get_head()
        head_changed = self.last_changed(head)
        result = max(result, head_changed)
        for leaf in expr.get_leaves():
            leaf_changed = self.last_changed(leaf)
            result = max(result, leaf_changed)
        return result

    def get_current_context(self):
        # It's crucial to specify System` in this get_ownvalue() call,
        # otherwise we'll end up back in this function and trigger
        # infinite recursion.
        context_rule = self.get_ownvalue('System`$Context')
        context = context_rule.replace.get_string_value()
        assert context is not None, ""$Context somehow set to an invalid value""
        return context

    def get_context_path(self):
        context_path_rule = self.get_ownvalue('System`$ContextPath')
        context_path = context_path_rule.replace
        assert context_path.has_form('System`List', None)
        context_path = [c.get_string_value() for c in context_path.leaves]
        assert not any([c is None for c in context_path])
        return context_path

    def set_current_context(self, context) -> None:
        assert isinstance(context, str)
        self.set_ownvalue('System`$Context', String(context))
        self.clear_cache()

    def set_context_path(self, context_path) -> None:
        assert isinstance(context_path, list)
        assert all([isinstance(c, str) for c in context_path])
        self.set_ownvalue('System`$ContextPath',
                          Expression('System`List',
                                     *[String(c) for c in context_path]))
        self.clear_cache()

    def get_builtin_names(self):
        return set(self.builtin)

    def get_user_names(self):
        return set(self.user)

    def get_pymathics_names(self):
        return set(self.pymathics)

    def get_names(self):
        return self.get_builtin_names() | self.get_pymathics_names() | self.get_user_names()

    def get_accessible_contexts(self):
        ""Return the contexts reachable though $Context or $ContextPath.""
        accessible_ctxts = set(self.get_context_path())
        accessible_ctxts.add(self.get_current_context())
        return accessible_ctxts

    def get_matching_names(self, pattern) -> typing.List[str]:
        """"""
        Return a list of the symbol names matching a string pattern.

        A pattern containing a context mark (of the form
        ""ctx_pattern`short_pattern"") matches symbols whose context and
        short name individually match the two patterns. A pattern
        without a context mark matches symbols accessible through
        $Context and $ContextPath whose short names match the pattern.

        '*' matches any sequence of symbol characters or an empty
        string. '@' matches a non-empty sequence of symbol characters
        which aren't uppercase letters. In the context pattern, both
        '*' and '@' match context marks.
        """"""

        if re.match(full_names_pattern, pattern) is None:
            # The pattern contained characters which weren't allowed
            # in symbols and aren't valid wildcards. Hence, the
            # pattern can't match any symbols.
            return []

        # If we get here, there aren't any regexp metacharacters in
        # the pattern.

        if '`' in pattern:
            ctx_pattern, short_pattern = pattern.rsplit('`', 1)
            ctx_pattern = ((ctx_pattern + '`')
                           .replace('@', '[^A-Z`]+')
                           .replace('*', '.*')
                           .replace('$', r'\$'))
        else:
            short_pattern = pattern
            # start with a group matching the accessible contexts
            ctx_pattern = ""(?:%s)"" % ""|"".join(
                re.escape(c) for c in self.get_accessible_contexts())

        short_pattern = (short_pattern
                         .replace('@', '[^A-Z]+')
                         .replace('*', '[^`]*')
                         .replace('$', r'\$'))
        regex = re.compile('^' + ctx_pattern + short_pattern + '$')

        return [name for name in self.get_names() if regex.match(name)]

    def lookup_name(self, name) -> str:
        """"""
        Determine the full name (including context) for a symbol name.

        - If the name begins with a context mark, it's in the context
          given by $Context.
        - Otherwise, if it contains a context mark, it's already fully
          specified.
        - Otherwise, it doesn't contain a context mark: try $Context,
          then each element of $ContextPath, taking the first existing
          symbol.
        - Otherwise, it's a new symbol in $Context.
        """"""

        cached = self.lookup_cache.get(name, None)
        if cached is not None:
            return cached

        assert isinstance(name, str)

        # Bail out if the name we're being asked to look up is already
        # fully qualified.
        if fully_qualified_symbol_name(name):
            return name

        current_context = self.get_current_context()

        if '`' in name:
            if name.startswith('`'):
                return current_context + name.lstrip('`')
            return name

        with_context = current_context + name
        if not self.have_definition(with_context):
            for ctx in self.get_context_path():
                n = ctx + name
                if self.have_definition(n):
                    return n
        return with_context

    def shorten_name(self, name_with_ctx) -> str:
        if '`' not in name_with_ctx:
            return name_with_ctx

        def in_ctx(name, ctx):
            return name.startswith(ctx) and '`' not in name[len(ctx):]

        if in_ctx(name_with_ctx, self.get_current_context()):
            return name_with_ctx[len(self.get_current_context()):]
        for ctx in self.get_context_path():
            if in_ctx(name_with_ctx, ctx):
                return name_with_ctx[len(ctx):]
        return name_with_ctx

    def have_definition(self, name) -> bool:
        return self.get_definition(name, only_if_exists=True) is not None

    def get_definition(self, name, only_if_exists=False) -> 'Definition':
        definition = self.definitions_cache.get(name, None)
        if definition is not None:
            return definition

        original_name = name
        name = self.lookup_name(name)
        user = self.user.get(name, None)
        builtin = self.builtin.get(name, None)

        if user is None and builtin is None:            
            definition = None
        elif builtin is None:
            definition = user
        elif user is None:
            definition = builtin
        else:
            if user:
                attributes = user.attributes
            elif builtin:                        #  Never happens
                attributes = builtin.attributes
            else:                                #  Never happens
                attributes = set()
            if not user:                         #  Never happens
                user = Definition(name=name)
            if not builtin:                      #  Never happens
                builtin = Definition(name=name)
            options = builtin.options.copy()
            options.update(user.options)
            formatvalues = builtin.formatvalues.copy()
            for form, rules in user.formatvalues.items():
                if form in formatvalues:
                    formatvalues[form].extend(rules)
                else:
                    formatvalues[form] = rules

            definition = Definition(name=name,
                                    ownvalues=user.ownvalues + builtin.ownvalues,
                                    downvalues=user.downvalues + builtin.downvalues,
                                    subvalues=user.subvalues + builtin.subvalues,
                                    upvalues=user.upvalues + builtin.upvalues,
                                    formatvalues=formatvalues,
                                    messages=user.messages + builtin.messages,
                                    attributes=attributes,
                                    options=options,
                                    nvalues=user.nvalues + builtin.nvalues,
                                    defaultvalues=user.defaultvalues +
                                    builtin.defaultvalues,)

        if definition is not None:
            self.proxy[strip_context(original_name)].add(original_name)
            self.definitions_cache[original_name] = definition
            self.lookup_cache[original_name] = name
        elif not only_if_exists:
            definition = Definition(name=name)

        return definition

    def get_attributes(self, name):
        return self.get_definition(name).attributes

    def get_ownvalues(self, name):
        return self.get_definition(name).ownvalues

    def get_downvalues(self, name):
        return self.get_definition(name).downvalues

    def get_subvalues(self, name):
        return self.get_definition(name).subvalues

    def get_upvalues(self, name):
        return self.get_definition(name).upvalues

    def get_formats(self, name, format=''):
        formats = self.get_definition(name).formatvalues
        result = formats.get(format, []) + formats.get('', [])
        result.sort()
        return result

    def get_nvalues(self, name):
        return self.get_definition(name).nvalues

    def get_defaultvalues(self, name):
        return self.get_definition(name).defaultvalues

    def get_value(self, name, pos, pattern, evaluation):
        assert isinstance(name, str)
        assert '`' in name
        rules = self.get_definition(name).get_values_list(valuesname(pos))
        for rule in rules:
            result = rule.apply(pattern, evaluation)
            if result is not None:
                return result

    def get_user_definition(self, name, create=True) -> typing.Optional['Definition']:
        assert not isinstance(name, Symbol)

        existing = self.user.get(name)
        if existing:
            return existing
        else:
            if not create:
                return None
            builtin = self.builtin.get(name)
            if builtin:
                attributes = builtin.attributes
            else:
                attributes = set()
            self.user[name] = Definition(name=name, attributes=attributes)
            self.clear_cache(name)
            return self.user[name]

    def mark_changed(self, definition) -> None:
        self.now += 1
        definition.changed = self.now

    def reset_user_definition(self, name) -> None:
        assert not isinstance(name, Symbol)
        fullname = self.lookup_name(name)
        del self.user[fullname]
        self.clear_cache(fullname)
        # TODO fix changed

    def add_user_definition(self, name, definition) -> None:
        assert not isinstance(name, Symbol)
        self.mark_changed(definition)
        fullname = self.lookup_name(name)
        self.user[fullname] = definition
        self.clear_cache(fullname)

    def set_attribute(self, name, attribute) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.attributes.add(attribute)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def set_attributes(self, name, attributes) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.attributes = set(attributes)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def clear_attribute(self, name, attribute) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        if attribute in definition.attributes:
            definition.attributes.remove(attribute)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_rule(self, name, rule, position=None):
        definition = self.get_user_definition(self.lookup_name(name))
        if position is None:
            result = definition.add_rule(rule)
        else:
            result = definition.add_rule_at(rule, position)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)
        return result

    def add_format(self, name, rule, form='') -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        if isinstance(form, tuple) or isinstance(form, list):
            forms = form
        else:
            forms = [form]
        for form in forms:
            if form not in definition.formatvalues:
                definition.formatvalues[form] = []
            insert_rule(definition.formatvalues[form], rule)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_nvalue(self, name, rule) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.add_rule_at(rule, 'n')
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_default(self, name, rule) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.add_rule_at(rule, 'default')
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_message(self, name, rule) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.add_rule_at(rule, 'messages')
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def set_values(self, name, values, rules) -> None:
        pos = valuesname(values)
        definition = self.get_user_definition(self.lookup_name(name))
        definition.set_values_list(pos, rules)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def get_options(self, name):
        return self.get_definition(self.lookup_name(name)).options

    def reset_user_definitions(self) -> None:
        self.user = {}
        self.clear_cache()
        # TODO changed

    def get_user_definitions(self):
        return base64.encodebytes(pickle.dumps(self.user, protocol=2)).decode('ascii')

    def set_user_definitions(self, definitions) -> None:
        if definitions:
            self.user = pickle.loads(base64.decodebytes(definitions.encode('ascii')))
        else:
            self.user = {}
        self.clear_cache()

    def get_ownvalue(self, name):
        ownvalues = self.get_definition(self.lookup_name(name)).ownvalues
        if ownvalues:
            return ownvalues[0]
        return None

    def set_ownvalue(self, name, value) -> None:
        from .expression import Symbol
        from .rules import Rule

        name = self.lookup_name(name)
        self.add_rule(name, Rule(Symbol(name), value))
        self.clear_cache(name)

    def set_options(self, name, options) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.options = options
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def unset(self, name, expr):
        definition = self.get_user_definition(self.lookup_name(name))
        result = definition.remove_rule(expr)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)
        return result

    def get_config_value(self, name, default=None):
        'Infinity -> None, otherwise returns integer.'
        value = self.get_definition(name).ownvalues
        if value:
            try:
                value = value[0].replace
            except AttributeError:
                return None
            if value.get_name() == 'System`Infinity' or value.has_form('DirectedInfinity', 1):
                return None

            return int(value.get_int_value())
        else:
            return default

    def set_config_value(self, name, new_value) -> None:
        from mathics.core.expression import Integer
        self.set_ownvalue(name, Integer(new_value))

    def set_line_no(self, line_no) -> None:
        self.set_config_value('$Line', line_no)

    def get_line_no(self):
        return self.get_config_value('$Line', 0)

    def get_history_length(self):
        history_length = self.get_config_value('$HistoryLength', 100)
        if history_length is None or history_length > 100:
            history_length = 100
        return history_length


def get_tag_position(pattern, name) -> typing.Optional[str]:
    if pattern.get_name() == name:
        return 'own'
    elif pattern.is_atom():
        return None
    else:
        head_name = pattern.get_head_name()
        if head_name == name:
            return 'down'
        elif head_name == 'System`Condition' and len(pattern.leaves) > 0:
            return get_tag_position(pattern.leaves[0], name)
        elif pattern.get_lookup_name() == name:
            return 'sub'
        else:
            for leaf in pattern.leaves:
                if leaf.get_lookup_name() == name:
                    return 'up'
        return None


def insert_rule(values, rule) -> None:
    for index, existing in enumerate(values):
        if existing.pattern.same(rule.pattern):
            del values[index]
            break
    # use insort_left to guarantee that if equal rules exist, newer rules will
    # get higher precedence by being inserted before them. see DownValues[].
    bisect.insort_left(values, rule)


class Definition(object):
    def __init__(self, name, rules=None, ownvalues=None, downvalues=None,
                 subvalues=None, upvalues=None, formatvalues=None,
                 messages=None, attributes=(), options=None, nvalues=None,
                 defaultvalues=None, builtin=None) -> None:

        super(Definition, self).__init__()
        self.name = name

        if rules is None:
            rules = []
        if ownvalues is None:
            ownvalues = []
        if downvalues is None:
            downvalues = []
        if subvalues is None:
            subvalues = []
        if upvalues is None:
            upvalues = []
        if formatvalues is None:
            formatvalues = {}
        if options is None:
            options = {}
        if nvalues is None:
            nvalues = []
        if defaultvalues is None:
            defaultvalues = []
        if messages is None:
            messages = []

        self.ownvalues = ownvalues
        self.downvalues = downvalues
        self.subvalues = subvalues
        self.upvalues = upvalues
        for rule in rules:
            self.add_rule(rule)
        self.formatvalues = dict((name, list)
                                 for name, list in formatvalues.items())
        self.messages = messages
        self.attributes = set(attributes)
        for a in self.attributes:
            assert '`' in a, ""%s attribute %s has no context"" % (name, a)
        self.options = options
        self.nvalues = nvalues
        self.defaultvalues = defaultvalues
        self.builtin = builtin

    def get_values_list(self, pos):
        assert pos.isalpha()
        if pos == 'messages':
            return self.messages
        else:
            return getattr(self, '%svalues' % pos)

    def set_values_list(self, pos, rules) -> None:
        assert pos.isalpha()
        if pos == 'messages':
            self.messages = rules
        else:
            setattr(self, '%svalues' % pos, rules)

    def add_rule_at(self, rule, position) -> bool:
        values = self.get_values_list(position)
        insert_rule(values, rule)
        return True

    def add_rule(self, rule) -> bool:
        pos = get_tag_position(rule.pattern, self.name)
        if pos:
            return self.add_rule_at(rule, pos)
        return False

    def remove_rule(self, lhs) -> bool:
        position = get_tag_position(lhs, self.name)
        if position:
            values = self.get_values_list(position)
            for index, existing in enumerate(values):
                if existing.pattern.expr.same(lhs):
                    del values[index]
                    return True
        return False

    def __repr__(self):
        s = '<Definition: name: {}, downvalues: {}, formats: {}, attributes: {}>'.format(
            self.name, self.downvalues, self.formatvalues, self.attributes)
        return s.encode('unicode_escape')
","#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pickle

import os
import base64
import re
import bisect

from collections import defaultdict

import typing

from mathics.core.expression import Expression, Symbol, String, fully_qualified_symbol_name, strip_context
from mathics.core.characters import letters, letterlikes


names_wildcards = ""@*""
base_names_pattern = r'((?![0-9])([0-9${0}{1}{2}])+)'.format(letters, letterlikes, names_wildcards)
full_names_pattern = r'(`?{0}(`{0})*)'.format(base_names_pattern)


def get_file_time(file) -> float:
    try:
        return os.stat(file).st_mtime
    except OSError:
        return 0


def valuesname(name) -> str:
    "" 'NValues' -> 'n' ""

    assert name.startswith('System`'), name
    if name == 'System`Messages':
        return 'messages'
    else:
        return name[7:-6].lower()


class PyMathicsLoadException(Exception):
    def __init__(self, module):
        self.name = module + "" is not a valid pymathics module""
        self.module = module

class Definitions(object):
    def __init__(self, add_builtin=False, builtin_filename=None, extension_modules=[]) -> None:
        super(Definitions, self).__init__()
        self.builtin = {}
        self.user = {}
        self.pymathics = {} 
        self.definitions_cache = {}
        self.lookup_cache = {}
        self.proxy = defaultdict(set)
        self.now = 0    # increments whenever something is updated

        if add_builtin:
            from mathics.builtin import modules, contribute
            from mathics.core.evaluation import Evaluation
            from mathics.settings import ROOT_DIR

            loaded = False
            if builtin_filename is not None:
                builtin_dates = [get_file_time(module.__file__)
                                 for module in modules]
                builtin_time = max(builtin_dates)
                if get_file_time(builtin_filename) > builtin_time:
                    builtin_file = open(builtin_filename, 'rb')
                    self.builtin = pickle.load(builtin_file)
                    loaded = True
            if not loaded:
                contribute(self)
                for module in extension_modules:
                    try:
                        loaded_module = self.load_pymathics_module(module, remove_on_quit=False)
                    except PyMathicsLoadException as e:
                        print(e.module + ' is not a valid pymathics module.')
                        continue
                    except ImportError as e:
                        print(e.__repr__())
                        continue
                    #print(module + loaded_module.pymathics_version_data['version'] + ""  by "" + loaded_module.pymathics_version_data['author'])

                if builtin_filename is not None:
                    builtin_file = open(builtin_filename, 'wb')
                    pickle.dump(self.builtin, builtin_file, -1)

            # Load symbols from the autoload folder
            for root, dirs, files in os.walk(os.path.join(ROOT_DIR, 'autoload')):
                for path in [os.path.join(root, f) for f in files if f.endswith('.m')]:
                    Expression('Get', String(path)).evaluate(Evaluation(self))

            # Move any user definitions created by autoloaded files to
            # builtins, and clear out the user definitions list. This
            # means that any autoloaded definitions become shared
            # between users and no longer disappear after a Quit[].
            #
            # Autoloads that accidentally define a name in Global`
            # could cause confusion, so check for this.
            #
            for name in self.user:
                if name.startswith('Global`'):
                    raise ValueError(""autoload defined %s."" % name)
            self.builtin.update(self.user)
            self.user = {}
            self.clear_cache()

    def load_pymathics_module(self, module, remove_on_quit=True):
        '''
        loads Mathics builtin objects and their definitions
        from an external python module
        '''
        import importlib
        from mathics.builtin import is_builtin, builtins, builtins_by_module, Builtin
        loaded_module = importlib.import_module(module)
        builtins_by_module[loaded_module.__name__] = []
        vars = dir(loaded_module)
        newsymbols = {}
        if not ('pymathics_version_data' in vars):
            raise PyMathicsLoadException(module)
        for name in vars:
            var = getattr(loaded_module, name)
            if (hasattr(var, '__module__') and
                var.__module__ != 'mathics.builtin.base' and 
                    is_builtin(var) and not name.startswith('_') and
                var.__module__[:len(loaded_module.__name__)] == loaded_module.__name__):     # nopep8
                instance = var(expression=False)
                if isinstance(instance, Builtin):
                    builtins[instance.get_name()] = instance
                    builtins_by_module[loaded_module.__name__].append(instance)
                    newsymbols[instance.get_name()] = instance

        for name in newsymbols:
            if remove_on_quit and name not in self.pymathics:
                self.pymathics[name] = self.builtin.get(name, None)
        self.builtin.update(newsymbols)
        for name, item in newsymbols.items():
            if name != 'System`MakeBoxes':
                item.contribute(self)
        return loaded_module

    def clear_pymathics_modules(self):
        from mathics.builtin import builtins, builtins_by_module
        # Remove all modules that are not in mathics
        # print(""cleaning pymathics modules"")
        for key in list(builtins_by_module.keys()):
            if key[:8] != ""mathics."":
                print(""removing module "", key, "" not in mathics."")
                del builtins_by_module[key]
        # print(""reloading symbols from current builtins."")
        for s in self.pymathics:
            if s in self.builtin:
                # If there was a true built-in definition for the symbol, restore it, else, remove he symbol. 
                if self.pymathics[s]:
                    self.builtin[s] = self.pymathics[s]
                    builtins[s] = None
                    for key, val in builtins_by_module:
                        for simb in val:
                            if simb.get_name() == s:
                                builtins[s] = simb
                                break
                        if builtins[s] is not None:
                            break
                    if builtins[s] is None:
                        builtins.__delitem__(s)
                else:
                    self.builtin.__delitem__(s)
                    builtins.__delitem__(s)
        self.pymathics = {}
        # print(""everything is clean"")
        return None

    def clear_cache(self, name=None):
        # the definitions cache (self.definitions_cache) caches (incomplete and complete) names -> Definition(),
        # e.g. ""xy"" -> d and ""MyContext`xy"" -> d. we need to clear this cache if a Definition() changes (which
        # would happen if a Definition is combined from a builtin and a user definition and some content in the
        # user definition is updated) or if the lookup rules change and we could end up at a completely different
        # Definition.

        # the lookup cache (self.lookup_cache) caches what lookup_name() does. we only need to update this if some
        # change happens that might change the result lookup_name() calculates. we do not need to change it if a
        # Definition() changes.

        # self.proxy keeps track of all the names we cache. if we need to clear the caches for only one name, e.g.
        # 'MySymbol', then we need to be able to look up all the entries that might be related to it, e.g. 'MySymbol',
        # 'A`MySymbol', 'C`A`MySymbol', and so on. proxy identifies symbols using their stripped name and thus might
        # give us symbols in other contexts that are actually not affected. still, this is a safe solution.

        if name is None:
            self.definitions_cache = {}
            self.lookup_cache = {}
            self.proxy = defaultdict(set)
        else:
            definitions_cache = self.definitions_cache
            lookup_cache = self.lookup_cache
            tail = strip_context(name)
            for k in self.proxy.pop(tail, []):
                definitions_cache.pop(k, None)
                lookup_cache.pop(k, None)

    def clear_definitions_cache(self, name) -> None:
        definitions_cache = self.definitions_cache
        tail = strip_context(name)
        for k in self.proxy.pop(tail, []):
            definitions_cache.pop(k, None)

    def last_changed(self, expr) -> int:
        # timestamp for the most recently changed part of a given expression.
        if isinstance(expr, Symbol):
            symb = self.get_definition(expr.get_name(), only_if_exists=True)
            if symb is None:
                # symbol doesn't exist so it was never changed
                return 0
            try:
                return symb.changed
            except AttributeError:
                # must be system symbol
                symb.changed = 0
                return 0
        result = 0
        head = expr.get_head()
        head_changed = self.last_changed(head)
        result = max(result, head_changed)
        for leaf in expr.get_leaves():
            leaf_changed = self.last_changed(leaf)
            result = max(result, leaf_changed)
        return result

    def get_current_context(self):
        # It's crucial to specify System` in this get_ownvalue() call,
        # otherwise we'll end up back in this function and trigger
        # infinite recursion.
        context_rule = self.get_ownvalue('System`$Context')
        context = context_rule.replace.get_string_value()
        assert context is not None, ""$Context somehow set to an invalid value""
        return context

    def get_context_path(self):
        context_path_rule = self.get_ownvalue('System`$ContextPath')
        context_path = context_path_rule.replace
        assert context_path.has_form('System`List', None)
        context_path = [c.get_string_value() for c in context_path.leaves]
        assert not any([c is None for c in context_path])
        return context_path

    def set_current_context(self, context) -> None:
        assert isinstance(context, str)
        self.set_ownvalue('System`$Context', String(context))
        self.clear_cache()

    def set_context_path(self, context_path) -> None:
        assert isinstance(context_path, list)
        assert all([isinstance(c, str) for c in context_path])
        self.set_ownvalue('System`$ContextPath',
                          Expression('System`List',
                                     *[String(c) for c in context_path]))
        self.clear_cache()

    def get_builtin_names(self):
        return set(self.builtin)

    def get_user_names(self):
        return set(self.user)

    def get_pymathics_names(self):
        return set(self.pymathics)

    def get_names(self):
        return self.get_builtin_names() | self.get_pymathics_names() | self.get_user_names()

    def get_accessible_contexts(self):
        ""Return the contexts reachable though $Context or $ContextPath.""
        accessible_ctxts = set(self.get_context_path())
        accessible_ctxts.add(self.get_current_context())
        return accessible_ctxts

    def get_matching_names(self, pattern) -> typing.List[str]:
        """"""
        Return a list of the symbol names matching a string pattern.

        A pattern containing a context mark (of the form
        ""ctx_pattern`short_pattern"") matches symbols whose context and
        short name individually match the two patterns. A pattern
        without a context mark matches symbols accessible through
        $Context and $ContextPath whose short names match the pattern.

        '*' matches any sequence of symbol characters or an empty
        string. '@' matches a non-empty sequence of symbol characters
        which aren't uppercase letters. In the context pattern, both
        '*' and '@' match context marks.
        """"""

        if re.match(full_names_pattern, pattern) is None:
            # The pattern contained characters which weren't allowed
            # in symbols and aren't valid wildcards. Hence, the
            # pattern can't match any symbols.
            return []

        # If we get here, there aren't any regexp metacharacters in
        # the pattern.

        if '`' in pattern:
            ctx_pattern, short_pattern = pattern.rsplit('`', 1)
            ctx_pattern = ((ctx_pattern + '`')
                           .replace('@', '[^A-Z`]+')
                           .replace('*', '.*')
                           .replace('$', r'\$'))
        else:
            short_pattern = pattern
            # start with a group matching the accessible contexts
            ctx_pattern = ""(?:%s)"" % ""|"".join(
                re.escape(c) for c in self.get_accessible_contexts())

        short_pattern = (short_pattern
                         .replace('@', '[^A-Z]+')
                         .replace('*', '[^`]*')
                         .replace('$', r'\$'))
        regex = re.compile('^' + ctx_pattern + short_pattern + '$')

        return [name for name in self.get_names() if regex.match(name)]

    def lookup_name(self, name) -> str:
        """"""
        Determine the full name (including context) for a symbol name.

        - If the name begins with a context mark, it's in the context
          given by $Context.
        - Otherwise, if it contains a context mark, it's already fully
          specified.
        - Otherwise, it doesn't contain a context mark: try $Context,
          then each element of $ContextPath, taking the first existing
          symbol.
        - Otherwise, it's a new symbol in $Context.
        """"""

        cached = self.lookup_cache.get(name, None)
        if cached is not None:
            return cached

        assert isinstance(name, str)

        # Bail out if the name we're being asked to look up is already
        # fully qualified.
        if fully_qualified_symbol_name(name):
            return name

        current_context = self.get_current_context()

        if '`' in name:
            if name.startswith('`'):
                return current_context + name.lstrip('`')
            return name

        with_context = current_context + name
        if not self.have_definition(with_context):
            for ctx in self.get_context_path():
                n = ctx + name
                if self.have_definition(n):
                    return n
        return with_context

    def shorten_name(self, name_with_ctx) -> str:
        if '`' not in name_with_ctx:
            return name_with_ctx

        def in_ctx(name, ctx):
            return name.startswith(ctx) and '`' not in name[len(ctx):]

        if in_ctx(name_with_ctx, self.get_current_context()):
            return name_with_ctx[len(self.get_current_context()):]
        for ctx in self.get_context_path():
            if in_ctx(name_with_ctx, ctx):
                return name_with_ctx[len(ctx):]
        return name_with_ctx

    def have_definition(self, name) -> bool:
        return self.get_definition(name, only_if_exists=True) is not None

    def get_definition(self, name, only_if_exists=False) -> 'Definition':
        definition = self.definitions_cache.get(name, None)
        if definition is not None:
            return definition

        original_name = name
        name = self.lookup_name(name)
        user = self.user.get(name, None)
        builtin = self.builtin.get(name, None)

        if user is None and builtin is None:            
            definition = None
        elif builtin is None:
            definition = user
        elif user is None:
            definition = builtin
        else:
            if user:
                attributes = user.attributes
            elif builtin:                        #  Never happens
                attributes = builtin.attributes
            else:                                #  Never happens
                attributes = set()
            if not user:                         #  Never happens
                user = Definition(name=name)
            if not builtin:                      #  Never happens
                builtin = Definition(name=name)
            options = builtin.options.copy()
            options.update(user.options)
            formatvalues = builtin.formatvalues.copy()
            for form, rules in user.formatvalues.items():
                if form in formatvalues:
                    formatvalues[form].extend(rules)
                else:
                    formatvalues[form] = rules

            definition = Definition(name=name,
                                    ownvalues=user.ownvalues + builtin.ownvalues,
                                    downvalues=user.downvalues + builtin.downvalues,
                                    subvalues=user.subvalues + builtin.subvalues,
                                    upvalues=user.upvalues + builtin.upvalues,
                                    formatvalues=formatvalues,
                                    messages=user.messages + builtin.messages,
                                    attributes=attributes,
                                    options=options,
                                    nvalues=user.nvalues + builtin.nvalues,
                                    defaultvalues=user.defaultvalues +
                                    builtin.defaultvalues,)

        if definition is not None:
            self.proxy[strip_context(original_name)].add(original_name)
            self.definitions_cache[original_name] = definition
            self.lookup_cache[original_name] = name
        elif not only_if_exists:
            definition = Definition(name=name)

        return definition

    def get_attributes(self, name):
        return self.get_definition(name).attributes

    def get_ownvalues(self, name):
        return self.get_definition(name).ownvalues

    def get_downvalues(self, name):
        return self.get_definition(name).downvalues

    def get_subvalues(self, name):
        return self.get_definition(name).subvalues

    def get_upvalues(self, name):
        return self.get_definition(name).upvalues

    def get_formats(self, name, format=''):
        formats = self.get_definition(name).formatvalues
        result = formats.get(format, []) + formats.get('', [])
        result.sort()
        return result

    def get_nvalues(self, name):
        return self.get_definition(name).nvalues

    def get_defaultvalues(self, name):
        return self.get_definition(name).defaultvalues

    def get_value(self, name, pos, pattern, evaluation):
        assert isinstance(name, str)
        assert '`' in name
        rules = self.get_definition(name).get_values_list(valuesname(pos))
        for rule in rules:
            result = rule.apply(pattern, evaluation)
            if result is not None:
                return result

    def get_user_definition(self, name, create=True) -> typing.Optional['Definition']:
        assert not isinstance(name, Symbol)

        existing = self.user.get(name)
        if existing:
            return existing
        else:
            if not create:
                return None
            builtin = self.builtin.get(name)
            if builtin:
                attributes = builtin.attributes
            else:
                attributes = set()
            self.user[name] = Definition(name=name, attributes=attributes)
            self.clear_cache(name)
            return self.user[name]

    def mark_changed(self, definition) -> None:
        self.now += 1
        definition.changed = self.now

    def reset_user_definition(self, name) -> None:
        assert not isinstance(name, Symbol)
        fullname = self.lookup_name(name)
        del self.user[fullname]
        self.clear_cache(fullname)
        # TODO fix changed

    def add_user_definition(self, name, definition) -> None:
        assert not isinstance(name, Symbol)
        self.mark_changed(definition)
        fullname = self.lookup_name(name)
        self.user[fullname] = definition
        self.clear_cache(fullname)

    def set_attribute(self, name, attribute) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.attributes.add(attribute)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def set_attributes(self, name, attributes) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.attributes = set(attributes)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def clear_attribute(self, name, attribute) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        if attribute in definition.attributes:
            definition.attributes.remove(attribute)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_rule(self, name, rule, position=None):
        definition = self.get_user_definition(self.lookup_name(name))
        if position is None:
            result = definition.add_rule(rule)
        else:
            result = definition.add_rule_at(rule, position)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)
        return result

    def add_format(self, name, rule, form='') -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        if isinstance(form, tuple) or isinstance(form, list):
            forms = form
        else:
            forms = [form]
        for form in forms:
            if form not in definition.formatvalues:
                definition.formatvalues[form] = []
            insert_rule(definition.formatvalues[form], rule)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_nvalue(self, name, rule) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.add_rule_at(rule, 'n')
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_default(self, name, rule) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.add_rule_at(rule, 'default')
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def add_message(self, name, rule) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.add_rule_at(rule, 'messages')
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def set_values(self, name, values, rules) -> None:
        pos = valuesname(values)
        definition = self.get_user_definition(self.lookup_name(name))
        definition.set_values_list(pos, rules)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def get_options(self, name):
        return self.get_definition(self.lookup_name(name)).options

    def reset_user_definitions(self) -> None:
        self.user = {}
        self.clear_cache()
        # TODO changed

    def get_user_definitions(self):
        return base64.encodebytes(pickle.dumps(self.user, protocol=2)).decode('ascii')

    def set_user_definitions(self, definitions) -> None:
        if definitions:
            self.user = pickle.loads(base64.decodebytes(definitions.encode('ascii')))
        else:
            self.user = {}
        self.clear_cache()

    def get_ownvalue(self, name):
        ownvalues = self.get_definition(self.lookup_name(name)).ownvalues
        if ownvalues:
            return ownvalues[0]
        return None

    def set_ownvalue(self, name, value) -> None:
        from .expression import Symbol
        from .rules import Rule

        name = self.lookup_name(name)
        self.add_rule(name, Rule(Symbol(name), value))
        self.clear_cache(name)

    def set_options(self, name, options) -> None:
        definition = self.get_user_definition(self.lookup_name(name))
        definition.options = options
        self.mark_changed(definition)
        self.clear_definitions_cache(name)

    def unset(self, name, expr):
        definition = self.get_user_definition(self.lookup_name(name))
        result = definition.remove_rule(expr)
        self.mark_changed(definition)
        self.clear_definitions_cache(name)
        return result

    def get_config_value(self, name, default=None):
        'Infinity -> None, otherwise returns integer.'
        value = self.get_definition(name).ownvalues
        if value:
            try:
                value = value[0].replace
            except AttributeError:
                return None
            if value.get_name() == 'System`Infinity' or value.has_form('DirectedInfinity', 1):
                return None

            return int(value.get_int_value())
        else:
            return default

    def set_config_value(self, name, new_value) -> None:
        from mathics.core.expression import Integer
        self.set_ownvalue(name, Integer(new_value))

    def set_line_no(self, line_no) -> None:
        self.set_config_value('$Line', line_no)

    def get_line_no(self):
        return self.get_config_value('$Line', 0)

    def get_history_length(self):
        history_length = self.get_config_value('$HistoryLength', 100)
        if history_length is None or history_length > 100:
            history_length = 100
        return history_length


def get_tag_position(pattern, name) -> typing.Optional[str]:
    if pattern.get_name() == name:
        return 'own'
    elif pattern.is_atom():
        return None
    else:
        head_name = pattern.get_head_name()
        if head_name == name:
            return 'down'
        elif head_name == 'System`Condition' and len(pattern.leaves) > 0:
            return get_tag_position(pattern.leaves[0], name)
        elif pattern.get_lookup_name() == name:
            return 'sub'
        else:
            for leaf in pattern.leaves:
                if leaf.get_lookup_name() == name:
                    return 'up'
        return None


def insert_rule(values, rule) -> None:
    for index, existing in enumerate(values):
        if existing.pattern.same(rule.pattern):
            del values[index]
            break
    # use insort_left to guarantee that if equal rules exist, newer rules will
    # get higher precedence by being inserted before them. see DownValues[].
    bisect.insort_left(values, rule)


class Definition(object):
    def __init__(self, name, rules=None, ownvalues=None, downvalues=None,
                 subvalues=None, upvalues=None, formatvalues=None,
                 messages=None, attributes=(), options=None, nvalues=None,
                 defaultvalues=None, builtin=None) -> None:

        super(Definition, self).__init__()
        self.name = name

        if rules is None:
            rules = []
        if ownvalues is None:
            ownvalues = []
        if downvalues is None:
            downvalues = []
        if subvalues is None:
            subvalues = []
        if upvalues is None:
            upvalues = []
        if formatvalues is None:
            formatvalues = {}
        if options is None:
            options = {}
        if nvalues is None:
            nvalues = []
        if defaultvalues is None:
            defaultvalues = []
        if messages is None:
            messages = []

        self.ownvalues = ownvalues
        self.downvalues = downvalues
        self.subvalues = subvalues
        self.upvalues = upvalues
        for rule in rules:
            self.add_rule(rule)
        self.formatvalues = dict((name, list)
                                 for name, list in formatvalues.items())
        self.messages = messages
        self.attributes = set(attributes)
        for a in self.attributes:
            assert '`' in a, ""%s attribute %s has no context"" % (name, a)
        self.options = options
        self.nvalues = nvalues
        self.defaultvalues = defaultvalues
        self.builtin = builtin

    def get_values_list(self, pos):
        assert pos.isalpha()
        if pos == 'messages':
            return self.messages
        else:
            return getattr(self, '%svalues' % pos)

    def set_values_list(self, pos, rules) -> None:
        assert pos.isalpha()
        if pos == 'messages':
            self.messages = rules
        else:
            setattr(self, '%svalues' % pos, rules)

    def add_rule_at(self, rule, position) -> bool:
        values = self.get_values_list(position)
        insert_rule(values, rule)
        return True

    def add_rule(self, rule) -> bool:
        pos = get_tag_position(rule.pattern, self.name)
        if pos:
            return self.add_rule_at(rule, pos)
        return False

    def remove_rule(self, lhs) -> bool:
        position = get_tag_position(lhs, self.name)
        if position:
            values = self.get_values_list(position)
            for index, existing in enumerate(values):
                if existing.pattern.expr.same(lhs):
                    del values[index]
                    return True
        return False

    def __repr__(self):
        s = '<Definition: name: {}, downvalues: {}, formats: {}, attributes: {}>'.format(
            self.name, self.downvalues, self.formatvalues, self.attributes)
        return s.encode('unicode_escape')
",Definitions.clear_pymathics_modules,https://github.com/mathics/Mathics/issues/836,"[{'piece_type': 'error message', 'piece_content': 'Mathics 1.1.dev0\non CPython 3.6.9 (default, Jul 17 2020, 12:50:27)\nusing SymPy 1.6.2, mpmath 1.1.0\n\nCopyright (C) 2011-2020 The Mathics Team.\nThis program comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions.\nSee the documentation for the full license.\n\nQuit by pressing CONTROL-D\n\nIn[1]:= a = 3\nOut[1]= 3\n\nIn[2]:= Quit[]\nremoving module  pymathics.natlang  not in mathics.\nIn[1]:= LoadModule[""pymathics.natlang""]\nOut[1]= pymathics.natlang\n\nIn[2]:= Quit[]\nremoving module  pymathics.natlang  not in mathics.\nTraceback (most recent call last):\nFile ""/home/pablo/.local/bin/mathics"", line 315, in <module>\nmain()\nFile ""/home/pablo/.local/bin/mathics"", line 298, in main\nresult = evaluation.evaluate(query, timeout=settings.TIMEOUT)\nFile ""/home/pablo/Documents/Mathics/mathics/core/evaluation.py"", line 286, in evaluate\nresult = run_with_timeout_and_stack(evaluate, timeout)\nFile ""/home/pablo/Documents/Mathics/mathics/core/evaluation.py"", line 95, in run_with_timeout_and_stack\nreturn request()\nFile ""/home/pablo/Documents/Mathics/mathics/core/evaluation.py"", line 264, in evaluate\nresult = query.evaluate(self)\nFile ""/home/pablo/Documents/Mathics/mathics/core/expression.py"", line 853, in evaluate\nexpr, reevaluate = expr.evaluate_next(evaluation)\nFile ""/home/pablo/Documents/Mathics/mathics/core/expression.py"", line 975, in evaluate_next\nresult = rule.apply(new, evaluation, fully=False)\nFile ""/home/pablo/Documents/Mathics/mathics/core/rules.py"", line 63, in apply\nyield_match, expression, {}, evaluation, fully=fully)\nFile ""/home/pablo/Documents/Mathics/mathics/core/pattern.py"", line 203, in match\nyield_head, expression.get_head(), vars, evaluation)\nFile ""/home/pablo/Documents/Mathics/mathics/core/pattern.py"", line 132, in match\nyield_func(vars, None)\nFile ""/home/pablo/Documents/Mathics/mathics/core/pattern.py"", line 198, in yield_head\nyield_func(head_vars, None)\nFile ""/home/pablo/Documents/Mathics/mathics/core/rules.py"", line 39, in yield_match\nnew_expression = self.do_replace(expression, vars, options, evaluation)\nFile ""/home/pablo/Documents/Mathics/mathics/core/rules.py"", line 124, in do_replace\nreturn self.function(evaluation=evaluation, **vars_noctx)\nFile ""/home/pablo/Documents/Mathics/mathics/builtin/assignment.py"", line 2205, in apply\nevaluation.definitions.clear_pymathics_modules()\nFile ""/home/pablo/Documents/Mathics/mathics/core/definitions.py"", line 157, in clear_pymathics_modules\nfor key, val in builtins_by_module:\nValueError: too many values to unpack (expected 2)'}]","Mathics 1.1.dev0
on CPython 3.6.9 (default, Jul 17 2020, 12:50:27)
using SymPy 1.6.2, mpmath 1.1.0

Copyright (C) 2011-2020 The Mathics Team.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions.
See the documentation for the full license.

Quit by pressing CONTROL-D

In[1]:= a = 3
Out[1]= 3

In[2]:= Quit[]
removing module  pymathics.natlang  not in mathics.
In[1]:= LoadModule[""pymathics.natlang""]
Out[1]= pymathics.natlang

In[2]:= Quit[]
removing module  pymathics.natlang  not in mathics.
Traceback (most recent call last):
File ""/home/pablo/.local/bin/mathics"", line 315, in <module>
main()
File ""/home/pablo/.local/bin/mathics"", line 298, in main
result = evaluation.evaluate(query, timeout=settings.TIMEOUT)
File ""/home/pablo/Documents/Mathics/mathics/core/evaluation.py"", line 286, in evaluate
result = run_with_timeout_and_stack(evaluate, timeout)
File ""/home/pablo/Documents/Mathics/mathics/core/evaluation.py"", line 95, in run_with_timeout_and_stack
return request()
File ""/home/pablo/Documents/Mathics/mathics/core/evaluation.py"", line 264, in evaluate
result = query.evaluate(self)
File ""/home/pablo/Documents/Mathics/mathics/core/expression.py"", line 853, in evaluate
expr, reevaluate = expr.evaluate_next(evaluation)
File ""/home/pablo/Documents/Mathics/mathics/core/expression.py"", line 975, in evaluate_next
result = rule.apply(new, evaluation, fully=False)
File ""/home/pablo/Documents/Mathics/mathics/core/rules.py"", line 63, in apply
yield_match, expression, {}, evaluation, fully=fully)
File ""/home/pablo/Documents/Mathics/mathics/core/pattern.py"", line 203, in match
yield_head, expression.get_head(), vars, evaluation)
File ""/home/pablo/Documents/Mathics/mathics/core/pattern.py"", line 132, in match
yield_func(vars, None)
File ""/home/pablo/Documents/Mathics/mathics/core/pattern.py"", line 198, in yield_head
yield_func(head_vars, None)
File ""/home/pablo/Documents/Mathics/mathics/core/rules.py"", line 39, in yield_match
new_expression = self.do_replace(expression, vars, options, evaluation)
File ""/home/pablo/Documents/Mathics/mathics/core/rules.py"", line 124, in do_replace
return self.function(evaluation=evaluation, **vars_noctx)
File ""/home/pablo/Documents/Mathics/mathics/builtin/assignment.py"", line 2205, in apply
evaluation.definitions.clear_pymathics_modules()
File ""/home/pablo/Documents/Mathics/mathics/core/definitions.py"", line 157, in clear_pymathics_modules
for key, val in builtins_by_module:
ValueError: too many values to unpack (expected 2)",ValueError,"    def clear_pymathics_modules(self):
        from mathics.builtin import builtins, builtins_by_module
        
        
        for key in list(builtins_by_module.keys()):
            if key[:8] != ""mathics."":
                print(""removing module "", key, "" not in mathics."")
                del builtins_by_module[key]
        
        for s in self.pymathics:
            if s in self.builtin:
                
                if self.pymathics[s]:
                    self.builtin[s] = self.pymathics[s]
                    builtins[s] = None
                    for key, val in builtins_by_module:
                        for simb in val:
                            if simb.get_name() == s:
                                builtins[s] = simb
                                break
                        if builtins[s] is not None:
                            break
                    if builtins[s] is None:
                        builtins.__delitem__(s)
                else:
                    self.builtin.__delitem__(s)
                    builtins.__delitem__(s)
        self.pymathics = {}
        
        return None","    def clear_pymathics_modules(self):
        from mathics.builtin import builtins, builtins_by_module
        
        
        for key in list(builtins_by_module.keys()):
            if not key.startswith(""mathics.""):
                print(f""removing module \""{key}\"" not in mathics."")
                del builtins_by_module[key]
        
        for s in self.pymathics:
            if s in self.builtin:
                
                if self.pymathics[s]:
                    self.builtin[s] = self.pymathics[s]
                    builtins[s] = None
                    for key, val in builtins_by_module.items():
                        for simb in val:
                            if simb.get_name() == s:
                                builtins[s] = simb
                                break
                        if builtins[s] is not None:
                            break
                    if builtins[s] is None:
                        builtins.__delitem__(s)
                else:
                    self.builtin.__delitem__(s)
                    builtins.__delitem__(s)
        self.pymathics = {}
        
        return None",[],[],buggy_snippets_files/c38d590a2b9f13a2fdf5a00003051a57f8d1f2606740a7b2d7f9391e2ca02664_before_merge.py,buggy_snippets_files/c38d590a2b9f13a2fdf5a00003051a57f8d1f2606740a7b2d7f9391e2ca02664_after_merge.py
"    def apply(self, evaluation):
        'Exit'
        exit()","    def apply(self, evaluation):
        'Exit[]'
        sys.exit()",mathics/builtin/evaluation.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-


from mathics.builtin.base import Predefined, Builtin
from mathics.core.expression import Integer
from mathics.core.evaluation import MAX_RECURSION_DEPTH, set_python_recursion_limit


class RecursionLimit(Predefined):
    """"""
    <dl>
    <dt>'$RecursionLimit'
        <dd>specifies the maximum allowable recursion depth after
        which a calculation is terminated.
    </dl>

    Calculations terminated by '$RecursionLimit' return '$Aborted':
    >> a = a + a
     : Recursion depth of 200 exceeded.
     = $Aborted
    >> $RecursionLimit
     = 200

    >> $RecursionLimit = x;
     : Cannot set $RecursionLimit to x; value must be an integer between 20 and 512; use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits.

    >> $RecursionLimit = 512
     = 512
    >> a = a + a
     : Recursion depth of 512 exceeded.
     = $Aborted

    #> $RecursionLimit = 20
     = 20
    #> a = a + a
     : Recursion depth of 20 exceeded.
     = $Aborted

    #> $RecursionLimit = 200
     = 200

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     : Recursion depth of 20 exceeded.
     = $Aborted
    #> ClearAll[f];
    """"""

    name = '$RecursionLimit'
    value = 200

    set_python_recursion_limit(value)

    rules = {
        '$RecursionLimit': str(value),
    }

    messages = {
        'reclim': ""Recursion depth of `1` exceeded."",
        'limset': (
            ""Cannot set $RecursionLimit to `1`; ""
            ""value must be an integer between 20 and %d; ""
            ""use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits."") % (
                MAX_RECURSION_DEPTH),
    }

    rules = {
        '$RecursionLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class IterationLimit(Predefined):
    """"""
    <dl>
    <dt>'$IterationLimit'
        <dd>specifies the maximum number of times a reevaluation may happen.
    </dl>

    Calculations terminated by '$IterationLimit' return '$Aborted':
    >> ClearAll[f]; f[x_] := f[x + 1];
    >> f[x]
     : Iteration limit of 1000 exceeded.
     = $Aborted
    >> $IterationLimit
     = 1000
    >> ClearAll[f];

    >> $IterationLimit = x;
     : Cannot set $IterationLimit to x; value must be an integer between 20 and Infinity.

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     : Iteration limit of 20 exceeded.
     = $Aborted
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];
    """"""

    name = '$IterationLimit'
    value = 1000

    rules = {
        '$IterationLimit': str(value),
    }

    messages = {
        'itlim': ""Iteration limit of `1` exceeded."",
        'limset': (
            ""Cannot set $IterationLimit to `1`; ""
            ""value must be an integer between 20 and Infinity.""),
    }

    rules = {
        '$IterationLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class Hold(Builtin):
    """"""
    <dl>
    <dt>'Hold[$expr$]'
        <dd>prevents $expr$ from being evaluated.
    </dl>
    >> Attributes[Hold]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)


class HoldComplete(Builtin):
    """"""
    <dl>
    <dt>'HoldComplete[$expr$]'
        <dd>prevents $expr$ from being evaluated, and also prevents
        'Sequence' objects from being spliced into argument lists.
    </dl>
    >> Attributes[HoldComplete]
     = {HoldAllComplete, Protected}
    """"""

    attributes = ('HoldAllComplete',)


class HoldForm(Builtin):
    """"""
    <dl>
    <dt>'HoldForm[$expr$]'
        <dd>is equivalent to 'Hold[$expr$]', but prints as $expr$.
    </dl>

    >> HoldForm[1 + 2 + 3]
     = 1 + 2 + 3

    'HoldForm' has attribute 'HoldAll':
    >> Attributes[HoldForm]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)

    rules = {
        'MakeBoxes[HoldForm[expr_], f_]': 'MakeBoxes[expr, f]',
    }


class Evaluate(Builtin):
    """"""
    <dl>
    <dt>'Evaluate[$expr$]'
        <dd>forces evaluation of $expr$, even if it occurs inside a
        held argument or a 'Hold' form.
    </dl>

    Create a function $f$ with a held argument:
    >> SetAttributes[f, HoldAll]
    >> f[1 + 2]
     = f[1 + 2]

    'Evaluate' forces evaluation of the argument, even though $f$ has
    the 'HoldAll' attribute:
    >> f[Evaluate[1 + 2]]
     = f[3]

    >> Hold[Evaluate[1 + 2]]
     = Hold[3]
    >> HoldComplete[Evaluate[1 + 2]]
     = HoldComplete[Evaluate[1 + 2]]
    >> Evaluate[Sequence[1, 2]]
     = Sequence[1, 2]
    """"""

    rules = {
        'Evaluate[Unevaluated[x_]]': 'Unevaluated[x]',
        'Evaluate[x___]': 'x',
    }


class Unevaluated(Builtin):
    """"""
    <dl>
    <dt>'Unevaluated[$expr$]'
        <dd>temporarily leaves $expr$ in an unevaluated form when it
        appears as a function argument.
    </dl>

    'Unevaluated' is automatically removed when function arguments are
    evaluated:
    >> Sqrt[Unevaluated[x]]
     = Sqrt[x]

    >> Length[Unevaluated[1+2+3+4]]
     = 4
    'Unevaluated' has attribute 'HoldAllComplete':
    >> Attributes[Unevaluated]
     = {HoldAllComplete, Protected}

    'Unevaluated' is maintained for arguments to non-executed functions:
    >> f[Unevaluated[x]]
     = f[Unevaluated[x]]
    Likewise, its kept in flattened arguments and sequences:
    >> Attributes[f] = {Flat};
    >> f[a, Unevaluated[f[b, c]]]
     = f[a, Unevaluated[b], Unevaluated[c]]
    >> g[a, Sequence[Unevaluated[b], Unevaluated[c]]]
     = g[a, Unevaluated[b], Unevaluated[c]]
    However, unevaluated sequences are kept:
    >> g[Unevaluated[Sequence[a, b, c]]]
     = g[Unevaluated[Sequence[a, b, c]]]

    #> Attributes[h] = Flat;
    #> h[items___] := Plus[items]
    #> h[1, Unevaluated[Sequence[Unevaluated[2], 3]], Sequence[4, Unevaluated[5]]]
     = 15
    """"""

    attributes = ('HoldAllComplete',)


class ReleaseHold(Builtin):
    """"""
    <dl>
    <dt>'ReleaseHold[$expr$]'
        <dd>removes any 'Hold', 'HoldForm', 'HoldPattern' or
        'HoldComplete' head from $expr$.
    </dl>
    >> x = 3;
    >> Hold[x]
     = Hold[x]
    >> ReleaseHold[Hold[x]]
     = 3
    >> ReleaseHold[y]
     = y
    """"""

    rules = {
        'ReleaseHold[(Hold|HoldForm|HoldPattern|HoldComplete)[expr_]]': 'expr',
        'ReleaseHold[other_]': 'other',
    }


class Sequence(Builtin):
    """"""
    <dl>
    <dt>'Sequence[$x1$, $x2$, ...]'
        <dd>represents a sequence of arguments to a function.
    </dl>

    'Sequence' is automatically spliced in, except when a function has attribute 'SequenceHold'
    (like assignment functions).
    >> f[x, Sequence[a, b], y]
     = f[x, a, b, y]
    >> Attributes[Set]
     = {HoldFirst, Protected, SequenceHold}
    >> a = Sequence[b, c];
    >> a
     = Sequence[b, c]

    Apply 'Sequence' to a list to splice in arguments:
    >> list = {1, 2, 3};
    >> f[Sequence @@ list]
     = f[1, 2, 3]

    Inside 'Hold' or a function with a held argument, 'Sequence' is
    spliced in at the first level of the argument:
    >> Hold[a, Sequence[b, c], d]
     = Hold[a, b, c, d]
    If 'Sequence' appears at a deeper level, it is left unevaluated:
    >> Hold[{a, Sequence[b, c], d}]
     = Hold[{a, Sequence[b, c], d}]
    """"""


class Line(Builtin):
    """"""
    <dl>
    <dt>'$Line'
        <dd>holds the current input line number.
    </dl>
    >> $Line
     = 1
    >> $Line
     = 2
    >> $Line = 12;
    >> 2 * 5
     = 10
    >> Out[13]
     = 10
    >> $Line = -1;
     : Non-negative integer expected.
    """"""

    name = '$Line'


class HistoryLength(Builtin):
    """"""
    <dl>
    <dt>'$HistoryLength'
        <dd>specifies the maximum number of 'In' and 'Out' entries.
    </dl>
    >> $HistoryLength
     = 100
    >> $HistoryLength = 1;
    >> 42
     = 42
    >> %
     = 42
    >> %%
     = %3
    >> $HistoryLength = 0;
    >> 42
     = 42
    >> %
     = %7
    """"""

    name = '$HistoryLength'

    rules = {
        '$HistoryLength': '100',
    }


class In(Builtin):
    """"""
    <dl>
    <dt>'In[$k$]'
        <dd>gives the $k$th line of input.
    </dl>
    >> x = 1
     = 1
    >> x = x + 1
     = 2
    >> Do[In[2], {3}]
    >> x
     = 5
    >> In[-1]
     = 5
    >> Definition[In]
     = Attributes[In] = {Protected}
     .
     . In[6] = Definition[In]
     .
     . In[5] = In[-1]
     .
     . In[4] = x
     .
     . In[3] = Do[In[2], {3}]
     .
     . In[2] = x = x + 1
     .
     . In[1] = x = 1
    """"""

    rules = {
        'In[k_Integer?Negative]': 'In[$Line + k]',
    }


class Out(Builtin):
    """"""
    <dl>
    <dt>'Out[$k$]'
    <dt>'%$k$'
        <dd>gives the result of the $k$th input line.
    <dt>'%', '%%', etc.
        <dd>gives the result of the previous input line, of the line before the previous input line, etc.
    </dl>

    >> 42
     = 42
    >> %
     = 42
    >> 43;
    >> %
     = 43
    >> 44
     = 44
    >> %1
     = 42
    >> %%
     = 44
    >> Hold[Out[-1]]
     = Hold[%]
    >> Hold[%4]
     = Hold[%4]
    >> Out[0]
     = Out[0]

    #> 10
     = 10
    #> Out[-1] + 1
     = 11
    #> Out[] + 1
     = 12
    """"""

    rules = {
        'Out[k_Integer?Negative]': 'Out[$Line + k]',
        'Out[]': 'Out[$Line - 1]',
        'MakeBoxes[Out[k_Integer?((-10 <= # < 0)&)],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'StringJoin[ConstantArray[""%%"", -k]]',
        'MakeBoxes[Out[k_Integer?Positive],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'""%%"" <> ToString[k]',
    }


class Exit(Builtin):
    '''
    <dl>
    <dt>'Exit'
      <dd>terminates the Mathics session.
    <dt>'Exit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Exit is an alias for Quit.
    '''

    def apply(self, evaluation):
        'Exit'
        exit()

    def apply_n(self, n, evaluation):
        'Exit[n_Integer]'
        exit(n.get_int_value())


class Quit(Builtin):
    '''
    <dl>
    <dt>'Quit'
      <dd>terminates the Mathics session.
    <dt>'Quit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Quit is an alias for Exit.
    '''

    rules = {
        'Quit[n_Integer]': 'Exit[n]',
        'Quit': 'Exit',
    }
","#!/usr/bin/env python
# -*- coding: utf-8 -*-


from mathics.builtin.base import Predefined, Builtin
from mathics.core.expression import Integer
from mathics.core.evaluation import MAX_RECURSION_DEPTH, set_python_recursion_limit


class RecursionLimit(Predefined):
    """"""
    <dl>
    <dt>'$RecursionLimit'
        <dd>specifies the maximum allowable recursion depth after
        which a calculation is terminated.
    </dl>

    Calculations terminated by '$RecursionLimit' return '$Aborted':
    >> a = a + a
     : Recursion depth of 200 exceeded.
     = $Aborted
    >> $RecursionLimit
     = 200

    >> $RecursionLimit = x;
     : Cannot set $RecursionLimit to x; value must be an integer between 20 and 512; use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits.

    >> $RecursionLimit = 512
     = 512
    >> a = a + a
     : Recursion depth of 512 exceeded.
     = $Aborted

    #> $RecursionLimit = 20
     = 20
    #> a = a + a
     : Recursion depth of 20 exceeded.
     = $Aborted

    #> $RecursionLimit = 200
     = 200

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     : Recursion depth of 20 exceeded.
     = $Aborted
    #> ClearAll[f];
    """"""

    name = '$RecursionLimit'
    value = 200

    set_python_recursion_limit(value)

    rules = {
        '$RecursionLimit': str(value),
    }

    messages = {
        'reclim': ""Recursion depth of `1` exceeded."",
        'limset': (
            ""Cannot set $RecursionLimit to `1`; ""
            ""value must be an integer between 20 and %d; ""
            ""use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits."") % (
                MAX_RECURSION_DEPTH),
    }

    rules = {
        '$RecursionLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class IterationLimit(Predefined):
    """"""
    <dl>
    <dt>'$IterationLimit'
        <dd>specifies the maximum number of times a reevaluation may happen.
    </dl>

    Calculations terminated by '$IterationLimit' return '$Aborted':
    >> ClearAll[f]; f[x_] := f[x + 1];
    >> f[x]
     : Iteration limit of 1000 exceeded.
     = $Aborted
    >> $IterationLimit
     = 1000
    >> ClearAll[f];

    >> $IterationLimit = x;
     : Cannot set $IterationLimit to x; value must be an integer between 20 and Infinity.

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     : Iteration limit of 20 exceeded.
     = $Aborted
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];
    """"""

    name = '$IterationLimit'
    value = 1000

    rules = {
        '$IterationLimit': str(value),
    }

    messages = {
        'itlim': ""Iteration limit of `1` exceeded."",
        'limset': (
            ""Cannot set $IterationLimit to `1`; ""
            ""value must be an integer between 20 and Infinity.""),
    }

    rules = {
        '$IterationLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class Hold(Builtin):
    """"""
    <dl>
    <dt>'Hold[$expr$]'
        <dd>prevents $expr$ from being evaluated.
    </dl>
    >> Attributes[Hold]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)


class HoldComplete(Builtin):
    """"""
    <dl>
    <dt>'HoldComplete[$expr$]'
        <dd>prevents $expr$ from being evaluated, and also prevents
        'Sequence' objects from being spliced into argument lists.
    </dl>
    >> Attributes[HoldComplete]
     = {HoldAllComplete, Protected}
    """"""

    attributes = ('HoldAllComplete',)


class HoldForm(Builtin):
    """"""
    <dl>
    <dt>'HoldForm[$expr$]'
        <dd>is equivalent to 'Hold[$expr$]', but prints as $expr$.
    </dl>

    >> HoldForm[1 + 2 + 3]
     = 1 + 2 + 3

    'HoldForm' has attribute 'HoldAll':
    >> Attributes[HoldForm]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)

    rules = {
        'MakeBoxes[HoldForm[expr_], f_]': 'MakeBoxes[expr, f]',
    }


class Evaluate(Builtin):
    """"""
    <dl>
    <dt>'Evaluate[$expr$]'
        <dd>forces evaluation of $expr$, even if it occurs inside a
        held argument or a 'Hold' form.
    </dl>

    Create a function $f$ with a held argument:
    >> SetAttributes[f, HoldAll]
    >> f[1 + 2]
     = f[1 + 2]

    'Evaluate' forces evaluation of the argument, even though $f$ has
    the 'HoldAll' attribute:
    >> f[Evaluate[1 + 2]]
     = f[3]

    >> Hold[Evaluate[1 + 2]]
     = Hold[3]
    >> HoldComplete[Evaluate[1 + 2]]
     = HoldComplete[Evaluate[1 + 2]]
    >> Evaluate[Sequence[1, 2]]
     = Sequence[1, 2]
    """"""

    rules = {
        'Evaluate[Unevaluated[x_]]': 'Unevaluated[x]',
        'Evaluate[x___]': 'x',
    }


class Unevaluated(Builtin):
    """"""
    <dl>
    <dt>'Unevaluated[$expr$]'
        <dd>temporarily leaves $expr$ in an unevaluated form when it
        appears as a function argument.
    </dl>

    'Unevaluated' is automatically removed when function arguments are
    evaluated:
    >> Sqrt[Unevaluated[x]]
     = Sqrt[x]

    >> Length[Unevaluated[1+2+3+4]]
     = 4
    'Unevaluated' has attribute 'HoldAllComplete':
    >> Attributes[Unevaluated]
     = {HoldAllComplete, Protected}

    'Unevaluated' is maintained for arguments to non-executed functions:
    >> f[Unevaluated[x]]
     = f[Unevaluated[x]]
    Likewise, its kept in flattened arguments and sequences:
    >> Attributes[f] = {Flat};
    >> f[a, Unevaluated[f[b, c]]]
     = f[a, Unevaluated[b], Unevaluated[c]]
    >> g[a, Sequence[Unevaluated[b], Unevaluated[c]]]
     = g[a, Unevaluated[b], Unevaluated[c]]
    However, unevaluated sequences are kept:
    >> g[Unevaluated[Sequence[a, b, c]]]
     = g[Unevaluated[Sequence[a, b, c]]]

    #> Attributes[h] = Flat;
    #> h[items___] := Plus[items]
    #> h[1, Unevaluated[Sequence[Unevaluated[2], 3]], Sequence[4, Unevaluated[5]]]
     = 15
    """"""

    attributes = ('HoldAllComplete',)


class ReleaseHold(Builtin):
    """"""
    <dl>
    <dt>'ReleaseHold[$expr$]'
        <dd>removes any 'Hold', 'HoldForm', 'HoldPattern' or
        'HoldComplete' head from $expr$.
    </dl>
    >> x = 3;
    >> Hold[x]
     = Hold[x]
    >> ReleaseHold[Hold[x]]
     = 3
    >> ReleaseHold[y]
     = y
    """"""

    rules = {
        'ReleaseHold[(Hold|HoldForm|HoldPattern|HoldComplete)[expr_]]': 'expr',
        'ReleaseHold[other_]': 'other',
    }


class Sequence(Builtin):
    """"""
    <dl>
    <dt>'Sequence[$x1$, $x2$, ...]'
        <dd>represents a sequence of arguments to a function.
    </dl>

    'Sequence' is automatically spliced in, except when a function has attribute 'SequenceHold'
    (like assignment functions).
    >> f[x, Sequence[a, b], y]
     = f[x, a, b, y]
    >> Attributes[Set]
     = {HoldFirst, Protected, SequenceHold}
    >> a = Sequence[b, c];
    >> a
     = Sequence[b, c]

    Apply 'Sequence' to a list to splice in arguments:
    >> list = {1, 2, 3};
    >> f[Sequence @@ list]
     = f[1, 2, 3]

    Inside 'Hold' or a function with a held argument, 'Sequence' is
    spliced in at the first level of the argument:
    >> Hold[a, Sequence[b, c], d]
     = Hold[a, b, c, d]
    If 'Sequence' appears at a deeper level, it is left unevaluated:
    >> Hold[{a, Sequence[b, c], d}]
     = Hold[{a, Sequence[b, c], d}]
    """"""


class Line(Builtin):
    """"""
    <dl>
    <dt>'$Line'
        <dd>holds the current input line number.
    </dl>
    >> $Line
     = 1
    >> $Line
     = 2
    >> $Line = 12;
    >> 2 * 5
     = 10
    >> Out[13]
     = 10
    >> $Line = -1;
     : Non-negative integer expected.
    """"""

    name = '$Line'


class HistoryLength(Builtin):
    """"""
    <dl>
    <dt>'$HistoryLength'
        <dd>specifies the maximum number of 'In' and 'Out' entries.
    </dl>
    >> $HistoryLength
     = 100
    >> $HistoryLength = 1;
    >> 42
     = 42
    >> %
     = 42
    >> %%
     = %3
    >> $HistoryLength = 0;
    >> 42
     = 42
    >> %
     = %7
    """"""

    name = '$HistoryLength'

    rules = {
        '$HistoryLength': '100',
    }


class In(Builtin):
    """"""
    <dl>
    <dt>'In[$k$]'
        <dd>gives the $k$th line of input.
    </dl>
    >> x = 1
     = 1
    >> x = x + 1
     = 2
    >> Do[In[2], {3}]
    >> x
     = 5
    >> In[-1]
     = 5
    >> Definition[In]
     = Attributes[In] = {Protected}
     .
     . In[6] = Definition[In]
     .
     . In[5] = In[-1]
     .
     . In[4] = x
     .
     . In[3] = Do[In[2], {3}]
     .
     . In[2] = x = x + 1
     .
     . In[1] = x = 1
    """"""

    rules = {
        'In[k_Integer?Negative]': 'In[$Line + k]',
    }


class Out(Builtin):
    """"""
    <dl>
    <dt>'Out[$k$]'
    <dt>'%$k$'
        <dd>gives the result of the $k$th input line.
    <dt>'%', '%%', etc.
        <dd>gives the result of the previous input line, of the line before the previous input line, etc.
    </dl>

    >> 42
     = 42
    >> %
     = 42
    >> 43;
    >> %
     = 43
    >> 44
     = 44
    >> %1
     = 42
    >> %%
     = 44
    >> Hold[Out[-1]]
     = Hold[%]
    >> Hold[%4]
     = Hold[%4]
    >> Out[0]
     = Out[0]

    #> 10
     = 10
    #> Out[-1] + 1
     = 11
    #> Out[] + 1
     = 12
    """"""

    rules = {
        'Out[k_Integer?Negative]': 'Out[$Line + k]',
        'Out[]': 'Out[$Line - 1]',
        'MakeBoxes[Out[k_Integer?((-10 <= # < 0)&)],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'StringJoin[ConstantArray[""%%"", -k]]',
        'MakeBoxes[Out[k_Integer?Positive],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'""%%"" <> ToString[k]',
    }


class Exit(Builtin):
    '''
    <dl>
    <dt>'Exit[]'
      <dd>terminates the Mathics session.
    <dt>'Exit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Exit is an alias for Quit.
    '''

    def apply(self, evaluation):
        'Exit[]'
        sys.exit()

    def apply_n(self, n, evaluation):
        'Exit[n_Integer]'
        sys.exit(n.get_int_value())


class Quit(Builtin):
    '''
    <dl>
    <dt>'Quit[]'
      <dd>terminates the Mathics session.
    <dt>'Quit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Quit is an alias for Exit.
    '''

    rules = {
        'Quit[n_Integer]': 'Exit[n]',
        'Quit[]': 'Exit[]',
    }
",Exit.apply,https://github.com/mathics/Mathics/issues/813,"[{'piece_type': 'error message', 'piece_content': 'Copyright (C) 2011-2016 The Mathics Team.\nThis program comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions.\nSee the documentation for the full license.\n\nQuit by pressing CONTROL-D\n\nIn[1]:= Quit[]\nTraceback (most recent call last):\nFile ""~/Documents/Mathics/mathics/main.py"", line 303, in <module>\nmain()\nFile ""~/Documents/Mathics/mathics/main.py"", line 286, in main\nresult = evaluation.evaluate(query, timeout=settings.TIMEOUT)\nFile ""~/Documents/Mathics/mathics/core/evaluation.py"", line 288, in evaluate\nresult = run_with_timeout_and_stack(evaluate, timeout)\nFile ""~/Documents/Mathics/mathics/core/evaluation.py"", line 95, in run_with_timeout_and_stack\nreturn request()\nFile ""~/Documents/Mathics/mathics/core/evaluation.py"", line 265, in evaluate\nresult = query.evaluate(self)\nFile ""~/Documents/Mathics/mathics/core/expression.py"", line 853, in evaluate\nexpr, reevaluate = expr.evaluate_next(evaluation)\nFile ""~/Documents/Mathics/mathics/core/expression.py"", line 975, in evaluate_next\nresult = rule.apply(new, evaluation, fully=False)\nFile ""~/Documents/Mathics/mathics/core/rules.py"", line 63, in apply\nyield_match, expression, {}, evaluation, fully=fully)\nFile ""~/Documents/Mathics/mathics/core/pattern.py"", line 203, in match\nyield_head, expression.get_head(), vars, evaluation)\nFile ""~/Documents/Mathics/mathics/core/pattern.py"", line 132, in match\nyield_func(vars, None)\nFile ""~/Documents/Mathics/mathics/core/pattern.py"", line 198, in yield_head\nyield_func(head_vars, None)\nFile ""~/Documents/Mathics/mathics/core/rules.py"", line 39, in yield_match\nnew_expression = self.do_replace(expression, vars, options, evaluation)\nFile ""~/Documents/Mathics/mathics/core/rules.py"", line 124, in do_replace\nreturn self.function(evaluation=evaluation, **vars_noctx)\nFile ""~/Documents/Mathics/mathics/builtin/evaluation.py"", line 465, in apply\nsys.exit()\nNameError: name \'sys\' is not defined'}]","Copyright (C) 2011-2016 The Mathics Team.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions.
See the documentation for the full license.

Quit by pressing CONTROL-D

In[1]:= Quit[]
Traceback (most recent call last):
File ""~/Documents/Mathics/mathics/main.py"", line 303, in <module>
main()
File ""~/Documents/Mathics/mathics/main.py"", line 286, in main
result = evaluation.evaluate(query, timeout=settings.TIMEOUT)
File ""~/Documents/Mathics/mathics/core/evaluation.py"", line 288, in evaluate
result = run_with_timeout_and_stack(evaluate, timeout)
File ""~/Documents/Mathics/mathics/core/evaluation.py"", line 95, in run_with_timeout_and_stack
return request()
File ""~/Documents/Mathics/mathics/core/evaluation.py"", line 265, in evaluate
result = query.evaluate(self)
File ""~/Documents/Mathics/mathics/core/expression.py"", line 853, in evaluate
expr, reevaluate = expr.evaluate_next(evaluation)
File ""~/Documents/Mathics/mathics/core/expression.py"", line 975, in evaluate_next
result = rule.apply(new, evaluation, fully=False)
File ""~/Documents/Mathics/mathics/core/rules.py"", line 63, in apply
yield_match, expression, {}, evaluation, fully=fully)
File ""~/Documents/Mathics/mathics/core/pattern.py"", line 203, in match
yield_head, expression.get_head(), vars, evaluation)
File ""~/Documents/Mathics/mathics/core/pattern.py"", line 132, in match
yield_func(vars, None)
File ""~/Documents/Mathics/mathics/core/pattern.py"", line 198, in yield_head
yield_func(head_vars, None)
File ""~/Documents/Mathics/mathics/core/rules.py"", line 39, in yield_match
new_expression = self.do_replace(expression, vars, options, evaluation)
File ""~/Documents/Mathics/mathics/core/rules.py"", line 124, in do_replace
return self.function(evaluation=evaluation, **vars_noctx)
File ""~/Documents/Mathics/mathics/builtin/evaluation.py"", line 465, in apply
sys.exit()
NameError: name 'sys' is not defined",NameError,"    def apply(self, evaluation):
        
        sys.exit()","    def apply(self, evaluation):
        
        exit()",[],[],buggy_snippets_files/af9710252c22c98fce52a1b303149b57ab95716e3f635033ba0982307edead9e_before_merge.py,buggy_snippets_files/af9710252c22c98fce52a1b303149b57ab95716e3f635033ba0982307edead9e_after_merge.py
"    def apply_n(self, n, evaluation):
        'Exit[n_Integer]'
        exit(n.get_int_value())","    def apply_n(self, n, evaluation):
        'Exit[n_Integer]'
        sys.exit(n.get_int_value())",mathics/builtin/evaluation.py,"#!/usr/bin/env python
# -*- coding: utf-8 -*-


from mathics.builtin.base import Predefined, Builtin
from mathics.core.expression import Integer
from mathics.core.evaluation import MAX_RECURSION_DEPTH, set_python_recursion_limit


class RecursionLimit(Predefined):
    """"""
    <dl>
    <dt>'$RecursionLimit'
        <dd>specifies the maximum allowable recursion depth after
        which a calculation is terminated.
    </dl>

    Calculations terminated by '$RecursionLimit' return '$Aborted':
    >> a = a + a
     : Recursion depth of 200 exceeded.
     = $Aborted
    >> $RecursionLimit
     = 200

    >> $RecursionLimit = x;
     : Cannot set $RecursionLimit to x; value must be an integer between 20 and 512; use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits.

    >> $RecursionLimit = 512
     = 512
    >> a = a + a
     : Recursion depth of 512 exceeded.
     = $Aborted

    #> $RecursionLimit = 20
     = 20
    #> a = a + a
     : Recursion depth of 20 exceeded.
     = $Aborted

    #> $RecursionLimit = 200
     = 200

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     : Recursion depth of 20 exceeded.
     = $Aborted
    #> ClearAll[f];
    """"""

    name = '$RecursionLimit'
    value = 200

    set_python_recursion_limit(value)

    rules = {
        '$RecursionLimit': str(value),
    }

    messages = {
        'reclim': ""Recursion depth of `1` exceeded."",
        'limset': (
            ""Cannot set $RecursionLimit to `1`; ""
            ""value must be an integer between 20 and %d; ""
            ""use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits."") % (
                MAX_RECURSION_DEPTH),
    }

    rules = {
        '$RecursionLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class IterationLimit(Predefined):
    """"""
    <dl>
    <dt>'$IterationLimit'
        <dd>specifies the maximum number of times a reevaluation may happen.
    </dl>

    Calculations terminated by '$IterationLimit' return '$Aborted':
    >> ClearAll[f]; f[x_] := f[x + 1];
    >> f[x]
     : Iteration limit of 1000 exceeded.
     = $Aborted
    >> $IterationLimit
     = 1000
    >> ClearAll[f];

    >> $IterationLimit = x;
     : Cannot set $IterationLimit to x; value must be an integer between 20 and Infinity.

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     : Iteration limit of 20 exceeded.
     = $Aborted
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];
    """"""

    name = '$IterationLimit'
    value = 1000

    rules = {
        '$IterationLimit': str(value),
    }

    messages = {
        'itlim': ""Iteration limit of `1` exceeded."",
        'limset': (
            ""Cannot set $IterationLimit to `1`; ""
            ""value must be an integer between 20 and Infinity.""),
    }

    rules = {
        '$IterationLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class Hold(Builtin):
    """"""
    <dl>
    <dt>'Hold[$expr$]'
        <dd>prevents $expr$ from being evaluated.
    </dl>
    >> Attributes[Hold]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)


class HoldComplete(Builtin):
    """"""
    <dl>
    <dt>'HoldComplete[$expr$]'
        <dd>prevents $expr$ from being evaluated, and also prevents
        'Sequence' objects from being spliced into argument lists.
    </dl>
    >> Attributes[HoldComplete]
     = {HoldAllComplete, Protected}
    """"""

    attributes = ('HoldAllComplete',)


class HoldForm(Builtin):
    """"""
    <dl>
    <dt>'HoldForm[$expr$]'
        <dd>is equivalent to 'Hold[$expr$]', but prints as $expr$.
    </dl>

    >> HoldForm[1 + 2 + 3]
     = 1 + 2 + 3

    'HoldForm' has attribute 'HoldAll':
    >> Attributes[HoldForm]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)

    rules = {
        'MakeBoxes[HoldForm[expr_], f_]': 'MakeBoxes[expr, f]',
    }


class Evaluate(Builtin):
    """"""
    <dl>
    <dt>'Evaluate[$expr$]'
        <dd>forces evaluation of $expr$, even if it occurs inside a
        held argument or a 'Hold' form.
    </dl>

    Create a function $f$ with a held argument:
    >> SetAttributes[f, HoldAll]
    >> f[1 + 2]
     = f[1 + 2]

    'Evaluate' forces evaluation of the argument, even though $f$ has
    the 'HoldAll' attribute:
    >> f[Evaluate[1 + 2]]
     = f[3]

    >> Hold[Evaluate[1 + 2]]
     = Hold[3]
    >> HoldComplete[Evaluate[1 + 2]]
     = HoldComplete[Evaluate[1 + 2]]
    >> Evaluate[Sequence[1, 2]]
     = Sequence[1, 2]
    """"""

    rules = {
        'Evaluate[Unevaluated[x_]]': 'Unevaluated[x]',
        'Evaluate[x___]': 'x',
    }


class Unevaluated(Builtin):
    """"""
    <dl>
    <dt>'Unevaluated[$expr$]'
        <dd>temporarily leaves $expr$ in an unevaluated form when it
        appears as a function argument.
    </dl>

    'Unevaluated' is automatically removed when function arguments are
    evaluated:
    >> Sqrt[Unevaluated[x]]
     = Sqrt[x]

    >> Length[Unevaluated[1+2+3+4]]
     = 4
    'Unevaluated' has attribute 'HoldAllComplete':
    >> Attributes[Unevaluated]
     = {HoldAllComplete, Protected}

    'Unevaluated' is maintained for arguments to non-executed functions:
    >> f[Unevaluated[x]]
     = f[Unevaluated[x]]
    Likewise, its kept in flattened arguments and sequences:
    >> Attributes[f] = {Flat};
    >> f[a, Unevaluated[f[b, c]]]
     = f[a, Unevaluated[b], Unevaluated[c]]
    >> g[a, Sequence[Unevaluated[b], Unevaluated[c]]]
     = g[a, Unevaluated[b], Unevaluated[c]]
    However, unevaluated sequences are kept:
    >> g[Unevaluated[Sequence[a, b, c]]]
     = g[Unevaluated[Sequence[a, b, c]]]

    #> Attributes[h] = Flat;
    #> h[items___] := Plus[items]
    #> h[1, Unevaluated[Sequence[Unevaluated[2], 3]], Sequence[4, Unevaluated[5]]]
     = 15
    """"""

    attributes = ('HoldAllComplete',)


class ReleaseHold(Builtin):
    """"""
    <dl>
    <dt>'ReleaseHold[$expr$]'
        <dd>removes any 'Hold', 'HoldForm', 'HoldPattern' or
        'HoldComplete' head from $expr$.
    </dl>
    >> x = 3;
    >> Hold[x]
     = Hold[x]
    >> ReleaseHold[Hold[x]]
     = 3
    >> ReleaseHold[y]
     = y
    """"""

    rules = {
        'ReleaseHold[(Hold|HoldForm|HoldPattern|HoldComplete)[expr_]]': 'expr',
        'ReleaseHold[other_]': 'other',
    }


class Sequence(Builtin):
    """"""
    <dl>
    <dt>'Sequence[$x1$, $x2$, ...]'
        <dd>represents a sequence of arguments to a function.
    </dl>

    'Sequence' is automatically spliced in, except when a function has attribute 'SequenceHold'
    (like assignment functions).
    >> f[x, Sequence[a, b], y]
     = f[x, a, b, y]
    >> Attributes[Set]
     = {HoldFirst, Protected, SequenceHold}
    >> a = Sequence[b, c];
    >> a
     = Sequence[b, c]

    Apply 'Sequence' to a list to splice in arguments:
    >> list = {1, 2, 3};
    >> f[Sequence @@ list]
     = f[1, 2, 3]

    Inside 'Hold' or a function with a held argument, 'Sequence' is
    spliced in at the first level of the argument:
    >> Hold[a, Sequence[b, c], d]
     = Hold[a, b, c, d]
    If 'Sequence' appears at a deeper level, it is left unevaluated:
    >> Hold[{a, Sequence[b, c], d}]
     = Hold[{a, Sequence[b, c], d}]
    """"""


class Line(Builtin):
    """"""
    <dl>
    <dt>'$Line'
        <dd>holds the current input line number.
    </dl>
    >> $Line
     = 1
    >> $Line
     = 2
    >> $Line = 12;
    >> 2 * 5
     = 10
    >> Out[13]
     = 10
    >> $Line = -1;
     : Non-negative integer expected.
    """"""

    name = '$Line'


class HistoryLength(Builtin):
    """"""
    <dl>
    <dt>'$HistoryLength'
        <dd>specifies the maximum number of 'In' and 'Out' entries.
    </dl>
    >> $HistoryLength
     = 100
    >> $HistoryLength = 1;
    >> 42
     = 42
    >> %
     = 42
    >> %%
     = %3
    >> $HistoryLength = 0;
    >> 42
     = 42
    >> %
     = %7
    """"""

    name = '$HistoryLength'

    rules = {
        '$HistoryLength': '100',
    }


class In(Builtin):
    """"""
    <dl>
    <dt>'In[$k$]'
        <dd>gives the $k$th line of input.
    </dl>
    >> x = 1
     = 1
    >> x = x + 1
     = 2
    >> Do[In[2], {3}]
    >> x
     = 5
    >> In[-1]
     = 5
    >> Definition[In]
     = Attributes[In] = {Protected}
     .
     . In[6] = Definition[In]
     .
     . In[5] = In[-1]
     .
     . In[4] = x
     .
     . In[3] = Do[In[2], {3}]
     .
     . In[2] = x = x + 1
     .
     . In[1] = x = 1
    """"""

    rules = {
        'In[k_Integer?Negative]': 'In[$Line + k]',
    }


class Out(Builtin):
    """"""
    <dl>
    <dt>'Out[$k$]'
    <dt>'%$k$'
        <dd>gives the result of the $k$th input line.
    <dt>'%', '%%', etc.
        <dd>gives the result of the previous input line, of the line before the previous input line, etc.
    </dl>

    >> 42
     = 42
    >> %
     = 42
    >> 43;
    >> %
     = 43
    >> 44
     = 44
    >> %1
     = 42
    >> %%
     = 44
    >> Hold[Out[-1]]
     = Hold[%]
    >> Hold[%4]
     = Hold[%4]
    >> Out[0]
     = Out[0]

    #> 10
     = 10
    #> Out[-1] + 1
     = 11
    #> Out[] + 1
     = 12
    """"""

    rules = {
        'Out[k_Integer?Negative]': 'Out[$Line + k]',
        'Out[]': 'Out[$Line - 1]',
        'MakeBoxes[Out[k_Integer?((-10 <= # < 0)&)],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'StringJoin[ConstantArray[""%%"", -k]]',
        'MakeBoxes[Out[k_Integer?Positive],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'""%%"" <> ToString[k]',
    }


class Exit(Builtin):
    '''
    <dl>
    <dt>'Exit'
      <dd>terminates the Mathics session.
    <dt>'Exit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Exit is an alias for Quit.
    '''

    def apply(self, evaluation):
        'Exit'
        exit()

    def apply_n(self, n, evaluation):
        'Exit[n_Integer]'
        exit(n.get_int_value())


class Quit(Builtin):
    '''
    <dl>
    <dt>'Quit'
      <dd>terminates the Mathics session.
    <dt>'Quit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Quit is an alias for Exit.
    '''

    rules = {
        'Quit[n_Integer]': 'Exit[n]',
        'Quit': 'Exit',
    }
","#!/usr/bin/env python
# -*- coding: utf-8 -*-


from mathics.builtin.base import Predefined, Builtin
from mathics.core.expression import Integer
from mathics.core.evaluation import MAX_RECURSION_DEPTH, set_python_recursion_limit


class RecursionLimit(Predefined):
    """"""
    <dl>
    <dt>'$RecursionLimit'
        <dd>specifies the maximum allowable recursion depth after
        which a calculation is terminated.
    </dl>

    Calculations terminated by '$RecursionLimit' return '$Aborted':
    >> a = a + a
     : Recursion depth of 200 exceeded.
     = $Aborted
    >> $RecursionLimit
     = 200

    >> $RecursionLimit = x;
     : Cannot set $RecursionLimit to x; value must be an integer between 20 and 512; use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits.

    >> $RecursionLimit = 512
     = 512
    >> a = a + a
     : Recursion depth of 512 exceeded.
     = $Aborted

    #> $RecursionLimit = 20
     = 20
    #> a = a + a
     : Recursion depth of 20 exceeded.
     = $Aborted

    #> $RecursionLimit = 200
     = 200

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$RecursionLimit = 20}, f[0, 100]]
     : Recursion depth of 20 exceeded.
     = $Aborted
    #> ClearAll[f];
    """"""

    name = '$RecursionLimit'
    value = 200

    set_python_recursion_limit(value)

    rules = {
        '$RecursionLimit': str(value),
    }

    messages = {
        'reclim': ""Recursion depth of `1` exceeded."",
        'limset': (
            ""Cannot set $RecursionLimit to `1`; ""
            ""value must be an integer between 20 and %d; ""
            ""use the MATHICS_MAX_RECURSION_DEPTH environment variable to allow higher limits."") % (
                MAX_RECURSION_DEPTH),
    }

    rules = {
        '$RecursionLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class IterationLimit(Predefined):
    """"""
    <dl>
    <dt>'$IterationLimit'
        <dd>specifies the maximum number of times a reevaluation may happen.
    </dl>

    Calculations terminated by '$IterationLimit' return '$Aborted':
    >> ClearAll[f]; f[x_] := f[x + 1];
    >> f[x]
     : Iteration limit of 1000 exceeded.
     = $Aborted
    >> $IterationLimit
     = 1000
    >> ClearAll[f];

    >> $IterationLimit = x;
     : Cannot set $IterationLimit to x; value must be an integer between 20 and Infinity.

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := f[x + 1, n - 1];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     : Iteration limit of 20 exceeded.
     = $Aborted
    #> ClearAll[f];

    #> ClearAll[f];
    #> f[x_, 0] := x; f[x_, n_] := Module[{y = x + 1}, f[y, n - 1]];
    #> Block[{$IterationLimit = 20}, f[0, 100]]
     = 100
    #> ClearAll[f];
    """"""

    name = '$IterationLimit'
    value = 1000

    rules = {
        '$IterationLimit': str(value),
    }

    messages = {
        'itlim': ""Iteration limit of `1` exceeded."",
        'limset': (
            ""Cannot set $IterationLimit to `1`; ""
            ""value must be an integer between 20 and Infinity.""),
    }

    rules = {
        '$IterationLimit': str(value),
    }

    def evaluate(self, evaluation):
        return Integer(self.value)


class Hold(Builtin):
    """"""
    <dl>
    <dt>'Hold[$expr$]'
        <dd>prevents $expr$ from being evaluated.
    </dl>
    >> Attributes[Hold]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)


class HoldComplete(Builtin):
    """"""
    <dl>
    <dt>'HoldComplete[$expr$]'
        <dd>prevents $expr$ from being evaluated, and also prevents
        'Sequence' objects from being spliced into argument lists.
    </dl>
    >> Attributes[HoldComplete]
     = {HoldAllComplete, Protected}
    """"""

    attributes = ('HoldAllComplete',)


class HoldForm(Builtin):
    """"""
    <dl>
    <dt>'HoldForm[$expr$]'
        <dd>is equivalent to 'Hold[$expr$]', but prints as $expr$.
    </dl>

    >> HoldForm[1 + 2 + 3]
     = 1 + 2 + 3

    'HoldForm' has attribute 'HoldAll':
    >> Attributes[HoldForm]
     = {HoldAll, Protected}
    """"""

    attributes = ('HoldAll',)

    rules = {
        'MakeBoxes[HoldForm[expr_], f_]': 'MakeBoxes[expr, f]',
    }


class Evaluate(Builtin):
    """"""
    <dl>
    <dt>'Evaluate[$expr$]'
        <dd>forces evaluation of $expr$, even if it occurs inside a
        held argument or a 'Hold' form.
    </dl>

    Create a function $f$ with a held argument:
    >> SetAttributes[f, HoldAll]
    >> f[1 + 2]
     = f[1 + 2]

    'Evaluate' forces evaluation of the argument, even though $f$ has
    the 'HoldAll' attribute:
    >> f[Evaluate[1 + 2]]
     = f[3]

    >> Hold[Evaluate[1 + 2]]
     = Hold[3]
    >> HoldComplete[Evaluate[1 + 2]]
     = HoldComplete[Evaluate[1 + 2]]
    >> Evaluate[Sequence[1, 2]]
     = Sequence[1, 2]
    """"""

    rules = {
        'Evaluate[Unevaluated[x_]]': 'Unevaluated[x]',
        'Evaluate[x___]': 'x',
    }


class Unevaluated(Builtin):
    """"""
    <dl>
    <dt>'Unevaluated[$expr$]'
        <dd>temporarily leaves $expr$ in an unevaluated form when it
        appears as a function argument.
    </dl>

    'Unevaluated' is automatically removed when function arguments are
    evaluated:
    >> Sqrt[Unevaluated[x]]
     = Sqrt[x]

    >> Length[Unevaluated[1+2+3+4]]
     = 4
    'Unevaluated' has attribute 'HoldAllComplete':
    >> Attributes[Unevaluated]
     = {HoldAllComplete, Protected}

    'Unevaluated' is maintained for arguments to non-executed functions:
    >> f[Unevaluated[x]]
     = f[Unevaluated[x]]
    Likewise, its kept in flattened arguments and sequences:
    >> Attributes[f] = {Flat};
    >> f[a, Unevaluated[f[b, c]]]
     = f[a, Unevaluated[b], Unevaluated[c]]
    >> g[a, Sequence[Unevaluated[b], Unevaluated[c]]]
     = g[a, Unevaluated[b], Unevaluated[c]]
    However, unevaluated sequences are kept:
    >> g[Unevaluated[Sequence[a, b, c]]]
     = g[Unevaluated[Sequence[a, b, c]]]

    #> Attributes[h] = Flat;
    #> h[items___] := Plus[items]
    #> h[1, Unevaluated[Sequence[Unevaluated[2], 3]], Sequence[4, Unevaluated[5]]]
     = 15
    """"""

    attributes = ('HoldAllComplete',)


class ReleaseHold(Builtin):
    """"""
    <dl>
    <dt>'ReleaseHold[$expr$]'
        <dd>removes any 'Hold', 'HoldForm', 'HoldPattern' or
        'HoldComplete' head from $expr$.
    </dl>
    >> x = 3;
    >> Hold[x]
     = Hold[x]
    >> ReleaseHold[Hold[x]]
     = 3
    >> ReleaseHold[y]
     = y
    """"""

    rules = {
        'ReleaseHold[(Hold|HoldForm|HoldPattern|HoldComplete)[expr_]]': 'expr',
        'ReleaseHold[other_]': 'other',
    }


class Sequence(Builtin):
    """"""
    <dl>
    <dt>'Sequence[$x1$, $x2$, ...]'
        <dd>represents a sequence of arguments to a function.
    </dl>

    'Sequence' is automatically spliced in, except when a function has attribute 'SequenceHold'
    (like assignment functions).
    >> f[x, Sequence[a, b], y]
     = f[x, a, b, y]
    >> Attributes[Set]
     = {HoldFirst, Protected, SequenceHold}
    >> a = Sequence[b, c];
    >> a
     = Sequence[b, c]

    Apply 'Sequence' to a list to splice in arguments:
    >> list = {1, 2, 3};
    >> f[Sequence @@ list]
     = f[1, 2, 3]

    Inside 'Hold' or a function with a held argument, 'Sequence' is
    spliced in at the first level of the argument:
    >> Hold[a, Sequence[b, c], d]
     = Hold[a, b, c, d]
    If 'Sequence' appears at a deeper level, it is left unevaluated:
    >> Hold[{a, Sequence[b, c], d}]
     = Hold[{a, Sequence[b, c], d}]
    """"""


class Line(Builtin):
    """"""
    <dl>
    <dt>'$Line'
        <dd>holds the current input line number.
    </dl>
    >> $Line
     = 1
    >> $Line
     = 2
    >> $Line = 12;
    >> 2 * 5
     = 10
    >> Out[13]
     = 10
    >> $Line = -1;
     : Non-negative integer expected.
    """"""

    name = '$Line'


class HistoryLength(Builtin):
    """"""
    <dl>
    <dt>'$HistoryLength'
        <dd>specifies the maximum number of 'In' and 'Out' entries.
    </dl>
    >> $HistoryLength
     = 100
    >> $HistoryLength = 1;
    >> 42
     = 42
    >> %
     = 42
    >> %%
     = %3
    >> $HistoryLength = 0;
    >> 42
     = 42
    >> %
     = %7
    """"""

    name = '$HistoryLength'

    rules = {
        '$HistoryLength': '100',
    }


class In(Builtin):
    """"""
    <dl>
    <dt>'In[$k$]'
        <dd>gives the $k$th line of input.
    </dl>
    >> x = 1
     = 1
    >> x = x + 1
     = 2
    >> Do[In[2], {3}]
    >> x
     = 5
    >> In[-1]
     = 5
    >> Definition[In]
     = Attributes[In] = {Protected}
     .
     . In[6] = Definition[In]
     .
     . In[5] = In[-1]
     .
     . In[4] = x
     .
     . In[3] = Do[In[2], {3}]
     .
     . In[2] = x = x + 1
     .
     . In[1] = x = 1
    """"""

    rules = {
        'In[k_Integer?Negative]': 'In[$Line + k]',
    }


class Out(Builtin):
    """"""
    <dl>
    <dt>'Out[$k$]'
    <dt>'%$k$'
        <dd>gives the result of the $k$th input line.
    <dt>'%', '%%', etc.
        <dd>gives the result of the previous input line, of the line before the previous input line, etc.
    </dl>

    >> 42
     = 42
    >> %
     = 42
    >> 43;
    >> %
     = 43
    >> 44
     = 44
    >> %1
     = 42
    >> %%
     = 44
    >> Hold[Out[-1]]
     = Hold[%]
    >> Hold[%4]
     = Hold[%4]
    >> Out[0]
     = Out[0]

    #> 10
     = 10
    #> Out[-1] + 1
     = 11
    #> Out[] + 1
     = 12
    """"""

    rules = {
        'Out[k_Integer?Negative]': 'Out[$Line + k]',
        'Out[]': 'Out[$Line - 1]',
        'MakeBoxes[Out[k_Integer?((-10 <= # < 0)&)],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'StringJoin[ConstantArray[""%%"", -k]]',
        'MakeBoxes[Out[k_Integer?Positive],'
        '    f:StandardForm|TraditionalForm|InputForm|OutputForm]':
        r'""%%"" <> ToString[k]',
    }


class Exit(Builtin):
    '''
    <dl>
    <dt>'Exit[]'
      <dd>terminates the Mathics session.
    <dt>'Exit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Exit is an alias for Quit.
    '''

    def apply(self, evaluation):
        'Exit[]'
        sys.exit()

    def apply_n(self, n, evaluation):
        'Exit[n_Integer]'
        sys.exit(n.get_int_value())


class Quit(Builtin):
    '''
    <dl>
    <dt>'Quit[]'
      <dd>terminates the Mathics session.
    <dt>'Quit[n]'
      <dd>terminates with exit code $n$.
    </dl>

    Quit is an alias for Exit.
    '''

    rules = {
        'Quit[n_Integer]': 'Exit[n]',
        'Quit[]': 'Exit[]',
    }
",Exit.apply_n,https://github.com/mathics/Mathics/issues/813,"[{'piece_type': 'error message', 'piece_content': 'Copyright (C) 2011-2016 The Mathics Team.\nThis program comes with ABSOLUTELY NO WARRANTY.\nThis is free software, and you are welcome to redistribute it\nunder certain conditions.\nSee the documentation for the full license.\n\nQuit by pressing CONTROL-D\n\nIn[1]:= Quit[]\nTraceback (most recent call last):\nFile ""~/Documents/Mathics/mathics/main.py"", line 303, in <module>\nmain()\nFile ""~/Documents/Mathics/mathics/main.py"", line 286, in main\nresult = evaluation.evaluate(query, timeout=settings.TIMEOUT)\nFile ""~/Documents/Mathics/mathics/core/evaluation.py"", line 288, in evaluate\nresult = run_with_timeout_and_stack(evaluate, timeout)\nFile ""~/Documents/Mathics/mathics/core/evaluation.py"", line 95, in run_with_timeout_and_stack\nreturn request()\nFile ""~/Documents/Mathics/mathics/core/evaluation.py"", line 265, in evaluate\nresult = query.evaluate(self)\nFile ""~/Documents/Mathics/mathics/core/expression.py"", line 853, in evaluate\nexpr, reevaluate = expr.evaluate_next(evaluation)\nFile ""~/Documents/Mathics/mathics/core/expression.py"", line 975, in evaluate_next\nresult = rule.apply(new, evaluation, fully=False)\nFile ""~/Documents/Mathics/mathics/core/rules.py"", line 63, in apply\nyield_match, expression, {}, evaluation, fully=fully)\nFile ""~/Documents/Mathics/mathics/core/pattern.py"", line 203, in match\nyield_head, expression.get_head(), vars, evaluation)\nFile ""~/Documents/Mathics/mathics/core/pattern.py"", line 132, in match\nyield_func(vars, None)\nFile ""~/Documents/Mathics/mathics/core/pattern.py"", line 198, in yield_head\nyield_func(head_vars, None)\nFile ""~/Documents/Mathics/mathics/core/rules.py"", line 39, in yield_match\nnew_expression = self.do_replace(expression, vars, options, evaluation)\nFile ""~/Documents/Mathics/mathics/core/rules.py"", line 124, in do_replace\nreturn self.function(evaluation=evaluation, **vars_noctx)\nFile ""~/Documents/Mathics/mathics/builtin/evaluation.py"", line 465, in apply\nsys.exit()\nNameError: name \'sys\' is not defined'}]","Copyright (C) 2011-2016 The Mathics Team.
This program comes with ABSOLUTELY NO WARRANTY.
This is free software, and you are welcome to redistribute it
under certain conditions.
See the documentation for the full license.

Quit by pressing CONTROL-D

In[1]:= Quit[]
Traceback (most recent call last):
File ""~/Documents/Mathics/mathics/main.py"", line 303, in <module>
main()
File ""~/Documents/Mathics/mathics/main.py"", line 286, in main
result = evaluation.evaluate(query, timeout=settings.TIMEOUT)
File ""~/Documents/Mathics/mathics/core/evaluation.py"", line 288, in evaluate
result = run_with_timeout_and_stack(evaluate, timeout)
File ""~/Documents/Mathics/mathics/core/evaluation.py"", line 95, in run_with_timeout_and_stack
return request()
File ""~/Documents/Mathics/mathics/core/evaluation.py"", line 265, in evaluate
result = query.evaluate(self)
File ""~/Documents/Mathics/mathics/core/expression.py"", line 853, in evaluate
expr, reevaluate = expr.evaluate_next(evaluation)
File ""~/Documents/Mathics/mathics/core/expression.py"", line 975, in evaluate_next
result = rule.apply(new, evaluation, fully=False)
File ""~/Documents/Mathics/mathics/core/rules.py"", line 63, in apply
yield_match, expression, {}, evaluation, fully=fully)
File ""~/Documents/Mathics/mathics/core/pattern.py"", line 203, in match
yield_head, expression.get_head(), vars, evaluation)
File ""~/Documents/Mathics/mathics/core/pattern.py"", line 132, in match
yield_func(vars, None)
File ""~/Documents/Mathics/mathics/core/pattern.py"", line 198, in yield_head
yield_func(head_vars, None)
File ""~/Documents/Mathics/mathics/core/rules.py"", line 39, in yield_match
new_expression = self.do_replace(expression, vars, options, evaluation)
File ""~/Documents/Mathics/mathics/core/rules.py"", line 124, in do_replace
return self.function(evaluation=evaluation, **vars_noctx)
File ""~/Documents/Mathics/mathics/builtin/evaluation.py"", line 465, in apply
sys.exit()
NameError: name 'sys' is not defined",NameError,"    def apply_n(self, n, evaluation):
        
        sys.exit(n.get_int_value())","    def apply_n(self, n, evaluation):
        
        exit(n.get_int_value())",[],[],buggy_snippets_files/fdb8c2c5e1430f73fc95e1563cda6b41eb7f96930b9d9340d2efadb969fcea30_before_merge.py,buggy_snippets_files/fdb8c2c5e1430f73fc95e1563cda6b41eb7f96930b9d9340d2efadb969fcea30_after_merge.py
