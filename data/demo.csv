规则,描述,问题代码样例,问题解释,修复代码样例
@performance/high-frequency-log-check,"不建议在高频函数中使用Hilog。

高频函数包括：onTouch、onItemDragMove、onDragMove、onMouse、onVisibleAreaChange、onAreaChange、onScroll、onActionUpdate。","// Test.ets
import hilog from '@ohos.hilog';
@Entry
@Component
struct Index {
    build() {
            Column() {
                Scroll()
                    .onScroll(() => {
                        hilog.info(1001, 'Index', 'onScroll') // Avoid printing logs
                })
            }
    }
}",在滚动组件中触发滚动属于高频事件，而 onScroll 函数会在每次滚动时被触发。如果在 onScroll 函数中使用 hilog.info 进行日志记录，就会导致每次滚动操作都进行一次日志记录，这样的高频操作会对性能造成负面影响。通过移除高频函数中的 hilog 调用，减少了不必要的日志输出，从而降低了对系统性能的影响。,"// Test.ets
@Entry
@Component
struct Index {
  build() {
      Column() {
        Scroll()
          .onScroll(() => {
            const TAG = 'onScroll';
          })
      }
  }
}"
@performance/high-frequency-log-check,"不建议在高频函数中使用Hilog。

高频函数包括：onTouch、onItemDragMove、onDragMove、onMouse、onVisibleAreaChange、onAreaChange、onScroll、onActionUpdate。","import hilog from '@ohos.hilog';
@Entry
@Component
struct Index {
  build() {
    Button(""XXX"")
      .width(200)
      .height(100)
      .onTouch(() => {
        hilog.info(1001, 'Index', 'onTouch') // Avoid printing logs
      })
  }
}",在触摸事件中，onTouch 函数会在每次触摸时被触发。如果在 onTouch 函数中使用 hilog.debug 进行日志记录，就会导致每次触摸操作都进行一次日志记录，这样的高频操作会对性能造成负面影响。通过移除高频函数中的 hilog 调用，减少了不必要的日志输出，从而降低了对系统性能的影响。,"@Entry
@Component
struct Index {
  build() {
    Button(""XXX"")
      .width(200)
      .height(100)
      .onTouch(() => {
        const TAG = 'onTouch';
      })
  }
}"
@performance/high-frequency-log-check,"不建议在高频函数中使用Hilog。

高频函数包括：onTouch、onItemDragMove、onDragMove、onMouse、onVisibleAreaChange、onAreaChange、onScroll、onActionUpdate。","import hilog from '@ohos.hilog';
@Entry
@Component
struct Index {
  build() {
    Row(){
      Image(""XXX"")
        .width(200)
        .height(100)
        .draggable(true)
        .margin({ left: 15 })
        .border({ color: Color.Black, width: 1 })
        .onDragMove(() => {
          hilog.info(1001, 'Index', 'onDragMove')
      })
    }
  }
}",在拖拽组件中，onDragMove 函数会在每次拖动时被触发。如果在 onDragMove 函数中使用 hilog.warn 进行日志记录，就会导致每次拖动操作都进行一次日志记录，这样的高频操作会对性能造成负面影响。通过移除高频函数中的 hilog 调用，减少了不必要的日志输出，从而降低了对系统性能的影响。,"@Entry
@Component
struct Index {
  build() {
    Row(){
      Image(""XXX"")
        .width(200)
        .height(100)
        .draggable(true)
        .margin({ left: 15 })
        .border({ color: Color.Black, width: 1 })
        .onDragMove(() => {
          const TAG = 'onDragMove';
        })
    }
  }
}"
@performance/high-frequency-log-check,"不建议在高频函数中使用Hilog。

高频函数包括：onTouch、onItemDragMove、onDragMove、onMouse、onVisibleAreaChange、onAreaChange、onScroll、onActionUpdate。","import hilog from '@ohos.hilog';
@Entry
@Component
struct Index {
  build() {
    Button("""")
      .width(200)
      .height(100)
      .onMouse(() => {
        hilog.info(1001, 'Index', 'onMouse')
      })
  }
}",在鼠标事件中，onMouse 函数会在每次鼠标操作时被触发。如果在 onMouse 函数中使用 hilog.error 进行日志记录，就会导致每次鼠标操作都进行一次日志记录，这样的高频操作会对性能造成负面影响。通过移除高频函数中的 hilog 调用，减少了不必要的日志输出，从而降低了对系统性能的影响。,"@Entry
@Component
struct Index {
  build() {
    Button("""")
      .width(200)
      .height(100)
      .onMouse(() => {
        const TAG = 'onMouse';
      })
  }
}"
@performance/high-frequency-log-check,"不建议在高频函数中使用Hilog。

高频函数包括：onTouch、onItemDragMove、onDragMove、onMouse、onVisibleAreaChange、onAreaChange、onScroll、onActionUpdate。","import hilog from '@ohos.hilog';
@Entry
@Component
struct Index {
  build() {
    Row() {
      Slider({ value: 0, min: 0, max: 100 })
        .enabled(false)
        .height(4)
        .width(100)
        .trackThickness(3)
        .blockColor(Color.Red)
        .blockSize({ width: 4, height: 4 })
        .onVisibleAreaChange([0.0, 1.0], (isVisible: boolean, currentRatio: number) => {
          hilog.info(1001, 'Index', 'onVisibleAreaChange') // Avoid printing logs
        })
    }
  }
}",在可见区域变化事件中，onVisibleAreaChange 函数会在每次可见区域变化时被触发。如果在 onVisibleAreaChange 函数中使用 hilog.info 进行日志记录，就会导致每次可见区域变化操作都进行一次日志记录，这样的高频操作会对性能造成负面影响。通过移除高频函数中的 hilog 调用，减少了不必要的日志输出，从而降低了对系统性能的影响。,"@Entry
@Component
struct Index {
  build() {
    Row() {
      Slider({ value: 0, min: 0, max: 100 })
        .enabled(false)
        .height(4)
        .width(100)
        .trackThickness(3)
        .blockColor(Color.Red)
        .blockSize({ width: 4, height: 4 })
        .onVisibleAreaChange([0.0, 1.0], (isVisible: boolean, currentRatio: number) => {
          const TAG = 'onVisibleAreaChange';
        })
    }
  }
}"
@performance/no-high-loaded-frame-rate-range,不允许锁定最高帧率运行。,"let sync: displaySync.DisplaySync = displaySync.create();
sync.setExpectedFrameRateRange({
  expected: 120,
  min: 120,
  max: 120,
});",在给定的代码中，通过调用 setExpectedFrameRateRange 方法，将帧率锁定在 120 帧每秒 (FPS)，会对设备的 CPU 和 GPU 造成很大的性能负担，尤其是在移动设备上。通过将帧率范围设置为 45-60 FPS，可以确保应用在大多数设备上都能稳定运行，同时不会对设备造成不必要的性能负担。这样可以平衡性能和电池消耗，同时确保用户体验的一致性。,"let sync: displaySync.DisplaySync = displaySync.create();
sync.setExpectedFrameRateRange({
  expected: 60,
  min: 45,
  max: 60,
});"
@performance/no-high-loaded-frame-rate-range,不允许锁定最高帧率运行。,"let range : ExpectedFrameRateRange = {
  expected: 120,
  min: 120,
  max: 120
};
let backDisplaySyncSlow: displaySync.DisplaySync;
backDisplaySyncSlow = displaySync.create();
backDisplaySyncSlow.setExpectedFrameRateRange(range);",在给定的代码中，通过调用 setExpectedFrameRateRange 方法，将帧率锁定在 120 帧每秒 (FPS)，会对设备的 CPU 和 GPU 造成很大的性能负担，尤其是在移动设备上。通过将帧率范围设置为 0-30 FPS，可以确保应用在大多数设备上都能稳定运行，同时不会对设备造成不必要的性能负担。这样可以平衡性能和电池消耗，同时确保用户体验的一致性。,"let range : ExpectedFrameRateRange = {
  expected: 30,
  min: 0,
  max: 120
};
let backDisplaySyncSlow: displaySync.DisplaySync;
backDisplaySyncSlow = displaySync.create();
backDisplaySyncSlow.setExpectedFrameRateRange(range);"
@performance/no-high-loaded-frame-rate-range,不允许锁定最高帧率运行。,"@Entry
@Component
struct Index {
  build() {
    Button()
      .onClick(() => {
        animateTo({
          duration: 1200,
          iterations: 10,
          expectedFrameRateRange: { 
            expected: 120,
            min: 120,
            max: 120,
          },
        }, () => {
        })
      })
  }
}",在给定的代码中，通过设置expectedFrameRateRange ，将帧率锁定在 120 帧每秒 (FPS)，会对设备的 CPU 和 GPU 造成很大的性能负担，尤其是在移动设备上。通过将帧率范围设置为 0-120 FPS，可以确保应用在大多数设备上都能稳定运行，同时不会对设备造成不必要的性能负担。这样可以平衡性能和电池消耗，同时确保用户体验的一致性。,"@Entry
@Component
struct Index {
  build() {
    Button()
      .onClick(() => {
        animateTo({
          duration: 1200,
          iterations: 10,
          expectedFrameRateRange: { 
            expected: 30,
            min: 0,
            max: 120,
          },
        }, () => {
        })
      })
  }
}"
@performance/no-high-loaded-frame-rate-range,不允许锁定最高帧率运行。,"Slider({ value: this.curTime, min: 0, max: 100 })
  .enabled(false)
  .height(4)
  .width(this.xComponentWidth)
  .trackThickness(3)
  .blockColor(Color.Red)
  .blockSize({ width: 4, height: 4 })
  .onVisibleAreaChange([0.0, 1.0], (isVisible: boolean, currentRatio: number) => {
    if (isVisible && currentRatio >= 1.0) {
      animateTo({
        duration: 30000,
        iterations: -1,
        expectedFrameRateRange: {
          expected: 120,
          min: 120,
          max: 120,
        },
      }, () => {
        if (this.curTime >= 100) {
          this.curTime = 0;
        }
        for (let i = 0; i < 101; i++) {
          this.curTime += 1;
        }
      })
    }
  })",在给定的代码中，通过设置expectedFrameRateRange ，将帧率锁定在 120 帧每秒 (FPS)，会对设备的 CPU 和 GPU 造成很大的性能负担，尤其是在移动设备上。通过将帧率范围设置为 0-120 FPS，可以确保应用在大多数设备上都能稳定运行，同时不会对设备造成不必要的性能负担。这样可以平衡性能和电池消耗，同时确保用户体验的一致性。,"Slider({ value: this.curTime, min: 0, max: 100 })
  .enabled(false)
  .height(4)
  .width(this.xComponentWidth)
  .trackThickness(3)
  .blockColor(Color.Red)
  .blockSize({ width: 4, height: 4 })
  .onVisibleAreaChange([0.0, 1.0], (isVisible: boolean, currentRatio: number) => {
    if (isVisible && currentRatio >= 1.0) {
      animateTo({
        duration: 30000,
        iterations: -1,
        expectedFrameRateRange: {
          expected: 30,
          min: 0,
          max: 120,
        },
      }, () => {
        if (this.curTime >= 100) {
          this.curTime = 0;
        }
        for (let i = 0; i < 101; i++) {
          this.curTime += 1;
        }
      })
    }
  })"
@performance/no-high-loaded-frame-rate-range,不允许锁定最高帧率运行。,"CreateDisplaySyncSlow() {
    let range : ExpectedFrameRateRange = {
      expected: 120,
      min: 120,
      max: 120
    };

    let draw30 = (intervalInfo: displaySync.IntervalInfo) => {
      if (this.isBigger_30) {
        this.drawFirstSize += 1;
        if (this.drawFirstSize > 150) {
          this.isBigger_30 = false;
        }
      } else {
        this.drawFirstSize -= 1;
        if (this.drawFirstSize < 25) {
          this.isBigger_30 = true;
        }
      }
    };

    this.backDisplaySyncSlow = displaySync.create();
    this.backDisplaySyncSlow.setExpectedFrameRateRange(range);
    this.backDisplaySyncSlow.on(""frame"", draw30);
}",在给定的代码中，通过设置expectedFrameRateRange ，将帧率锁定在 120 帧每秒 (FPS)，会对设备的 CPU 和 GPU 造成很大的性能负担，尤其是在移动设备上。通过将帧率范围设置为 0-120 FPS，可以确保应用在大多数设备上都能稳定运行，同时不会对设备造成不必要的性能负担。这样可以平衡性能和电池消耗，同时确保用户体验的一致性。,"CreateDisplaySyncSlow() {
    let range : ExpectedFrameRateRange = {
      expected: 30,
      min: 0,
      max: 120
    };

    let draw30 = (intervalInfo: displaySync.IntervalInfo) => {
      if (this.isBigger_30) {
        this.drawFirstSize += 1;
        if (this.drawFirstSize > 150) {
          this.isBigger_30 = false;
        }
      } else {
        this.drawFirstSize -= 1;
        if (this.drawFirstSize < 25) {
          this.isBigger_30 = true;
        }
      }
    };

    this.backDisplaySyncSlow = displaySync.create();
    this.backDisplaySyncSlow.setExpectedFrameRateRange(range);
    this.backDisplaySyncSlow.on(""frame"", draw30);
}"
"@performance/number-init-check
",该规则将检查number是否正确使用。,"let intNum = 1;
intNum = 1.1; ",intNum被声明为int类型。应当避免将其转换成float类型,"let intNum = 1;
intNum = 2;"
"@performance/number-init-check
",该规则将检查number是否正确使用。,"let floatNum = 1.3;
floatNum = 2; ",floatNum被声明为float类型。应当避免将其转换成int类型,"let floatNum = 1.3;
floatNum = 2.4;"
"@performance/number-init-check
",该规则将检查number是否正确使用。,"let intNum = 3;
let floatNum = 2.5;
floatNum = 4; 
intNum = 1.8; ","intNum被声明为int类型。应当避免将其转换成float类型
floatNum被声明为float类型。应当避免将其转换成int类型","let intNum = 3;
let floatNum = 2.5;
intNum = 4;
floatNum = 1.8;"
"@performance/number-init-check
",该规则将检查number是否正确使用。,"let intNum1: number = 2, intNum2: number = 1;
intNum1 = 3.5;
intNum2 = 4.3;",intNum被声明为int类型。应当避免将其转换成float类型,"let intNum1: number = 2, intNum2: number = 1;
intNum1 = 3;
intNum2 = 4;"
"@performance/number-init-check
",该规则将检查number是否正确使用。,"let floatNum1: number = 2.5, floatNum2: number = 1.5;
floatNum1 = 3;
floatNum2 = 4;",floatNum被声明为float类型。应当避免将其转换成int类型,"let floatNum1: number = 2.5, floatNum2: number = 1.5;
floatNum1 = 3.5;
floatNum2 = 4.3;"
@performance/sparse-array-check,建议避免使用稀疏数组。,"let count = 100000;
let result: number[] = new Array(count);
result = new Array();
result[9999] = 0;","初始创建了一个长度为100000的数组 result，将数组重新初始化为空数组，然后在特定位置9999进行赋值。这种方式创建了一个稀疏数组，大部分元素仍然未定义，内存中保留了大量无效空间。
应当直接创建一个紧凑且仅包含需要元素的数组，确保内存使用高效。例如，在索引""3""处进行赋值，而不是在一个稀疏数组中进行赋值操作。","let index = 3;
let result: number[] = [];
result[index] = 0;"
@performance/sparse-array-check,建议避免使用稀疏数组。,"let stringArray: string[] = [];
stringArray[5000] = 'example';",稀疏数组在索引 5000 处赋值，其余位置都未定义，导致内存浪费和性能问题。应直接创建一个包含需要元素的紧凑数组，避免稀疏数组的使用,"let stringArray: string[] = [];
stringArray[0] = 'example';"
@performance/sparse-array-check,建议避免使用稀疏数组。,"let largeArray: number[] = new Array(1000);
largeArray[999] = 42;",创建了一个长度为 1000 的数组，但只在索引 999 处赋值。此时，数组大部分元素未定义，造成内存浪费。应直接创建一个包含所需元素的数组。,"let largeArray: number[] = new Array();
largeArray.push(42);"
@performance/sparse-array-check,建议避免使用稀疏数组。,"let array: string[] = new Array(10005);
array[9998] = 'end';",创建了一个长度为10005的数组，并在索引9998处赋值，造成大部分元素未定义，内存中存在大量无效空间。应使用紧凑数组，避免稀疏数组。,let array: string[] = ['end'];
@performance/sparse-array-check,建议避免使用稀疏数组。,"let numbers: number[] = [];
numbers[100] = 1;
numbers[1000] = 2;
numbers[10000] = 3;",稀疏数组中仅在索引 100、1000 和 10000 处赋值，其他位置均未定义，导致内存浪费和性能下降。应当创建一个紧凑的数组，避免稀疏数组的使用。,"let numbers: number[] = [1, 2, 3];"
@performance/typed-array-check,数值数组推荐使用TypedArray。,"const typedArray1: number[] = new Array(1, 2, 3);
const typedArray2: number[] = new Array(4, 5, 6);
let res: number[] = new Array(3);
for (let i = 0; i < 3; i++) {
     res[i] = typedArray1[i] + typedArray2[i];
}","原代码使用普通的 number[] 数组来存储数值。这种做法在处理大量数值数据时效率较低，因为普通数组没有经过优化，性能可能较差。
应改用 TypedArray（如 Int8Array）来代替普通数组。TypedArray 是专门为数值数据设计的数据结构，它们在内存使用和性能方面都经过优化，适合高效处理大量数值数据。","const typedArray1 = new Int8Array([1, 2, 3]); 
const typedArray2 = new Int8Array([4, 5, 6]);  
let res = new Int8Array(3);
for (let i = 0; i < 3; i++) {
     res[i] = typedArray1[i] + typedArray2[i];
}"
@performance/typed-array-check,数值数组推荐使用TypedArray。,"const arr1: number[] = [1, 2, 3, 4, 5];
const arr2: number[] = [6, 7, 8, 9, 10];
let sumArray: number[] = new Array(arr1.length);
for (let i = 0; i < arr1.length; i++) {
  sumArray[i] = arr1[i] + arr2[i];
}",原代码使用普通的 number[] 数组来存储数值，这种做法在处理大量数值数据时效率较低，因为普通数组没有经过优化，性能可能较差。应改用 TypedArray（如 Int8Array）来代替普通数组。TypedArray 是专门为数值数据设计的数据结构，在内存使用和性能方面都经过优化，更适合高效处理大量数值数据。,"const arr1 = new Int8Array([1, 2, 3, 4, 5]);
const arr2 = new Int8Array([6, 7, 8, 9, 10]);
let sumArray = new Int8Array(arr1.length);
for (let i = 0; i < arr1.length; i++) {
    sumArray[i] = arr1[i] + arr2[i];
}"
@performance/typed-array-check,数值数组推荐使用TypedArray。,"let floatArray: number[] = [1.1, 2.2, 3.3, 4.4, 5.5];
let doubleArray: number[] = new Array(floatArray.length);
for (let i = 0; i < floatArray.length; i++) {
  doubleArray[i] = floatArray[i] * 2;
}",原代码使用普通的 number[] 数组来存储数值，这种做法在处理大量数值数据时效率较低。通过使用 Float32Array 可以提高内存使用效率和性能。,"let floatArray = new Float32Array([1.1, 2.2, 3.3, 4.4, 5.5]);
let doubleArray = new Float32Array(floatArray.length);
for (let i = 0; i < floatArray.length; i++) {
    doubleArray[i] = floatArray[i] * 2;
}"
@performance/typed-array-check,数值数组推荐使用TypedArray。,"const matrix: number[][] = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
];
const result: number[] = new Array(matrix.length);
for (let i = 0; i < matrix.length; i++) {
  result[i] = matrix[i][i];
}",原代码使用普通的 number[][] 数组来存储数值。这种做法在处理大量数值数据时效率较低。使用 Float64Array 可以提高内存使用效率和性能。,"const matrix = [
  new Float64Array([1, 2, 3]),
  new Float64Array([4, 5, 6]),
  new Float64Array([7, 8, 9])
];
const result = new Float64Array(matrix.length);
for (let i = 0; i < matrix.length; i++) {
  result[i] = matrix[i][i];
}"
@performance/typed-array-check,数值数组推荐使用TypedArray。,"let bigNumbers: number[] = new Array(10000);
for (let i = 0; i < bigNumbers.length; i++) {
    bigNumbers[i] = i * 2;
}",原代码使用普通的 number[] 数组来存储大量的数值，这种做法在处理大量数值数据时效率较低，因为普通数组没有经过优化，性能可能较差。应改用 TypedArray（如 Uint16Array）来代替普通数组。TypedArray 是专门为数值数据设计的数据结构，在内存使用和性能方面都经过优化，更适合高效处理大量数值数据。,"let bigNumbers = new Uint16Array(10000);
for (let i = 0; i < bigNumbers.length; i++) {
    bigNumbers[i] = i * 2;
}
"
@performance/waterflow-data-preload-check,建议对waterflow子组件进行数据预加载。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .width('100%')
    .height(this.itemHeightArray[item % 100])
    .backgroundColor(this.colors[item % 5])
  }, (item: string) => item)
}
.onReachEnd(() => {
  console.info(""onReachEnd"")
  setTimeout(() => {
    for (let i = 0; i < 100; i++) {
      this.datasource.AddLastItem()
    }
  }, 1000)
})",在 onReachEnd 事件中加载更多数据可能会导致滚动到底部时的卡顿。通过提前检测 FlowItem 的出现并预加载数据，可以避免这种情况。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .onAppear(() => {
      if (item + 20 == this.dataSource.totalCount()) {
        for (let i = 0; i < 100; i++) {
          this.dataSource.addLastItem()
        }
      }
    })
    .width('100%')
    .height(this.itemHeightArray[item % 100])
    .backgroundColor(this.colors[item % 5])
  }, (item: string) => item)
}"
@performance/waterflow-data-preload-check,建议对waterflow子组件进行数据预加载。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .width('100%')
    .height(this.itemHeightArray[item % 100])
    .backgroundColor(this.colors[item % 5])
  }, (item: string) => item)
}
.onReachEnd(() => {
  console.info(""onReachEnd"")
  setTimeout(() => {
    for (let i = 0; i < 50; i++) {
      this.datasource.addNewItem()
    }
  }, 500)
})
",在 onReachEnd 事件中加载更多数据可能会导致滚动到底部时的卡顿。通过提前检测 FlowItem 的出现并预加载数据，可以避免这种情况。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .onAppear(() => {
      if (item + 20 == this.dataSource.totalCount()) {
        for (let i = 0; i < 50; i++) {
          this.dataSource.addNewItem()
        }
      }
    })
    .width('100%')
    .height(this.itemHeightArray[item % 100])
    .backgroundColor(this.colors[item % 5])
  }, (item: string) => item)
}
"
@performance/waterflow-data-preload-check,建议对waterflow子组件进行数据预加载。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .width('100%')
    .height(this.itemHeightArray[item % 50])
    .backgroundColor(this.colors[item % 3])
  }, (item: string) => item)
}
.onReachEnd(() => {
  console.info(""End of List"")
  for (let i = 0; i < 30; i++) {
    this.dataSource.appendItem()
  }
})
",在 onReachEnd 事件中加载更多数据可能会导致滚动到底部时的卡顿。通过提前检测 FlowItem 的出现并预加载数据，可以避免这种情况。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .onAppear(() => {
      if (item + 15 == this.dataSource.totalCount()) {
        for (let i = 0; i < 30; i++) {
          this.dataSource.appendItem()
        }
      }
    })
    .width('100%')
    .height(this.itemHeightArray[item % 50])
    .backgroundColor(this.colors[item % 3])
  }, (item: string) => item)
}
"
@performance/waterflow-data-preload-check,建议对waterflow子组件进行数据预加载。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .width('100%')
    .height(this.itemHeightArray[item % 20])
    .backgroundColor(this.colors[item % 4])
  }, (item: string) => item)
}
.onReachEnd(() => {
  console.info(""Loading more items"")
  for (let i = 0; i < 20; i++) {
    this.dataSource.addMoreItems()
  }
})
",在 onReachEnd 事件中加载更多数据可能会导致滚动到底部时的卡顿。通过提前检测 FlowItem 的出现并预加载数据，可以避免这种情况。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .onAppear(() => {
      if (item + 10 == this.dataSource.totalCount()) {
        for (let i = 0; i < 20; i++) {
          this.dataSource.addMoreItems()
        }
      }
    })
    .width('100%')
    .height(this.itemHeightArray[item % 20])
    .backgroundColor(this.colors[item % 4])
  }, (item: string) => item)
}
"
@performance/waterflow-data-preload-check,建议对waterflow子组件进行数据预加载。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .width('100%')
    .height(this.itemHeightArray[item % 80])
    .backgroundColor(this.colors[item % 2])
  }, (item: string) => item)
}
.onReachEnd(() => {
  console.info(""End reached"")
  setTimeout(() => {
    for (let i = 0; i < 40; i++) {
      this.dataSource.addItems()
    }
  }, 1000)
})
",在 onReachEnd 事件中加载更多数据可能会导致滚动到底部时的卡顿。通过提前检测 FlowItem 的出现并预加载数据，可以避免这种情况。,"WaterFlow() {
  LazyForEach(this.dataSource, (item: number) => {
    FlowItem() {
      ReusableFlowItem({ item: item })
    }
    .onAppear(() => {
      if (item + 25 == this.dataSource.totalCount()) {
        for (let i = 0; i < 40; i++) {
          this.dataSource.addItems()
        }
      }
    })
    .width('100%')
    .height(this.itemHeightArray[item % 80])
    .backgroundColor(this.colors[item % 2])
  }, (item: string) => item)
}
"
